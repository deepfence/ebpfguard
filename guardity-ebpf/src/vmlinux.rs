/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type __s8 = ::aya_bpf::cty::c_schar;
pub type __u8 = ::aya_bpf::cty::c_uchar;
pub type __s16 = ::aya_bpf::cty::c_short;
pub type __u16 = ::aya_bpf::cty::c_ushort;
pub type __s32 = ::aya_bpf::cty::c_int;
pub type __u32 = ::aya_bpf::cty::c_uint;
pub type __s64 = ::aya_bpf::cty::c_longlong;
pub type __u64 = ::aya_bpf::cty::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_long_t = ::aya_bpf::cty::c_long;
pub type __kernel_ulong_t = ::aya_bpf::cty::c_ulong;
pub type __kernel_pid_t = ::aya_bpf::cty::c_int;
pub type __kernel_uid32_t = ::aya_bpf::cty::c_uint;
pub type __kernel_gid32_t = ::aya_bpf::cty::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_loff_t = ::aya_bpf::cty::c_longlong;
pub type __kernel_time64_t = ::aya_bpf::cty::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::aya_bpf::cty::c_int;
pub type __kernel_clockid_t = ::aya_bpf::cty::c_int;
pub type __poll_t = ::aya_bpf::cty::c_uint;
pub type __kernel_dev_t = u32_;
pub type dev_t = __kernel_dev_t;
pub type umode_t = ::aya_bpf::cty::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type gfp_t = ::aya_bpf::cty::c_uint;
pub type fmode_t = ::aya_bpf::cty::c_uint;
pub type phys_addr_t = u64_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub counter: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut callback_head)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const ::aya_bpf::cty::c_char,
    pub fs_flags: ::aya_bpf::cty::c_int,
    pub init_fs_context: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf::cty::c_int,
    >,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: ::aya_bpf::cty::c_int,
    pub name_offset: ::aya_bpf::cty::c_int,
    pub namespace_offset: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ::aya_bpf::cty::c_int,
    pub burst: ::aya_bpf::cty::c_int,
    pub printed: ::aya_bpf::cty::c_int,
    pub missed: ::aya_bpf::cty::c_int,
    pub begin: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pi_entry {
    pub fmt: *const ::aya_bpf::cty::c_char,
    pub func: *const ::aya_bpf::cty::c_char,
    pub file: *const ::aya_bpf::cty::c_char,
    pub line: ::aya_bpf::cty::c_uint,
    pub level: *const ::aya_bpf::cty::c_char,
    pub subsys_fmt_prefix: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ::aya_bpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: ::aya_bpf::cty::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
}
pub mod module_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MODULE_STATE_LIVE: Type = 0;
    pub const MODULE_STATE_COMING: Type = 1;
    pub const MODULE_STATE_GOING: Type = 2;
    pub const MODULE_STATE_UNFORMED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const ::aya_bpf::cty::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: ::aya_bpf::cty::c_uint,
        state_in_sysfs: ::aya_bpf::cty::c_uint,
        state_add_uevent_sent: ::aya_bpf::cty::c_uint,
        state_remove_uevent_sent: ::aya_bpf::cty::c_uint,
        uevent_suppress: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::aya_bpf::cty::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_layout {
    pub base: *mut ::aya_bpf::cty::c_void,
    pub size: ::aya_bpf::cty::c_uint,
    pub text_size: ::aya_bpf::cty::c_uint,
    pub ro_size: ::aya_bpf::cty::c_uint,
    pub ro_after_init_size: ::aya_bpf::cty::c_uint,
    pub mtn: mod_tree_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_arch_specific {
    pub num_orcs: ::aya_bpf::cty::c_uint,
    pub orc_unwind_ip: *mut ::aya_bpf::cty::c_int,
    pub orc_unwind: *mut orc_entry,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: ::aya_bpf::cty::c_uint,
    pub strtab: *mut ::aya_bpf::cty::c_char,
    pub typetab: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state::Type,
    pub list: list_head,
    pub name: [::aya_bpf::cty::c_char; 56usize],
    pub build_id: [::aya_bpf::cty::c_uchar; 20usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const ::aya_bpf::cty::c_char,
    pub srcversion: *const ::aya_bpf::cty::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: ::aya_bpf::cty::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: ::aya_bpf::cty::c_uint,
    pub num_gpl_syms: ::aya_bpf::cty::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub using_gplonly_symbols: bool_,
    pub sig_ok: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: ::aya_bpf::cty::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf::cty::c_int>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: ::aya_bpf::cty::c_ulong,
    pub num_bugs: ::aya_bpf::cty::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut ::aya_bpf::cty::c_char,
    pub percpu: *mut ::aya_bpf::cty::c_void,
    pub percpu_size: ::aya_bpf::cty::c_uint,
    pub noinstr_text_start: *mut ::aya_bpf::cty::c_void,
    pub noinstr_text_size: ::aya_bpf::cty::c_uint,
    pub num_tracepoints: ::aya_bpf::cty::c_uint,
    pub tracepoints_ptrs: *const ::aya_bpf::cty::c_int,
    pub num_srcu_structs: ::aya_bpf::cty::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub num_bpf_raw_events: ::aya_bpf::cty::c_uint,
    pub bpf_raw_events: *mut bpf_raw_event_map,
    pub btf_data_size: ::aya_bpf::cty::c_uint,
    pub btf_data: *mut ::aya_bpf::cty::c_void,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: ::aya_bpf::cty::c_uint,
    pub num_trace_bprintk_fmt: ::aya_bpf::cty::c_uint,
    pub trace_bprintk_fmt_start: *mut *const ::aya_bpf::cty::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: ::aya_bpf::cty::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: ::aya_bpf::cty::c_uint,
    pub num_ftrace_callsites: ::aya_bpf::cty::c_uint,
    pub ftrace_callsites: *mut ::aya_bpf::cty::c_ulong,
    pub kprobes_text_start: *mut ::aya_bpf::cty::c_void,
    pub kprobes_text_size: ::aya_bpf::cty::c_uint,
    pub kprobe_blacklist: *mut ::aya_bpf::cty::c_ulong,
    pub num_kprobe_blacklist: ::aya_bpf::cty::c_uint,
    pub num_static_call_sites: ::aya_bpf::cty::c_int,
    pub static_call_sites: *mut static_call_site,
    pub klp: bool_,
    pub klp_alive: bool_,
    pub klp_info: *mut klp_modinfo,
    pub printk_index_size: ::aya_bpf::cty::c_uint,
    pub printk_index_start: *mut *mut pi_entry,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ei_funcs: *mut error_injection_entry,
    pub num_ei_funcs: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: ::aya_bpf::cty::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: *const kernel_param,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_char,
            arg2: *const kernel_param,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
}
pub type fl_owner_t = *mut ::aya_bpf::cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::aya_bpf::cty::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kiocb,
            arg2: *mut io_comp_batch,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf::cty::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::aya_bpf::cty::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub mmap_supported_flags: ::aya_bpf::cty::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf::cty::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: fl_owner_t) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf::cty::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf::cty::c_int,
            arg2: *mut file,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut file_lock,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_int,
            arg4: usize,
            arg5: *mut loff_t,
            arg6: ::aya_bpf::cty::c_int,
        ) -> isize,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: ::aya_bpf::cty::c_ulong,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
    pub check_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut file_lock,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> isize,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_int,
            arg3: loff_t,
            arg4: loff_t,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: ::aya_bpf::cty::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: loff_t,
            arg6: ::aya_bpf::cty::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_group {
    pub name: *const ::aya_bpf::cty::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: ::aya_bpf::cty::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: ::aya_bpf::cty::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_mod {
    pub next: *mut static_call_mod,
    pub mod_: *mut module,
    pub sites: *mut static_call_site,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: ::aya_bpf::cty::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_info {
    pub flags: ::aya_bpf::cty::c_ulong,
    pub syscall_work: ::aya_bpf::cty::c_ulong,
    pub status: u32_,
    pub cpu: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ::aya_bpf::cty::c_uint,
    pub a_flags: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct load_weight {
    pub weight: ::aya_bpf::cty::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct util_est {
    pub enqueued: ::aya_bpf::cty::c_uint,
    pub ewma: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: ::aya_bpf::cty::c_ulong,
    pub runnable_avg: ::aya_bpf::cty::c_ulong,
    pub util_avg: ::aya_bpf::cty::c_ulong,
    pub util_est: util_est,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: ::aya_bpf::cty::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub nr_migrations: u64_,
    pub depth: ::aya_bpf::cty::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub avg: sched_avg,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: ::aya_bpf::cty::c_ulong,
    pub watchdog_stamp: ::aya_bpf::cty::c_ulong,
    pub time_slice: ::aya_bpf::cty::c_uint,
    pub on_rq: ::aya_bpf::cty::c_ushort,
    pub on_list: ::aya_bpf::cty::c_ushort,
    pub back: *mut sched_rt_entity,
}
pub type ktime_t = s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
pub mod hrtimer_restart {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const HRTIMER_NORESTART: Type = 0;
    pub const HRTIMER_RESTART: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart::Type>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub pi_se: *mut sched_dl_entity,
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: ::aya_bpf::cty::c_uint,
        dl_yielded: ::aya_bpf::cty::c_uint,
        dl_non_contending: ::aya_bpf::cty::c_uint,
        dl_overrun: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub sum_block_runtime: s64,
    pub exec_max: u64_,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
    pub core_forceidle_sum: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl sched_statistics {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpumask {
    pub bits: [::aya_bpf::cty::c_ulong; 128usize],
}
pub type cpumask_t = cpumask;
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_info {
    pub pcount: ::aya_bpf::cty::c_ulong,
    pub run_delay: ::aya_bpf::cty::c_ulonglong,
    pub last_arrival: ::aya_bpf::cty::c_ulonglong,
    pub last_queued: ::aya_bpf::cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: ::aya_bpf::cty::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
pub mod timespec_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TT_NONE: Type = 0;
    pub const TT_NATIVE: Type = 1;
    pub const TT_COMPAT: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: ::aya_bpf::cty::c_ulong,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut restart_block) -> ::aya_bpf::cty::c_long,
    >,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type::Type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::aya_bpf::cty::c_int,
    pub has_timeout: ::aya_bpf::cty::c_int,
    pub tv_sec: ::aya_bpf::cty::c_ulong,
    pub tv_nsec: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount {
    pub sequence: ::aya_bpf::cty::c_uint,
}
pub type seqcount_t = seqcount;
pub mod vtime_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const VTIME_INACTIVE: Type = 0;
    pub const VTIME_IDLE: Type = 1;
    pub const VTIME_SYS: Type = 2;
    pub const VTIME_USER: Type = 3;
    pub const VTIME_GUEST: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vtime {
    pub seqcount: seqcount_t,
    pub starttime: ::aya_bpf::cty::c_ulonglong,
    pub state: vtime_state::Type,
    pub cpu: ::aya_bpf::cty::c_uint,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: ::aya_bpf::cty::c_uint,
    pub expiry_active: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub scheduled: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub sig: [::aya_bpf::cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: ::aya_bpf::cty::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut ::aya_bpf::cty::c_char,
    pub offset: ::aya_bpf::cty::c_ulong,
    pub len: ::aya_bpf::cty::c_ulong,
    pub on_dispatch: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [::aya_bpf::cty::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latency_record {
    pub backtrace: [::aya_bpf::cty::c_ulong; 12usize],
    pub count: ::aya_bpf::cty::c_uint,
    pub time: ::aya_bpf::cty::c_ulong,
    pub max: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ::aya_bpf::cty::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::core::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::core::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::core::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::core::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::core::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::core::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::core::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_state_perm {
    pub __state_perm: u64_,
    pub __state_size: ::aya_bpf::cty::c_uint,
    pub __user_state_size: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: u64_,
    pub xcomp_bv: u64_,
    pub reserved: [u64_; 6usize],
}
#[repr(C)]
pub struct xregs_state {
    pub i387: fxregs_state,
    pub header: xstate_header,
    pub extended_state_area: __IncompleteArrayField<u8_>,
}
#[repr(C)]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u64; 512usize],
}
#[repr(C)]
pub struct fpstate {
    pub size: ::aya_bpf::cty::c_uint,
    pub user_size: ::aya_bpf::cty::c_uint,
    pub xfeatures: u64_,
    pub user_xfeatures: u64_,
    pub xfd: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub regs: fpregs_state,
}
impl fpstate {
    #[inline]
    pub fn is_valloc(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valloc(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_guest(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_guest(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_confidential(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_confidential(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_use(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_use(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valloc: ::aya_bpf::cty::c_uint,
        is_guest: ::aya_bpf::cty::c_uint,
        is_confidential: ::aya_bpf::cty::c_uint,
        in_use: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valloc: u32 = unsafe { ::core::mem::transmute(is_valloc) };
            is_valloc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_guest: u32 = unsafe { ::core::mem::transmute(is_guest) };
            is_guest as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_confidential: u32 = unsafe { ::core::mem::transmute(is_confidential) };
            is_confidential as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_use: u32 = unsafe { ::core::mem::transmute(in_use) };
            in_use as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct fpu {
    pub last_cpu: ::aya_bpf::cty::c_uint,
    pub avx512_timestamp: ::aya_bpf::cty::c_ulong,
    pub fpstate: *mut fpstate,
    pub __task_fpstate: *mut fpstate,
    pub perm: fpu_state_perm,
    pub guest_perm: fpu_state_perm,
    pub __fpstate: fpstate,
}
#[repr(C)]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ::aya_bpf::cty::c_ulong,
    pub es: ::aya_bpf::cty::c_ushort,
    pub ds: ::aya_bpf::cty::c_ushort,
    pub fsindex: ::aya_bpf::cty::c_ushort,
    pub gsindex: ::aya_bpf::cty::c_ushort,
    pub fsbase: ::aya_bpf::cty::c_ulong,
    pub gsbase: ::aya_bpf::cty::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: ::aya_bpf::cty::c_ulong,
    pub ptrace_dr7: ::aya_bpf::cty::c_ulong,
    pub cr2: ::aya_bpf::cty::c_ulong,
    pub trap_nr: ::aya_bpf::cty::c_ulong,
    pub error_code: ::aya_bpf::cty::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pkru: u32_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub fpu: fpu,
}
impl thread_struct {
    #[inline]
    pub fn iopl_warn(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iopl_warn(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iopl_warn: ::aya_bpf::cty::c_uint,
        sig_on_uaccess_err: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iopl_warn: u32 = unsafe { ::core::mem::transmute(iopl_warn) };
            iopl_warn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::core::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: ::aya_bpf::cty::c_uint,
    pub stack: *mut ::aya_bpf::cty::c_void,
    pub usage: refcount_t,
    pub flags: ::aya_bpf::cty::c_uint,
    pub ptrace: ::aya_bpf::cty::c_uint,
    pub on_cpu: ::aya_bpf::cty::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: ::aya_bpf::cty::c_uint,
    pub wakee_flip_decay_ts: ::aya_bpf::cty::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: ::aya_bpf::cty::c_int,
    pub wake_cpu: ::aya_bpf::cty::c_int,
    pub on_rq: ::aya_bpf::cty::c_int,
    pub prio: ::aya_bpf::cty::c_int,
    pub static_prio: ::aya_bpf::cty::c_int,
    pub normal_prio: ::aya_bpf::cty::c_int,
    pub rt_priority: ::aya_bpf::cty::c_uint,
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub sched_class: *const sched_class,
    pub core_node: rb_node,
    pub core_cookie: ::aya_bpf::cty::c_ulong,
    pub core_occupation: ::aya_bpf::cty::c_uint,
    pub sched_task_group: *mut task_group,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub stats: sched_statistics,
    pub preempt_notifiers: hlist_head,
    pub btrace_seq: ::aya_bpf::cty::c_uint,
    pub policy: ::aya_bpf::cty::c_uint,
    pub nr_cpus_allowed: ::aya_bpf::cty::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut ::aya_bpf::cty::c_void,
    pub migration_disabled: ::aya_bpf::cty::c_ushort,
    pub migration_flags: ::aya_bpf::cty::c_ushort,
    pub rcu_read_lock_nesting: ::aya_bpf::cty::c_int,
    pub rcu_read_unlock_special: rcu_special,
    pub rcu_node_entry: list_head,
    pub rcu_blocked_node: *mut rcu_node,
    pub rcu_tasks_nvcsw: ::aya_bpf::cty::c_ulong,
    pub rcu_tasks_holdout: u8_,
    pub rcu_tasks_idx: u8_,
    pub rcu_tasks_idle_cpu: ::aya_bpf::cty::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub trc_reader_nesting: ::aya_bpf::cty::c_int,
    pub trc_ipi_to_cpu: ::aya_bpf::cty::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_holdout_list: list_head,
    pub trc_blkd_node: list_head,
    pub trc_blkd_cpu: ::aya_bpf::cty::c_int,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub exit_state: ::aya_bpf::cty::c_int,
    pub exit_code: ::aya_bpf::cty::c_int,
    pub exit_signal: ::aya_bpf::cty::c_int,
    pub pdeath_signal: ::aya_bpf::cty::c_int,
    pub jobctl: ::aya_bpf::cty::c_ulong,
    pub personality: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub atomic_flags: ::aya_bpf::cty::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: ::aya_bpf::cty::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut ::aya_bpf::cty::c_int,
    pub clear_child_tid: *mut ::aya_bpf::cty::c_int,
    pub worker_private: *mut ::aya_bpf::cty::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub vtime: vtime,
    pub tick_dep_mask: atomic_t,
    pub nvcsw: ::aya_bpf::cty::c_ulong,
    pub nivcsw: ::aya_bpf::cty::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: ::aya_bpf::cty::c_ulong,
    pub maj_flt: ::aya_bpf::cty::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [::aya_bpf::cty::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: ::aya_bpf::cty::c_ulong,
    pub last_switch_time: ::aya_bpf::cty::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: ::aya_bpf::cty::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: ::aya_bpf::cty::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: ::aya_bpf::cty::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut ::aya_bpf::cty::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: ::aya_bpf::cty::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub psi_flags: ::aya_bpf::cty::c_uint,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: ::aya_bpf::cty::c_int,
    pub cpuset_slab_spread_rotor: ::aya_bpf::cty::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub closid: u32_,
    pub rmid: u32_,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: ::aya_bpf::cty::c_uint,
    pub perf_event_ctxp: *mut perf_event_context,
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub mempolicy: *mut mempolicy,
    pub il_prev: ::aya_bpf::cty::c_short,
    pub pref_node_fork: ::aya_bpf::cty::c_short,
    pub numa_scan_seq: ::aya_bpf::cty::c_int,
    pub numa_scan_period: ::aya_bpf::cty::c_uint,
    pub numa_scan_period_max: ::aya_bpf::cty::c_uint,
    pub numa_preferred_nid: ::aya_bpf::cty::c_int,
    pub numa_migrate_retry: ::aya_bpf::cty::c_ulong,
    pub node_stamp: u64_,
    pub last_task_numa_placement: u64_,
    pub last_sum_exec_runtime: u64_,
    pub numa_work: callback_head,
    pub numa_group: *mut numa_group,
    pub numa_faults: *mut ::aya_bpf::cty::c_ulong,
    pub total_numa_faults: ::aya_bpf::cty::c_ulong,
    pub numa_faults_locality: [::aya_bpf::cty::c_ulong; 3usize],
    pub numa_pages_migrated: ::aya_bpf::cty::c_ulong,
    pub rseq: *mut rseq,
    pub rseq_sig: u32_,
    pub rseq_event_mask: ::aya_bpf::cty::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub __bindgen_anon_1: task_struct__bindgen_ty_1,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub make_it_fail: ::aya_bpf::cty::c_int,
    pub fail_nth: ::aya_bpf::cty::c_uint,
    pub nr_dirtied: ::aya_bpf::cty::c_int,
    pub nr_dirtied_pause: ::aya_bpf::cty::c_int,
    pub dirty_paused_when: ::aya_bpf::cty::c_ulong,
    pub latency_record_count: ::aya_bpf::cty::c_int,
    pub latency_record: [latency_record; 32usize],
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub curr_ret_stack: ::aya_bpf::cty::c_int,
    pub curr_ret_depth: ::aya_bpf::cty::c_int,
    pub ret_stack: *mut ftrace_ret_stack,
    pub ftrace_timestamp: ::aya_bpf::cty::c_ulonglong,
    pub trace_overrun: atomic_t,
    pub tracing_graph_pause: atomic_t,
    pub trace_recursion: ::aya_bpf::cty::c_ulong,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: ::aya_bpf::cty::c_int,
    pub memcg_nr_pages_over_high: ::aya_bpf::cty::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub throttle_queue: *mut request_queue,
    pub utask: *mut uprobe_task,
    pub sequential_io: ::aya_bpf::cty::c_uint,
    pub sequential_io_avg: ::aya_bpf::cty::c_uint,
    pub kmap_ctrl: kmap_ctrl,
    pub pagefault_disabled: ::aya_bpf::cty::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub patch_state: ::aya_bpf::cty::c_int,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub bpf_storage: *mut bpf_local_storage,
    pub bpf_ctx: *mut bpf_run_ctx,
    pub mce_vaddr: *mut ::aya_bpf::cty::c_void,
    pub mce_kflags: __u64,
    pub mce_addr: u64_,
    pub _bitfield_align_3: [u64; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub mce_kill_me: callback_head,
    pub mce_count: ::aya_bpf::cty::c_int,
    pub kretprobe_instances: llist_head,
    pub rethooks: llist_head,
    pub l1d_flush_kill: callback_head,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub thread: thread_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union task_struct__bindgen_ty_1 {
    pub rcu_users: refcount_t,
    pub rcu: callback_head,
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_lru_fault(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_lru_fault(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_memstall(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_memstall(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_page_owner(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_page_owner(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pasid_activated(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pasid_activated(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reported_split_lock(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reported_split_lock(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_thrashing(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(46usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_thrashing(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sched_reset_on_fork: ::aya_bpf::cty::c_uint,
        sched_contributes_to_load: ::aya_bpf::cty::c_uint,
        sched_migrated: ::aya_bpf::cty::c_uint,
        sched_remote_wakeup: ::aya_bpf::cty::c_uint,
        in_execve: ::aya_bpf::cty::c_uint,
        in_iowait: ::aya_bpf::cty::c_uint,
        restore_sigmask: ::aya_bpf::cty::c_uint,
        in_user_fault: ::aya_bpf::cty::c_uint,
        in_lru_fault: ::aya_bpf::cty::c_uint,
        no_cgroup_migration: ::aya_bpf::cty::c_uint,
        frozen: ::aya_bpf::cty::c_uint,
        use_memdelay: ::aya_bpf::cty::c_uint,
        in_memstall: ::aya_bpf::cty::c_uint,
        in_page_owner: ::aya_bpf::cty::c_uint,
        in_eventfd: ::aya_bpf::cty::c_uint,
        pasid_activated: ::aya_bpf::cty::c_uint,
        reported_split_lock: ::aya_bpf::cty::c_uint,
        in_thrashing: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let in_lru_fault: u32 = unsafe { ::core::mem::transmute(in_lru_fault) };
            in_lru_fault as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let in_memstall: u32 = unsafe { ::core::mem::transmute(in_memstall) };
            in_memstall as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let in_page_owner: u32 = unsafe { ::core::mem::transmute(in_page_owner) };
            in_page_owner as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let pasid_activated: u32 = unsafe { ::core::mem::transmute(pasid_activated) };
            pasid_activated as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let reported_split_lock: u32 = unsafe { ::core::mem::transmute(reported_split_lock) };
            reported_split_lock as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let in_thrashing: u32 = unsafe { ::core::mem::transmute(in_thrashing) };
            in_thrashing as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mce_ripv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_ripv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce_whole_page(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_whole_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __mce_reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set___mce_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        mce_ripv: __u64,
        mce_whole_page: __u64,
        __mce_reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mce_ripv: u64 = unsafe { ::core::mem::transmute(mce_ripv) };
            mce_ripv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mce_whole_page: u64 = unsafe { ::core::mem::transmute(mce_whole_page) };
            mce_whole_page as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let __mce_reserved: u64 = unsafe { ::core::mem::transmute(__mce_reserved) };
            __mce_reserved as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_4() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn end(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: ::aya_bpf::cty::c_uint,
        bp_reg: ::aya_bpf::cty::c_uint,
        type_: ::aya_bpf::cty::c_uint,
        end: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::core::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::core::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let end: u32 = unsafe { ::core::mem::transmute(end) };
            end as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type pteval_t = ::aya_bpf::cty::c_ulong;
pub type pmdval_t = ::aya_bpf::cty::c_ulong;
pub type pudval_t = ::aya_bpf::cty::c_ulong;
pub type pgdval_t = ::aya_bpf::cty::c_ulong;
pub type pgprotval_t = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: page__bindgen_ty_1__bindgen_ty_7,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub private: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ::aya_bpf::cty::c_void,
    pub mlock_count: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub index: ::aya_bpf::cty::c_ulong,
    pub share: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub pp_magic: ::aya_bpf::cty::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ::aya_bpf::cty::c_ulong,
    pub dma_addr: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub dma_addr_upper: ::aya_bpf::cty::c_ulong,
    pub pp_frag_count: atomic_long_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: ::aya_bpf::cty::c_ulong,
    pub compound_dtor: ::aya_bpf::cty::c_uchar,
    pub compound_order: ::aya_bpf::cty::c_uchar,
    pub compound_mapcount: atomic_t,
    pub subpages_mapcount: atomic_t,
    pub compound_pincount: atomic_t,
    pub compound_nr: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _compound_pad_1: ::aya_bpf::cty::c_ulong,
    pub _compound_pad_2: ::aya_bpf::cty::c_ulong,
    pub deferred_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _hugetlb_pad_1: ::aya_bpf::cty::c_ulong,
    pub hugetlb_subpool: *mut ::aya_bpf::cty::c_void,
    pub hugetlb_cgroup: *mut ::aya_bpf::cty::c_void,
    pub hugetlb_cgroup_rsvd: *mut ::aya_bpf::cty::c_void,
    pub hugetlb_hwpoison: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    pub _pt_pad_1: ::aya_bpf::cty::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub ptl: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_7 {
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map_p {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_root: *mut ::aya_bpf::cty::c_void,
    pub ma_flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub lock: mutex,
    pub vdso: *mut ::aya_bpf::cty::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mm_mt: maple_tree,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: ::aya_bpf::cty::c_ulong,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
    pub mmap_base: ::aya_bpf::cty::c_ulong,
    pub mmap_legacy_base: ::aya_bpf::cty::c_ulong,
    pub mmap_compat_base: ::aya_bpf::cty::c_ulong,
    pub mmap_compat_legacy_base: ::aya_bpf::cty::c_ulong,
    pub task_size: ::aya_bpf::cty::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: ::aya_bpf::cty::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: ::aya_bpf::cty::c_ulong,
    pub hiwater_vm: ::aya_bpf::cty::c_ulong,
    pub total_vm: ::aya_bpf::cty::c_ulong,
    pub locked_vm: ::aya_bpf::cty::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: ::aya_bpf::cty::c_ulong,
    pub exec_vm: ::aya_bpf::cty::c_ulong,
    pub stack_vm: ::aya_bpf::cty::c_ulong,
    pub def_flags: ::aya_bpf::cty::c_ulong,
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: ::aya_bpf::cty::c_ulong,
    pub end_code: ::aya_bpf::cty::c_ulong,
    pub start_data: ::aya_bpf::cty::c_ulong,
    pub end_data: ::aya_bpf::cty::c_ulong,
    pub start_brk: ::aya_bpf::cty::c_ulong,
    pub brk: ::aya_bpf::cty::c_ulong,
    pub start_stack: ::aya_bpf::cty::c_ulong,
    pub arg_start: ::aya_bpf::cty::c_ulong,
    pub arg_end: ::aya_bpf::cty::c_ulong,
    pub env_start: ::aya_bpf::cty::c_ulong,
    pub env_end: ::aya_bpf::cty::c_ulong,
    pub saved_auxv: [::aya_bpf::cty::c_ulong; 48usize],
    pub rss_stat: [percpu_counter; 4usize],
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub numa_next_scan: ::aya_bpf::cty::c_ulong,
    pub numa_scan_offset: ::aya_bpf::cty::c_ulong,
    pub numa_scan_seq: ::aya_bpf::cty::c_int,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub pasid: u32_,
    pub ksm_merging_pages: ::aya_bpf::cty::c_ulong,
    pub ksm_rmap_items: ::aya_bpf::cty::c_ulong,
    pub lru_gen: mm_struct__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
    pub list: list_head,
    pub bitmap: ::aya_bpf::cty::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {
    pub ctx: *mut userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: ::aya_bpf::cty::c_ulong,
    pub vm_end: ::aya_bpf::cty::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: ::aya_bpf::cty::c_ulong,
    pub shared: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: ::aya_bpf::cty::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut ::aya_bpf::cty::c_void,
    pub anon_name: *mut anon_vma_name,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ::aya_bpf::cty::c_int,
    pub file_disp: ::aya_bpf::cty::c_int,
    pub line: ::aya_bpf::cty::c_ushort,
    pub flags: ::aya_bpf::cty::c_ushort,
}
pub type cpumask_var_t = *mut cpumask;
pub type time64_t = __s64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::aya_bpf::cty::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ::aya_bpf::cty::c_long,
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::aya_bpf::cty::c_int,
    pub events: ::aya_bpf::cty::c_short,
    pub revents: ::aya_bpf::cty::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::aya_bpf::cty::c_ulong,
    pub r14: ::aya_bpf::cty::c_ulong,
    pub r13: ::aya_bpf::cty::c_ulong,
    pub r12: ::aya_bpf::cty::c_ulong,
    pub bp: ::aya_bpf::cty::c_ulong,
    pub bx: ::aya_bpf::cty::c_ulong,
    pub r11: ::aya_bpf::cty::c_ulong,
    pub r10: ::aya_bpf::cty::c_ulong,
    pub r9: ::aya_bpf::cty::c_ulong,
    pub r8: ::aya_bpf::cty::c_ulong,
    pub ax: ::aya_bpf::cty::c_ulong,
    pub cx: ::aya_bpf::cty::c_ulong,
    pub dx: ::aya_bpf::cty::c_ulong,
    pub si: ::aya_bpf::cty::c_ulong,
    pub di: ::aya_bpf::cty::c_ulong,
    pub orig_ax: ::aya_bpf::cty::c_ulong,
    pub ip: ::aya_bpf::cty::c_ulong,
    pub cs: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub sp: ::aya_bpf::cty::c_ulong,
    pub ss: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: ::aya_bpf::cty::c_long,
    pub regs: *mut pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ::aya_bpf::cty::c_void,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub prio: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ::aya_bpf::cty::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut ::aya_bpf::cty::c_void,
    pub iterator: *mut ::aya_bpf::cty::c_void,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf::cty::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut ::aya_bpf::cty::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl bpf_raw_event_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
pub mod perf_event_state {
    pub type Type = ::aya_bpf::cty::c_int;
    pub const PERF_EVENT_STATE_DEAD: Type = -4;
    pub const PERF_EVENT_STATE_EXIT: Type = -3;
    pub const PERF_EVENT_STATE_ERROR: Type = -2;
    pub const PERF_EVENT_STATE_OFF: Type = -1;
    pub const PERF_EVENT_STATE_INACTIVE: Type = 0;
    pub const PERF_EVENT_STATE_ACTIVE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local64_t {
    pub a: local_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    pub type_: __u32,
    pub size: __u32,
    pub config: __u64,
    pub __bindgen_anon_1: perf_event_attr__bindgen_ty_1,
    pub sample_type: __u64,
    pub read_format: __u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub __bindgen_anon_2: perf_event_attr__bindgen_ty_2,
    pub bp_type: __u32,
    pub __bindgen_anon_3: perf_event_attr__bindgen_ty_3,
    pub __bindgen_anon_4: perf_event_attr__bindgen_ty_4,
    pub branch_sample_type: __u64,
    pub sample_regs_user: __u64,
    pub sample_stack_user: __u32,
    pub clockid: __s32,
    pub sample_regs_intr: __u64,
    pub aux_watermark: __u32,
    pub sample_max_stack: __u16,
    pub __reserved_2: __u16,
    pub aux_sample_size: __u32,
    pub __reserved_3: __u32,
    pub sig_data: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_1 {
    pub sample_period: __u64,
    pub sample_freq: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_2 {
    pub wakeup_events: __u32,
    pub wakeup_watermark: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_3 {
    pub bp_addr: __u64,
    pub kprobe_func: __u64,
    pub uprobe_path: __u64,
    pub config1: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_attr__bindgen_ty_4 {
    pub bp_len: __u64,
    pub kprobe_addr: __u64,
    pub probe_offset: __u64,
    pub config2: __u64,
}
impl perf_event_attr {
    #[inline]
    pub fn disabled(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pinned(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_pinned(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_user(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_user(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_kernel(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_kernel(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_hv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_hv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_idle(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_idle(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn freq(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_freq(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_stat(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit_stat(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_on_exec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_enable_on_exec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn task(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_task(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn watermark(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_watermark(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn precise_ip(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_precise_ip(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap_data(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap_data(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_id_all(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sample_id_all(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_host(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_host(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_guest(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_guest(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_kernel(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_kernel(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclude_callchain_user(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_exclude_callchain_user(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap2(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mmap2(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comm_exec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_comm_exec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_clockid(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_use_clockid(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn context_switch(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_context_switch(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_backward(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_write_backward(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn namespaces(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_namespaces(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ksymbol(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ksymbol(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bpf_event(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_bpf_event(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aux_output(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_aux_output(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cgroup(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cgroup(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_poke(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_text_poke(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn build_id(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_build_id(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherit_thread(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_inherit_thread(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remove_on_exec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_remove_on_exec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sigtrap(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_sigtrap(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 26u8) as u64) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disabled: __u64,
        inherit: __u64,
        pinned: __u64,
        exclusive: __u64,
        exclude_user: __u64,
        exclude_kernel: __u64,
        exclude_hv: __u64,
        exclude_idle: __u64,
        mmap: __u64,
        comm: __u64,
        freq: __u64,
        inherit_stat: __u64,
        enable_on_exec: __u64,
        task: __u64,
        watermark: __u64,
        precise_ip: __u64,
        mmap_data: __u64,
        sample_id_all: __u64,
        exclude_host: __u64,
        exclude_guest: __u64,
        exclude_callchain_kernel: __u64,
        exclude_callchain_user: __u64,
        mmap2: __u64,
        comm_exec: __u64,
        use_clockid: __u64,
        context_switch: __u64,
        write_backward: __u64,
        namespaces: __u64,
        ksymbol: __u64,
        bpf_event: __u64,
        aux_output: __u64,
        cgroup: __u64,
        text_poke: __u64,
        build_id: __u64,
        inherit_thread: __u64,
        remove_on_exec: __u64,
        sigtrap: __u64,
        __reserved_1: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disabled: u64 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inherit: u64 = unsafe { ::core::mem::transmute(inherit) };
            inherit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pinned: u64 = unsafe { ::core::mem::transmute(pinned) };
            pinned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exclusive: u64 = unsafe { ::core::mem::transmute(exclusive) };
            exclusive as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exclude_user: u64 = unsafe { ::core::mem::transmute(exclude_user) };
            exclude_user as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let exclude_kernel: u64 = unsafe { ::core::mem::transmute(exclude_kernel) };
            exclude_kernel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let exclude_hv: u64 = unsafe { ::core::mem::transmute(exclude_hv) };
            exclude_hv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exclude_idle: u64 = unsafe { ::core::mem::transmute(exclude_idle) };
            exclude_idle as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mmap: u64 = unsafe { ::core::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let comm: u64 = unsafe { ::core::mem::transmute(comm) };
            comm as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let freq: u64 = unsafe { ::core::mem::transmute(freq) };
            freq as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inherit_stat: u64 = unsafe { ::core::mem::transmute(inherit_stat) };
            inherit_stat as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let enable_on_exec: u64 = unsafe { ::core::mem::transmute(enable_on_exec) };
            enable_on_exec as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let task: u64 = unsafe { ::core::mem::transmute(task) };
            task as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let watermark: u64 = unsafe { ::core::mem::transmute(watermark) };
            watermark as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let precise_ip: u64 = unsafe { ::core::mem::transmute(precise_ip) };
            precise_ip as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mmap_data: u64 = unsafe { ::core::mem::transmute(mmap_data) };
            mmap_data as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sample_id_all: u64 = unsafe { ::core::mem::transmute(sample_id_all) };
            sample_id_all as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let exclude_host: u64 = unsafe { ::core::mem::transmute(exclude_host) };
            exclude_host as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let exclude_guest: u64 = unsafe { ::core::mem::transmute(exclude_guest) };
            exclude_guest as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let exclude_callchain_kernel: u64 =
                unsafe { ::core::mem::transmute(exclude_callchain_kernel) };
            exclude_callchain_kernel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let exclude_callchain_user: u64 =
                unsafe { ::core::mem::transmute(exclude_callchain_user) };
            exclude_callchain_user as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let mmap2: u64 = unsafe { ::core::mem::transmute(mmap2) };
            mmap2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let comm_exec: u64 = unsafe { ::core::mem::transmute(comm_exec) };
            comm_exec as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_clockid: u64 = unsafe { ::core::mem::transmute(use_clockid) };
            use_clockid as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let context_switch: u64 = unsafe { ::core::mem::transmute(context_switch) };
            context_switch as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let write_backward: u64 = unsafe { ::core::mem::transmute(write_backward) };
            write_backward as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let namespaces: u64 = unsafe { ::core::mem::transmute(namespaces) };
            namespaces as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let ksymbol: u64 = unsafe { ::core::mem::transmute(ksymbol) };
            ksymbol as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bpf_event: u64 = unsafe { ::core::mem::transmute(bpf_event) };
            bpf_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let aux_output: u64 = unsafe { ::core::mem::transmute(aux_output) };
            aux_output as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let cgroup: u64 = unsafe { ::core::mem::transmute(cgroup) };
            cgroup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let text_poke: u64 = unsafe { ::core::mem::transmute(text_poke) };
            text_poke as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let build_id: u64 = unsafe { ::core::mem::transmute(build_id) };
            build_id as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let inherit_thread: u64 = unsafe { ::core::mem::transmute(inherit_thread) };
            inherit_thread as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let remove_on_exec: u64 = unsafe { ::core::mem::transmute(remove_on_exec) };
            remove_on_exec as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let sigtrap: u64 = unsafe { ::core::mem::transmute(sigtrap) };
            sigtrap as u64
        });
        __bindgen_bitfield_unit.set(38usize, 26u8, {
            let __reserved_1: u64 = unsafe { ::core::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event_extra {
    pub config: u64_,
    pub reg: ::aya_bpf::cty::c_uint,
    pub alloc: ::aya_bpf::cty::c_int,
    pub idx: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_hw_breakpoint {
    pub address: ::aya_bpf::cty::c_ulong,
    pub mask: ::aya_bpf::cty::c_ulong,
    pub len: u8_,
    pub type_: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhlist_head {
    pub rhead: rhash_head,
    pub next: *mut rhlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hw_perf_event {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_1,
    pub target: *mut task_struct,
    pub addr_filters: *mut ::aya_bpf::cty::c_void,
    pub addr_filters_gen: ::aya_bpf::cty::c_ulong,
    pub state: ::aya_bpf::cty::c_int,
    pub prev_count: local64_t,
    pub sample_period: u64_,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_2,
    pub interrupts_seq: u64_,
    pub interrupts: u64_,
    pub freq_time_stamp: u64_,
    pub freq_count_stamp: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hw_perf_event__bindgen_ty_1 {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: hw_perf_event__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: hw_perf_event__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: hw_perf_event__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: hw_perf_event__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_1 {
    pub config: u64_,
    pub last_tag: u64_,
    pub config_base: ::aya_bpf::cty::c_ulong,
    pub event_base: ::aya_bpf::cty::c_ulong,
    pub event_base_rdpmc: ::aya_bpf::cty::c_int,
    pub idx: ::aya_bpf::cty::c_int,
    pub last_cpu: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub extra_reg: hw_perf_event_extra,
    pub branch_reg: hw_perf_event_extra,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_2 {
    pub hrtimer: hrtimer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_3 {
    pub tp_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_4 {
    pub pwr_acc: u64_,
    pub ptsc: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_5 {
    pub info: arch_hw_breakpoint,
    pub bp_list: rhlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_1__bindgen_ty_6 {
    pub iommu_bank: u8_,
    pub iommu_cntr: u8_,
    pub padding: u16_,
    pub conf: u64_,
    pub conf1: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hw_perf_event__bindgen_ty_2 {
    pub __bindgen_anon_1: hw_perf_event__bindgen_ty_2__bindgen_ty_1,
    pub __bindgen_anon_2: hw_perf_event__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_2__bindgen_ty_1 {
    pub last_period: u64_,
    pub period_left: local64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_perf_event__bindgen_ty_2__bindgen_ty_2 {
    pub saved_metric: u64_,
    pub saved_slots: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
pub type wait_queue_head_t = wait_queue_head;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_work {
    pub node: __call_single_node,
    pub func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_work)>,
    pub irqwait: rcuwait,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_addr_filters_head {
    pub list: list_head,
    pub lock: raw_spinlock_t,
    pub nr_file_filters: ::aya_bpf::cty::c_uint,
}
pub type perf_overflow_handler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut perf_sample_data, arg3: *mut pt_regs),
>;
pub type ftrace_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::aya_bpf::cty::c_ulong,
        arg2: ::aya_bpf::cty::c_ulong,
        arg3: *mut ftrace_ops,
        arg4: *mut ftrace_regs,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops_hash {
    pub notrace_hash: *mut ftrace_hash,
    pub filter_hash: *mut ftrace_hash,
    pub regex_lock: mutex,
}
pub mod ftrace_ops_cmd {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_SELF: Type = 0;
    pub const FTRACE_OPS_CMD_ENABLE_SHARE_IPMODIFY_PEER: Type = 1;
    pub const FTRACE_OPS_CMD_DISABLE_SHARE_IPMODIFY_PEER: Type = 2;
}
pub type ftrace_ops_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ftrace_ops,
        arg2: ftrace_ops_cmd::Type,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops {
    pub func: ftrace_func_t,
    pub next: *mut ftrace_ops,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub saved_func: ftrace_func_t,
    pub local_hash: ftrace_ops_hash,
    pub func_hash: *mut ftrace_ops_hash,
    pub old_hash: ftrace_ops_hash,
    pub trampoline: ::aya_bpf::cty::c_ulong,
    pub trampoline_size: ::aya_bpf::cty::c_ulong,
    pub list: list_head,
    pub ops_func: ftrace_ops_func_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    pub event_entry: list_head,
    pub sibling_list: list_head,
    pub active_list: list_head,
    pub group_node: rb_node,
    pub group_index: u64_,
    pub migrate_entry: list_head,
    pub hlist_entry: hlist_node,
    pub active_entry: list_head,
    pub nr_siblings: ::aya_bpf::cty::c_int,
    pub event_caps: ::aya_bpf::cty::c_int,
    pub group_caps: ::aya_bpf::cty::c_int,
    pub group_leader: *mut perf_event,
    pub pmu: *mut pmu,
    pub pmu_private: *mut ::aya_bpf::cty::c_void,
    pub state: perf_event_state::Type,
    pub attach_state: ::aya_bpf::cty::c_uint,
    pub count: local64_t,
    pub child_count: atomic64_t,
    pub total_time_enabled: u64_,
    pub total_time_running: u64_,
    pub tstamp: u64_,
    pub attr: perf_event_attr,
    pub header_size: u16_,
    pub id_header_size: u16_,
    pub read_size: u16_,
    pub hw: hw_perf_event,
    pub ctx: *mut perf_event_context,
    pub pmu_ctx: *mut perf_event_pmu_context,
    pub refcount: atomic_long_t,
    pub child_total_time_enabled: atomic64_t,
    pub child_total_time_running: atomic64_t,
    pub child_mutex: mutex,
    pub child_list: list_head,
    pub parent: *mut perf_event,
    pub oncpu: ::aya_bpf::cty::c_int,
    pub cpu: ::aya_bpf::cty::c_int,
    pub owner_entry: list_head,
    pub owner: *mut task_struct,
    pub mmap_mutex: mutex,
    pub mmap_count: atomic_t,
    pub rb: *mut perf_buffer,
    pub rb_entry: list_head,
    pub rcu_batches: ::aya_bpf::cty::c_ulong,
    pub rcu_pending: ::aya_bpf::cty::c_int,
    pub waitq: wait_queue_head_t,
    pub fasync: *mut fasync_struct,
    pub pending_wakeup: ::aya_bpf::cty::c_uint,
    pub pending_kill: ::aya_bpf::cty::c_uint,
    pub pending_disable: ::aya_bpf::cty::c_uint,
    pub pending_sigtrap: ::aya_bpf::cty::c_uint,
    pub pending_addr: ::aya_bpf::cty::c_ulong,
    pub pending_irq: irq_work,
    pub pending_task: callback_head,
    pub pending_work: ::aya_bpf::cty::c_uint,
    pub event_limit: atomic_t,
    pub addr_filters: perf_addr_filters_head,
    pub addr_filter_ranges: *mut perf_addr_filter_range,
    pub addr_filters_gen: ::aya_bpf::cty::c_ulong,
    pub aux_event: *mut perf_event,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub callback_head: callback_head,
    pub ns: *mut pid_namespace,
    pub id: u64_,
    pub lost_samples: atomic64_t,
    pub clock: ::core::option::Option<unsafe extern "C" fn() -> u64_>,
    pub overflow_handler: perf_overflow_handler_t,
    pub overflow_handler_context: *mut ::aya_bpf::cty::c_void,
    pub orig_overflow_handler: perf_overflow_handler_t,
    pub prog: *mut bpf_prog,
    pub bpf_cookie: u64_,
    pub tp_event: *mut trace_event_call,
    pub filter: *mut event_filter,
    pub ftrace_ops: ftrace_ops,
    pub cgrp: *mut perf_cgroup,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub sb_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
pub mod pid_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PIDTYPE_PID: Type = 0;
    pub const PIDTYPE_TGID: Type = 1;
    pub const PIDTYPE_PGID: Type = 2;
    pub const PIDTYPE_SID: Type = 3;
    pub const PIDTYPE_MAX: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: ::aya_bpf::cty::c_int,
    pub ns: *mut pid_namespace,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: ::aya_bpf::cty::c_uint,
    pub idr_next: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ns_common {
    pub stashed: atomic_long_t,
    pub ops: *const proc_ns_operations,
    pub inum: ::aya_bpf::cty::c_uint,
    pub count: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    pub idr: idr,
    pub rcu: callback_head,
    pub pid_allocated: ::aya_bpf::cty::c_uint,
    pub child_reaper: *mut task_struct,
    pub pid_cachep: *mut kmem_cache,
    pub level: ::aya_bpf::cty::c_uint,
    pub parent: *mut pid_namespace,
    pub bacct: *mut fs_pin,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub reboot: ::aya_bpf::cty::c_int,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid {
    pub count: refcount_t,
    pub level: ::aya_bpf::cty::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub nr_extents: u32_,
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: ::aya_bpf::cty::c_int,
    pub count: ::aya_bpf::cty::c_int,
    pub nreg: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::aya_bpf::cty::c_int,
    >,
    pub dir: ctl_dir,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub parent: *mut user_namespace,
    pub level: ::aya_bpf::cty::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub parent_could_setfcap: bool_,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub persistent_keyring_register: *mut key,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [::aya_bpf::cty::c_long; 12usize],
    pub rlimit_max: [::aya_bpf::cty::c_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ::aya_bpf::cty::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: ::aya_bpf::cty::c_uint,
    pub active_bases: ::aya_bpf::cty::c_uint,
    pub clock_was_set_seq: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: ::aya_bpf::cty::c_uint,
    pub nr_retries: ::aya_bpf::cty::c_ushort,
    pub nr_hangs: ::aya_bpf::cty::c_ushort,
    pub max_hang_time: ::aya_bpf::cty::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: ::aya_bpf::cty::c_uint,
        in_hrtirq: ::aya_bpf::cty::c_uint,
        hang_detected: ::aya_bpf::cty::c_uint,
        softirq_activated: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: ::aya_bpf::cty::c_ulonglong,
}
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::aya_bpf::cty::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::aya_bpf::cty::c_int,
    pub sival_ptr: *mut ::aya_bpf::cty::c_void,
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::aya_bpf::cty::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::aya_bpf::cty::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ::aya_bpf::cty::c_int,
    pub _addr_lsb: ::aya_bpf::cty::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::aya_bpf::cty::c_char; 8usize],
    pub _lower: *mut ::aya_bpf::cty::c_void,
    pub _upper: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::aya_bpf::cty::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ::aya_bpf::cty::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::aya_bpf::cty::c_long,
    pub _fd: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::aya_bpf::cty::c_void,
    pub _syscall: ::aya_bpf::cty::c_int,
    pub _arch: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: ::aya_bpf::cty::c_int,
    pub si_errno: ::aya_bpf::cty::c_int,
    pub si_code: ::aya_bpf::cty::c_int,
    pub _sifields: __sifields,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucounts {
    pub node: hlist_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub count: atomic_t,
    pub ucount: [atomic_long_t; 12usize],
    pub rlimit: [atomic_long_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ::aya_bpf::cty::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: ::aya_bpf::cty::c_int,
    pub ac_exitcode: ::aya_bpf::cty::c_long,
    pub ac_mem: ::aya_bpf::cty::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: ::aya_bpf::cty::c_ulong,
    pub ac_majflt: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: ::aya_bpf::cty::c_int,
    pub quick_threads: ::aya_bpf::cty::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: ::aya_bpf::cty::c_int,
    pub notify_count: ::aya_bpf::cty::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub posix_timer_id: ::aya_bpf::cty::c_int,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tick_dep_mask: atomic_t,
    pub tty_old_pgrp: *mut pid,
    pub leader: ::aya_bpf::cty::c_int,
    pub tty: *mut tty_struct,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ::aya_bpf::cty::c_ulong,
    pub nivcsw: ::aya_bpf::cty::c_ulong,
    pub cnvcsw: ::aya_bpf::cty::c_ulong,
    pub cnivcsw: ::aya_bpf::cty::c_ulong,
    pub min_flt: ::aya_bpf::cty::c_ulong,
    pub maj_flt: ::aya_bpf::cty::c_ulong,
    pub cmin_flt: ::aya_bpf::cty::c_ulong,
    pub cmaj_flt: ::aya_bpf::cty::c_ulong,
    pub inblock: ::aya_bpf::cty::c_ulong,
    pub oublock: ::aya_bpf::cty::c_ulong,
    pub cinblock: ::aya_bpf::cty::c_ulong,
    pub coublock: ::aya_bpf::cty::c_ulong,
    pub maxrss: ::aya_bpf::cty::c_ulong,
    pub cmaxrss: ::aya_bpf::cty::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: ::aya_bpf::cty::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: ::aya_bpf::cty::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: ::aya_bpf::cty::c_short,
    pub oom_score_adj_min: ::aya_bpf::cty::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: ::aya_bpf::cty::c_uint,
        has_child_subreaper: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub __bindgen_padding_0: u32,
}
impl rseq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_class {
    pub enqueue_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf::cty::c_int),
    >,
    pub dequeue_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf::cty::c_int),
    >,
    pub yield_task: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub yield_to_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> bool_,
    >,
    pub check_preempt_curr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf::cty::c_int),
    >,
    pub pick_next_task:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq) -> *mut task_struct>,
    pub put_prev_task:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub set_next_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: bool_),
    >,
    pub balance: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rq,
            arg2: *mut task_struct,
            arg3: *mut rq_flags,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub select_task_rq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut task_struct,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pick_task: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq) -> *mut task_struct>,
    pub migrate_task_rq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: ::aya_bpf::cty::c_int),
    >,
    pub task_woken:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub set_cpus_allowed: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut affinity_context),
    >,
    pub rq_online: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub rq_offline: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub find_lock_rq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut rq) -> *mut rq,
    >,
    pub task_tick: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf::cty::c_int),
    >,
    pub task_fork: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub task_dead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub switched_from:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub switched_to:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct)>,
    pub prio_changed: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct, arg3: ::aya_bpf::cty::c_int),
    >,
    pub get_rr_interval: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq, arg2: *mut task_struct) -> ::aya_bpf::cty::c_uint,
    >,
    pub update_curr: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
    pub task_change_group: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ::aya_bpf::cty::c_uint,
    pub wait: swait_queue_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: ::aya_bpf::cty::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: ::aya_bpf::cty::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: ::aya_bpf::cty::c_int,
    pub rcu: callback_head,
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [::aya_bpf::cty::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut ::aya_bpf::cty::c_void,
    pub data: [*mut ::aya_bpf::cty::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array_ptr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub watchers: *mut watch_list,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: ::aya_bpf::cty::c_ushort,
    pub datalen: ::aya_bpf::cty::c_ushort,
    pub state: ::aya_bpf::cty::c_short,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: ::aya_bpf::cty::c_ulong,
    pub len_desc: ::aya_bpf::cty::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    pub count: atomic_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: ::aya_bpf::cty::c_ushort,
    pub lock: spinlock_t,
    pub icq_tree: xarray,
    pub icq_hint: *mut io_cq,
    pub icq_list: hlist_head,
    pub release_work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 14usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: ::aya_bpf::cty::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 14usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_src_preload_node: list_head,
    pub mg_dst_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
pub type compat_uptr_t = u32_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
pub type compat_long_t = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_groups {
    pub tree: rb_root,
    pub index: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_context {
    pub lock: raw_spinlock_t,
    pub mutex: mutex,
    pub pmu_ctx_list: list_head,
    pub pinned_groups: perf_event_groups,
    pub flexible_groups: perf_event_groups,
    pub event_list: list_head,
    pub nr_events: ::aya_bpf::cty::c_int,
    pub nr_user: ::aya_bpf::cty::c_int,
    pub is_active: ::aya_bpf::cty::c_int,
    pub nr_task_data: ::aya_bpf::cty::c_int,
    pub nr_stat: ::aya_bpf::cty::c_int,
    pub nr_freq: ::aya_bpf::cty::c_int,
    pub rotate_disable: ::aya_bpf::cty::c_int,
    pub refcount: refcount_t,
    pub task: *mut task_struct,
    pub time: u64_,
    pub timestamp: u64_,
    pub timeoffset: u64_,
    pub parent_ctx: *mut perf_event_context,
    pub parent_gen: u64_,
    pub generation: u64_,
    pub pin_count: ::aya_bpf::cty::c_int,
    pub nr_cgroups: ::aya_bpf::cty::c_int,
    pub callback_head: callback_head,
    pub nr_pending: local_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_ret_stack {
    pub ret: ::aya_bpf::cty::c_ulong,
    pub func: ::aya_bpf::cty::c_ulong,
    pub calltime: ::aya_bpf::cty::c_ulonglong,
    pub subtime: ::aya_bpf::cty::c_ulonglong,
    pub retp: *mut ::aya_bpf::cty::c_ulong,
}
pub mod uprobe_task_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const UTASK_RUNNING: Type = 0;
    pub const UTASK_SSTEP: Type = 1;
    pub const UTASK_SSTEP_ACK: Type = 2;
    pub const UTASK_SSTEP_TRAPPED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: ::aya_bpf::cty::c_ulong,
    pub saved_trap_nr: ::aya_bpf::cty::c_uint,
    pub saved_tf: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state::Type,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: ::aya_bpf::cty::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut ::aya_bpf::cty::c_void,
    pub size: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub pages: *mut *mut page,
    pub page_order: ::aya_bpf::cty::c_uint,
    pub nr_pages: ::aya_bpf::cty::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [::aya_bpf::cty::c_ulong; 4usize],
    pub len: atomic_long_t,
    pub seglen: [::aya_bpf::cty::c_long; 4usize],
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [atomic_long_t; 2usize],
    pub srcu_unlock_count: [atomic_long_t; 2usize],
    pub srcu_nmi_safety: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub __bindgen_padding_0: u32,
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ::aya_bpf::cty::c_ulong,
    pub srcu_gp_seq_needed_exp: ::aya_bpf::cty::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ::aya_bpf::cty::c_ulong,
    pub cpu: ::aya_bpf::cty::c_int,
    pub ssp: *mut srcu_struct,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
}
impl srcu_data {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [::aya_bpf::cty::c_ulong; 4usize],
    pub srcu_data_have_cbs: [::aya_bpf::cty::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ::aya_bpf::cty::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ::aya_bpf::cty::c_int,
    pub grphi: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 4usize],
    pub srcu_size_state: ::aya_bpf::cty::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: ::aya_bpf::cty::c_uint,
    pub srcu_gp_seq: ::aya_bpf::cty::c_ulong,
    pub srcu_gp_seq_needed: ::aya_bpf::cty::c_ulong,
    pub srcu_gp_seq_needed_exp: ::aya_bpf::cty::c_ulong,
    pub srcu_gp_start: ::aya_bpf::cty::c_ulong,
    pub srcu_last_gp_end: ::aya_bpf::cty::c_ulong,
    pub srcu_size_jiffies: ::aya_bpf::cty::c_ulong,
    pub srcu_n_lock_retries: ::aya_bpf::cty::c_ulong,
    pub srcu_n_exp_nodelay: ::aya_bpf::cty::c_ulong,
    pub sda: *mut srcu_data,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: ::aya_bpf::cty::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: ::aya_bpf::cty::c_ulong,
    pub reschedule_count: ::aya_bpf::cty::c_ulong,
    pub work: delayed_work,
    pub dep_map: lockdep_map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: ::aya_bpf::cty::c_ulong,
    pub stack: ::aya_bpf::cty::c_ulong,
    pub orig_ret_vaddr: ::aya_bpf::cty::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub size: ::aya_bpf::cty::c_ulong,
    pub alt: ::aya_bpf::cty::c_ulong,
    pub alt_len: ::aya_bpf::cty::c_ulong,
    pub extable_base: ::aya_bpf::cty::c_ulong,
    pub extable_len: ::aya_bpf::cty::c_ulong,
    pub extable: *const ::aya_bpf::cty::c_void,
    pub sym_vvar_start: ::aya_bpf::cty::c_long,
    pub sym_vvar_page: ::aya_bpf::cty::c_long,
    pub sym_pvclock_page: ::aya_bpf::cty::c_long,
    pub sym_hvclock_page: ::aya_bpf::cty::c_long,
    pub sym_timens_page: ::aya_bpf::cty::c_long,
    pub sym_VDSO32_NOTE_MASK: ::aya_bpf::cty::c_long,
    pub sym___kernel_sigreturn: ::aya_bpf::cty::c_long,
    pub sym___kernel_rt_sigreturn: ::aya_bpf::cty::c_long,
    pub sym___kernel_vsyscall: ::aya_bpf::cty::c_long,
    pub sym_int80_landing_pad: ::aya_bpf::cty::c_long,
    pub sym_vdso32_sigreturn_landing_pad: ::aya_bpf::cty::c_long,
    pub sym_vdso32_rt_sigreturn_landing_pad: ::aya_bpf::cty::c_long,
}
pub type errseq_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: ::aya_bpf::cty::c_ulong,
    pub writeback_index: ::aya_bpf::cty::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub wb_err: errseq_t,
    pub private_lock: spinlock_t,
    pub private_list: list_head,
    pub private_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: ::aya_bpf::cty::c_ulong,
    pub end_pfn: ::aya_bpf::cty::c_ulong,
    pub reserve: ::aya_bpf::cty::c_ulong,
    pub free: ::aya_bpf::cty::c_ulong,
    pub align: ::aya_bpf::cty::c_ulong,
    pub alloc: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: ::aya_bpf::cty::c_ulong,
    pub data: *mut percpu_ref_data,
}
pub mod memory_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MEMORY_DEVICE_PRIVATE: Type = 1;
    pub const MEMORY_DEVICE_COHERENT: Type = 2;
    pub const MEMORY_DEVICE_FS_DAX: Type = 3;
    pub const MEMORY_DEVICE_GENERIC: Type = 4;
    pub const MEMORY_DEVICE_PCI_P2PDMA: Type = 5;
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type::Type,
    pub flags: ::aya_bpf::cty::c_uint,
    pub vmemmap_shift: ::aya_bpf::cty::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut ::aya_bpf::cty::c_void,
    pub nr_range: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub ranges: __BindgenUnionField<[range; 0usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: ::aya_bpf::cty::c_ulong,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
    pub memcg_data: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ::aya_bpf::cty::c_void,
    pub mlock_count: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
    pub __page_1: page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1 {
    pub _flags_1: ::aya_bpf::cty::c_ulong,
    pub _head_1: ::aya_bpf::cty::c_ulong,
    pub _folio_dtor: ::aya_bpf::cty::c_uchar,
    pub _folio_order: ::aya_bpf::cty::c_uchar,
    pub _compound_mapcount: atomic_t,
    pub _subpages_mapcount: atomic_t,
    pub _pincount: atomic_t,
    pub _folio_nr_pages: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_3 {
    pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
    pub __page_2: page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_1 {
    pub _flags_2: ::aya_bpf::cty::c_ulong,
    pub _head_2: ::aya_bpf::cty::c_ulong,
    pub _hugetlb_subpool: *mut ::aya_bpf::cty::c_void,
    pub _hugetlb_cgroup: *mut ::aya_bpf::cty::c_void,
    pub _hugetlb_cgroup_rsvd: *mut ::aya_bpf::cty::c_void,
    pub _hugetlb_hwpoison: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type::Type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_ra_state {
    pub start: ::aya_bpf::cty::c_ulong,
    pub size: ::aya_bpf::cty::c_uint,
    pub async_size: ::aya_bpf::cty::c_uint,
    pub ra_pages: ::aya_bpf::cty::c_uint,
    pub mmap_miss: ::aya_bpf::cty::c_uint,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_count: atomic_long_t,
    pub f_flags: ::aya_bpf::cty::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64_,
    pub f_security: *mut ::aya_bpf::cty::c_void,
    pub private_data: *mut ::aya_bpf::cty::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_llist: llist_node,
    pub f_rcuhead: callback_head,
    pub f_iocb_flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
pub type vm_fault_t = ::aya_bpf::cty::c_uint;
pub mod page_entry_size {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PE_SIZE_PTE: Type = 0;
    pub const PE_SIZE_PMD: Type = 1;
    pub const PE_SIZE_PUD: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_fault, arg2: page_entry_size::Type) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_fault,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct) -> ::aya_bpf::cty::c_ulong,
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: ::aya_bpf::cty::c_int,
            arg5: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct) -> *const ::aya_bpf::cty::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: *mut mempolicy,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vm_area_struct,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> *mut mempolicy,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut vm_area_struct, arg2: ::aya_bpf::cty::c_ulong) -> *mut page,
    >,
}
pub mod fault_flag {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FAULT_FLAG_WRITE: Type = 1;
    pub const FAULT_FLAG_MKWRITE: Type = 2;
    pub const FAULT_FLAG_ALLOW_RETRY: Type = 4;
    pub const FAULT_FLAG_RETRY_NOWAIT: Type = 8;
    pub const FAULT_FLAG_KILLABLE: Type = 16;
    pub const FAULT_FLAG_TRIED: Type = 32;
    pub const FAULT_FLAG_USER: Type = 64;
    pub const FAULT_FLAG_REMOTE: Type = 128;
    pub const FAULT_FLAG_INSTRUCTION: Type = 256;
    pub const FAULT_FLAG_INTERRUPTIBLE: Type = 512;
    pub const FAULT_FLAG_UNSHARE: Type = 1024;
    pub const FAULT_FLAG_ORIG_PTE_VALID: Type = 2048;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag::Type,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: ::aya_bpf::cty::c_ulong,
    pub address: ::aya_bpf::cty::c_ulong,
    pub real_address: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: ::aya_bpf::cty::c_int,
    pub memcg_aware: bool_,
    pub xa: xarray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: ::aya_bpf::cty::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const ::aya_bpf::cty::c_char,
    pub rb: rb_node,
    pub ns: *const ::aya_bpf::cty::c_void,
    pub hash: ::aya_bpf::cty::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub id: u64_,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_ops {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub seq_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut ::aya_bpf::cty::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: ::aya_bpf::cty::c_int,
    pub file: *const file,
    pub private: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut ::aya_bpf::cty::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type poll_queue_proc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut wait_queue_head_t,
        arg3: *mut poll_table_struct,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    pub _qproc: poll_queue_proc,
    pub _key: __poll_t,
}
pub mod kobj_ns_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const KOBJ_NS_TYPE_NONE: Type = 0;
    pub const KOBJ_NS_TYPE_NET: Type = 1;
    pub const KOBJ_NS_TYPES: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type::Type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns:
        ::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_bpf::cty::c_void>,
    pub netlink_ns: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock) -> *const ::aya_bpf::cty::c_void,
    >,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const ::aya_bpf::cty::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: ::aya_bpf::cty::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const ::aya_bpf::cty::c_char,
    pub mode: umode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut ::aya_bpf::cty::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut ::aya_bpf::cty::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut ::aya_bpf::cty::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const kobject) -> *const ::aya_bpf::cty::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const kobject, arg2: *mut kuid_t, arg3: *mut kgid_t),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut ::aya_bpf::cty::c_char; 3usize],
    pub envp: [*mut ::aya_bpf::cty::c_char; 64usize],
    pub envp_idx: ::aya_bpf::cty::c_int,
    pub buf: [::aya_bpf::cty::c_char; 2048usize],
    pub buflen: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const kobject) -> ::aya_bpf::cty::c_int>,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const kobject) -> *const ::aya_bpf::cty::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut kobj_uevent_env,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct em_perf_state {
    pub frequency: ::aya_bpf::cty::c_ulong,
    pub power: ::aya_bpf::cty::c_ulong,
    pub cost: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct em_perf_domain {
    pub table: *mut em_perf_state,
    pub nr_perf_states: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub cpus: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
pub mod dl_dev_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DL_DEV_NO_DRIVER: Type = 0;
    pub const DL_DEV_PROBING: Type = 1;
    pub const DL_DEV_DRIVER_BOUND: Type = 2;
    pub const DL_DEV_UNBINDING: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_message {
    pub event: ::aya_bpf::cty::c_int,
}
pub type pm_message_t = pm_message;
pub mod rpm_request {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RPM_REQ_NONE: Type = 0;
    pub const RPM_REQ_IDLE: Type = 1;
    pub const RPM_REQ_SUSPEND: Type = 2;
    pub const RPM_REQ_AUTOSUSPEND: Type = 3;
    pub const RPM_REQ_RESUME: Type = 4;
}
pub mod rpm_status {
    pub type Type = ::aya_bpf::cty::c_int;
    pub const RPM_INVALID: Type = -1;
    pub const RPM_ACTIVE: Type = 0;
    pub const RPM_RESUMING: Type = 1;
    pub const RPM_SUSPENDED: Type = 2;
    pub const RPM_SUSPENDING: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: ::aya_bpf::cty::c_uint,
    pub request: rpm_request::Type,
    pub runtime_status: rpm_status::Type,
    pub last_status: rpm_status::Type,
    pub runtime_error: ::aya_bpf::cty::c_int,
    pub autosuspend_delay: ::aya_bpf::cty::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: ::aya_bpf::cty::c_uint,
        async_suspend: ::aya_bpf::cty::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn must_resume(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        must_resume: ::aya_bpf::cty::c_uint,
        may_skip_resume: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: ::aya_bpf::cty::c_uint,
        idle_notification: ::aya_bpf::cty::c_uint,
        request_pending: ::aya_bpf::cty::c_uint,
        deferred_resume: ::aya_bpf::cty::c_uint,
        needs_force_resume: ::aya_bpf::cty::c_uint,
        runtime_auto: ::aya_bpf::cty::c_uint,
        ignore_children: bool_,
        no_callbacks: ::aya_bpf::cty::c_uint,
        irq_safe: ::aya_bpf::cty::c_uint,
        use_autosuspend: ::aya_bpf::cty::c_uint,
        timer_autosuspends: ::aya_bpf::cty::c_uint,
        memalloc_noio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u32 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_archdata {}
pub mod device_removable {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVICE_REMOVABLE_NOT_SUPPORTED: Type = 0;
    pub const DEVICE_REMOVABLE_UNKNOWN: Type = 1;
    pub const DEVICE_FIXED: Type = 2;
    pub const DEVICE_REMOVABLE: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const ::aya_bpf::cty::c_char,
    pub type_: *const device_type,
    pub bus: *mut bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut ::aya_bpf::cty::c_void,
    pub driver_data: *mut ::aya_bpf::cty::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub em_pd: *mut em_perf_domain,
    pub pins: *mut dev_pin_info,
    pub msi: dev_msi_info,
    pub dma_ops: *const dma_map_ops,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *const bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub cma_area: *mut cma,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: ::aya_bpf::cty::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *mut class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable::Type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub freeze:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub thaw:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub poweroff:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub restore:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: ::aya_bpf::cty::c_uint,
    pub clock_op_might_sleep: ::aya_bpf::cty::c_uint,
    pub clock_mutex: mutex,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const ::aya_bpf::cty::c_char,
    pub id: ::aya_bpf::cty::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: ::aya_bpf::cty::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: ::aya_bpf::cty::c_ulong,
    pub active_count: ::aya_bpf::cty::c_ulong,
    pub relax_count: ::aya_bpf::cty::c_ulong,
    pub expire_count: ::aya_bpf::cty::c_ulong,
    pub wakeup_count: ::aya_bpf::cty::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: bool_)>,
    pub activate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_type {
    pub name: *const ::aya_bpf::cty::c_char,
    pub dev_name: *const ::aya_bpf::cty::c_char,
    pub dev_root: *mut device,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut device_driver) -> ::aya_bpf::cty::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut kobj_uevent_env,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub online:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub offline:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf::cty::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub num_vf:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub iommu_ops: *const iommu_ops,
    pub p: *mut subsys_private,
    pub lock_key: lock_class_key,
    pub need_parent_lock: bool_,
}
pub mod probe_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PROBE_DEFAULT_STRATEGY: Type = 0;
    pub const PROBE_PREFER_ASYNCHRONOUS: Type = 1;
    pub const PROBE_FORCE_SYNCHRONOUS: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_driver {
    pub name: *const ::aya_bpf::cty::c_char,
    pub bus: *mut bus_type,
    pub owner: *mut module,
    pub mod_name: *const ::aya_bpf::cty::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type::Type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: pm_message_t) -> ::aya_bpf::cty::c_int,
    >,
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub p: *mut driver_private,
}
pub mod iommu_cap {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IOMMU_CAP_CACHE_COHERENCY: Type = 0;
    pub const IOMMU_CAP_INTR_REMAP: Type = 1;
    pub const IOMMU_CAP_NOEXEC: Type = 2;
    pub const IOMMU_CAP_PRE_BOOT_PROTECTION: Type = 3;
    pub const IOMMU_CAP_ENFORCE_CACHE_COHERENCY: Type = 4;
}
pub mod iommu_dev_features {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IOMMU_DEV_FEAT_SVA: Type = 0;
    pub const IOMMU_DEV_FEAT_IOPF: Type = 1;
}
pub type ioasid_t = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_ops {
    pub capable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: iommu_cap::Type) -> bool_,
    >,
    pub domain_alloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf::cty::c_uint) -> *mut iommu_domain,
    >,
    pub probe_device:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_device>,
    pub release_device: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub probe_finalize: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub device_group:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> *mut iommu_group>,
    pub get_resv_regions:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut list_head)>,
    pub of_xlate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut of_phandle_args,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub is_attach_deferred:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> bool_>,
    pub dev_enable_feat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: iommu_dev_features::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dev_disable_feat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: iommu_dev_features::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub page_response: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut iommu_fault_event,
            arg3: *mut iommu_page_response,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub def_domain_type:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub remove_dev_pasid:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: ioasid_t)>,
    pub default_domain_ops: *const iommu_domain_ops,
    pub pgsize_bitmap: ::aya_bpf::cty::c_ulong,
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_type {
    pub name: *const ::aya_bpf::cty::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut kobj_uevent_env,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut umode_t,
            arg3: *mut kuid_t,
            arg4: *mut kgid_t,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub pm: *const dev_pm_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class {
    pub name: *const ::aya_bpf::cty::c_char,
    pub owner: *mut module,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_kobj: *mut kobject,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const device,
            arg2: *mut kobj_uevent_env,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const device,
            arg2: *mut umode_t,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const device) -> *const ::aya_bpf::cty::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const device, arg2: *mut kuid_t, arg3: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
    pub p: *mut subsys_private,
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ctl_table,
        arg2: ::aya_bpf::cty::c_int,
        arg3: *mut ::aya_bpf::cty::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const ::aya_bpf::cty::c_char,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub maxlen: ::aya_bpf::cty::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ::aya_bpf::cty::c_void,
    pub extra2: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ctl_table_header,
            arg2: *mut ctl_table,
            arg3: *mut kuid_t,
            arg4: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ctl_table_header,
            arg2: *mut ctl_table,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Off = __u64;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: ::aya_bpf::cty::c_uchar,
    pub st_other: ::aya_bpf::cty::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [::aya_bpf::cty::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const ::aya_bpf::cty::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut ::aya_bpf::cty::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: ::aya_bpf::cty::c_uint,
    pub string: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: ::aya_bpf::cty::c_uint,
    pub elemsize: ::aya_bpf::cty::c_uint,
    pub num: *mut ::aya_bpf::cty::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: ::aya_bpf::cty::c_ulong,
    pub etype: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut ::aya_bpf::cty::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const ::aya_bpf::cty::c_char),
    >,
    pub test:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ::aya_bpf::cty::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klp_modinfo {
    pub hdr: Elf64_Ehdr,
    pub sechdrs: *mut Elf64_Shdr,
    pub secstrings: *mut ::aya_bpf::cty::c_char,
    pub symndx: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: ::aya_bpf::cty::c_int,
    pub fixup: ::aya_bpf::cty::c_int,
    pub data: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event {
    pub node: hlist_node,
    pub type_: ::aya_bpf::cty::c_int,
    pub funcs: *mut trace_event_functions,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_event_call {
    pub list: list_head,
    pub class: *mut trace_event_class,
    pub __bindgen_anon_1: trace_event_call__bindgen_ty_1,
    pub event: trace_event,
    pub print_fmt: *mut ::aya_bpf::cty::c_char,
    pub filter: *mut event_filter,
    pub __bindgen_anon_2: trace_event_call__bindgen_ty_2,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub flags: ::aya_bpf::cty::c_int,
    pub perf_refcount: ::aya_bpf::cty::c_int,
    pub perf_events: *mut hlist_head,
    pub prog_array: *mut bpf_prog_array,
    pub perf_perm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_event_call,
            arg2: *mut perf_event,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union trace_event_call__bindgen_ty_1 {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub tp: *mut tracepoint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union trace_event_call__bindgen_ty_2 {
    pub module: *mut ::aya_bpf::cty::c_void,
    pub refcnt: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_eval_map {
    pub system: *const ::aya_bpf::cty::c_char,
    pub eval_string: *const ::aya_bpf::cty::c_char,
    pub eval_value: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct of_device_id {
    pub name: [::aya_bpf::cty::c_char; 32usize],
    pub type_: [::aya_bpf::cty::c_char; 32usize],
    pub compatible: [::aya_bpf::cty::c_char; 128usize],
    pub data: *const ::aya_bpf::cty::c_void,
}
pub type kernel_ulong_t = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 16usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: ::aya_bpf::cty::c_uint,
    pub min_align_mask: ::aya_bpf::cty::c_uint,
    pub segment_boundary_mask: ::aya_bpf::cty::c_ulong,
}
pub mod device_physical_location_panel {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVICE_PANEL_TOP: Type = 0;
    pub const DEVICE_PANEL_BOTTOM: Type = 1;
    pub const DEVICE_PANEL_LEFT: Type = 2;
    pub const DEVICE_PANEL_RIGHT: Type = 3;
    pub const DEVICE_PANEL_FRONT: Type = 4;
    pub const DEVICE_PANEL_BACK: Type = 5;
    pub const DEVICE_PANEL_UNKNOWN: Type = 6;
}
pub mod device_physical_location_vertical_position {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVICE_VERT_POS_UPPER: Type = 0;
    pub const DEVICE_VERT_POS_CENTER: Type = 1;
    pub const DEVICE_VERT_POS_LOWER: Type = 2;
}
pub mod device_physical_location_horizontal_position {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVICE_HORI_POS_LEFT: Type = 0;
    pub const DEVICE_HORI_POS_CENTER: Type = 1;
    pub const DEVICE_HORI_POS_RIGHT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel::Type,
    pub vertical_position: device_physical_location_vertical_position::Type,
    pub horizontal_position: device_physical_location_horizontal_position::Type,
    pub dock: bool_,
    pub lid: bool_,
}
pub type dma_addr_t = u64_;
pub mod dma_data_direction {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DMA_BIDIRECTIONAL: Type = 0;
    pub const DMA_TO_DEVICE: Type = 1;
    pub const DMA_FROM_DEVICE: Type = 2;
    pub const DMA_NONE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_map_ops {
    pub flags: ::aya_bpf::cty::c_uint,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: *mut dma_addr_t,
            arg4: gfp_t,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: dma_addr_t,
            arg5: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub alloc_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: *mut dma_addr_t,
            arg4: dma_data_direction::Type,
            arg5: gfp_t,
        ) -> *mut page,
    >,
    pub free_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: *mut page,
            arg4: dma_addr_t,
            arg5: dma_data_direction::Type,
        ),
    >,
    pub alloc_noncontiguous: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: dma_data_direction::Type,
            arg4: gfp_t,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> *mut sg_table,
    >,
    pub free_noncontiguous: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: usize,
            arg3: *mut sg_table,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut vm_area_struct,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: dma_addr_t,
            arg5: usize,
            arg6: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_sgtable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut sg_table,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: dma_addr_t,
            arg5: usize,
            arg6: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: usize,
            arg5: dma_data_direction::Type,
            arg6: ::aya_bpf::cty::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: usize,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub map_sg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unmap_sg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub map_resource: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: phys_addr_t,
            arg3: usize,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> dma_addr_t,
    >,
    pub unmap_resource: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: usize,
            arg4: dma_data_direction::Type,
            arg5: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub sync_single_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: usize,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_single_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: dma_addr_t,
            arg3: usize,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_sg_for_cpu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub sync_sg_for_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub cache_sync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: usize,
            arg4: dma_data_direction::Type,
        ),
    >,
    pub dma_supported: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: u64_) -> ::aya_bpf::cty::c_int,
    >,
    pub get_required_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> u64_>,
    pub max_mapping_size: ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> usize>,
    pub opt_mapping_size: ::core::option::Option<unsafe extern "C" fn() -> usize>,
    pub get_merge_boundary:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device) -> ::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_region {
    pub cpu_start: phys_addr_t,
    pub dma_start: dma_addr_t,
    pub size: u64_,
    pub offset: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const ::aya_bpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: ::aya_bpf::cty::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [::aya_bpf::cty::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: ::aya_bpf::cty::c_ulong,
    pub d_fsdata: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: ::aya_bpf::cty::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: ::aya_bpf::cty::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut ::aya_bpf::cty::c_void,
    pub i_ino: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: ::aya_bpf::cty::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: ::aya_bpf::cty::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: ::aya_bpf::cty::c_ulong,
    pub dirtied_time_when: ::aya_bpf::cty::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_wb: *mut bdi_writeback,
    pub i_wb_frn_winner: ::aya_bpf::cty::c_int,
    pub i_wb_frn_avg_time: u16_,
    pub i_wb_frn_history: u16_,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_crypt_info: *mut fscrypt_info,
    pub i_verity_info: *mut fsverity_info,
    pub i_private: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: ::aya_bpf::cty::c_uint,
    pub __i_nlink: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut ::aya_bpf::cty::c_char,
    pub i_dir_seq: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ::aya_bpf::cty::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: *const qstr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ::aya_bpf::cty::c_int>,
    pub d_init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf::cty::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: ::aya_bpf::cty::c_int,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ::aya_bpf::cty::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl dentry_operations {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtd_info {
    _unused: [u8; 0],
}
pub type qsize_t = ::aya_bpf::cty::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: ::aya_bpf::cty::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: ::aya_bpf::cty::c_ulong,
    pub dqi_bgrace: ::aya_bpf::cty::c_uint,
    pub dqi_igrace: ::aya_bpf::cty::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: ::aya_bpf::cty::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: ::aya_bpf::cty::c_int,
    pub gp_count: ::aya_bpf::cty::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut ::aya_bpf::cty::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: ::aya_bpf::cty::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
    pub batch: ::aya_bpf::cty::c_long,
    pub seeks: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_uint,
    pub list: list_head,
    pub id: ::aya_bpf::cty::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: ::aya_bpf::cty::c_uchar,
    pub s_blocksize: ::aya_bpf::cty::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: ::aya_bpf::cty::c_ulong,
    pub s_iflags: ::aya_bpf::cty::c_ulong,
    pub s_magic: ::aya_bpf::cty::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: ::aya_bpf::cty::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut ::aya_bpf::cty::c_void,
    pub s_xattr: *mut *const xattr_handler,
    pub s_cop: *const fscrypt_operations,
    pub s_master_keys: *mut fscrypt_keyring,
    pub s_vop: *const fsverity_operations,
    pub s_encoding: *mut unicode_map,
    pub s_encoding_flags: __u16,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: ::aya_bpf::cty::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut ::aya_bpf::cty::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [::aya_bpf::cty::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: ::aya_bpf::cty::c_uint,
    pub s_mode: fmode_t,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const ::aya_bpf::cty::c_char,
    pub s_d_op: *const dentry_operations,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_connectors: atomic_long_t,
    pub s_readonly_remount: ::aya_bpf::cty::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub __bindgen_padding_0: u32,
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl super_block {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: ::aya_bpf::cty::c_int,
    pub mnt_idmap: *mut mnt_idmap,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: ::aya_bpf::cty::c_int,
    pub nr_to_scan: ::aya_bpf::cty::c_ulong,
    pub nr_scanned: ::aya_bpf::cty::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: ::aya_bpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub nr_items: ::aya_bpf::cty::c_long,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl list_lru_node {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub mod migrate_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MIGRATE_ASYNC: Type = 0;
    pub const MIGRATE_SYNC_LIGHT: Type = 1;
    pub const MIGRATE_SYNC: Type = 2;
    pub const MIGRATE_SYNC_NO_COPY: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub sibling: list_head,
    pub children: list_head,
    pub rstat_css_node: list_head,
    pub id: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: ::aya_bpf::cty::c_ulong,
    pub notify_timer: timer_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
    pub forceidle_sum: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_bpf {
    pub effective: [*mut bpf_prog_array; 33usize],
    pub progs: [hlist_head; 33usize],
    pub flags: [u8_; 33usize],
    pub storages: list_head,
    pub inactive: *mut bpf_prog_array,
    pub refcnt: percpu_ref,
    pub release_work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: ::aya_bpf::cty::c_int,
    pub nr_frozen_descendants: ::aya_bpf::cty::c_int,
    pub nr_frozen_tasks: ::aya_bpf::cty::c_int,
}
#[repr(C)]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub level: ::aya_bpf::cty::c_int,
    pub max_depth: ::aya_bpf::cty::c_int,
    pub nr_descendants: ::aya_bpf::cty::c_int,
    pub nr_dying_descendants: ::aya_bpf::cty::c_int,
    pub max_descendants: ::aya_bpf::cty::c_int,
    pub nr_populated_csets: ::aya_bpf::cty::c_int,
    pub nr_populated_domain_children: ::aya_bpf::cty::c_int,
    pub nr_populated_threaded_children: ::aya_bpf::cty::c_int,
    pub nr_threaded_children: ::aya_bpf::cty::c_int,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub psi_files: [cgroup_file; 3usize],
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 14usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 14usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_cpu: *mut cgroup_rstat_cpu,
    pub rstat_css_list: list_head,
    pub last_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: *mut psi_group,
    pub bpf: cgroup_bpf,
    pub congestion_count: atomic_t,
    pub freezer: cgroup_freezer_state,
    pub bpf_cgrp_storage: *mut bpf_local_storage,
    pub ancestors: __IncompleteArrayField<*mut cgroup>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
pub type request_key_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut key,
        arg2: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    pub name: *const ::aya_bpf::cty::c_char,
    pub def_datalen: usize,
    pub flags: ::aya_bpf::cty::c_uint,
    pub vet_description: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_char) -> ::aya_bpf::cty::c_int,
    >,
    pub preparse: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut key_preparsed_payload) -> ::aya_bpf::cty::c_int,
    >,
    pub free_preparse:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut key_preparsed_payload)>,
    pub instantiate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut key,
            arg2: *mut key_preparsed_payload,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut key,
            arg2: *mut key_preparsed_payload,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub match_preparse: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut key_match_data) -> ::aya_bpf::cty::c_int,
    >,
    pub match_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key_match_data)>,
    pub revoke: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut key)>,
    pub describe:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const key, arg2: *mut seq_file)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const key,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub request_key: request_key_actor_t,
    pub lookup_restriction: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_char) -> *mut key_restriction,
    >,
    pub asym_query: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kernel_pkey_params,
            arg2: *mut kernel_pkey_query,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub asym_eds_op: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernel_pkey_params,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub asym_verify_signature: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernel_pkey_params,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: *const ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub link: list_head,
    pub lock_class: lock_class_key,
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut key,
        arg2: *const key_type,
        arg3: *const key_payload,
        arg4: *mut key,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: ::aya_bpf::cty::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub nr_watches: atomic_t,
    pub ratelimit: ratelimit_state,
}
#[repr(C)]
#[derive(Debug)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: ::aya_bpf::cty::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [::aya_bpf::cty::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub __bindgen_padding_0: u32,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
    pub ac_btime64: __u64,
    pub compact_count: __u64,
    pub compact_delay_total: __u64,
    pub ac_tgid: __u32,
    pub ac_tgetime: __u64,
    pub ac_exe_dev: __u64,
    pub ac_exe_inode: __u64,
    pub wpcopy_count: __u64,
    pub wpcopy_delay_total: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub arg: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: ::aya_bpf::cty::c_long),
    >,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub ki_flags: ::aya_bpf::cty::c_int,
    pub ki_ioprio: u16_,
    pub ki_waitq: *mut wait_page_queue,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: ::aya_bpf::cty::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
pub mod quota_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const USRQUOTA: Type = 0;
    pub const GRPQUOTA: Type = 1;
    pub const PRJQUOTA: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: ::aya_bpf::cty::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: ::aya_bpf::cty::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ::aya_bpf::cty::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::aya_bpf::cty::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ::aya_bpf::cty::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ::aya_bpf::cty::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut kqid) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: ::aya_bpf::cty::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: ::aya_bpf::cty::c_int,
    pub d_spc_warns: ::aya_bpf::cty::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_type_state {
    pub flags: ::aya_bpf::cty::c_uint,
    pub spc_timelimit: ::aya_bpf::cty::c_uint,
    pub ino_timelimit: ::aya_bpf::cty::c_uint,
    pub rt_spc_timelimit: ::aya_bpf::cty::c_uint,
    pub spc_warnlimit: ::aya_bpf::cty::c_uint,
    pub ino_warnlimit: ::aya_bpf::cty::c_uint,
    pub rt_spc_warnlimit: ::aya_bpf::cty::c_uint,
    pub ino: ::aya_bpf::cty::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: ::aya_bpf::cty::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: ::aya_bpf::cty::c_int,
    pub i_flags: ::aya_bpf::cty::c_uint,
    pub i_spc_timelimit: ::aya_bpf::cty::c_uint,
    pub i_ino_timelimit: ::aya_bpf::cty::c_uint,
    pub i_rt_spc_timelimit: ::aya_bpf::cty::c_uint,
    pub i_spc_warnlimit: ::aya_bpf::cty::c_uint,
    pub i_ino_warnlimit: ::aya_bpf::cty::c_uint,
    pub i_rt_spc_warnlimit: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *const path,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut qc_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ::aya_bpf::cty::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut page,
            arg2: *mut writeback_control,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ::aya_bpf::cty::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut address_space,
            arg3: loff_t,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: *mut *mut page,
            arg6: *mut *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut address_space,
            arg3: loff_t,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: ::aya_bpf::cty::c_uint,
            arg6: *mut page,
            arg7: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: usize, arg3: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut folio,
            arg3: *mut folio,
            arg4: migrate_mode::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub launder_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> ::aya_bpf::cty::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, arg2: usize, arg3: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, arg2: *mut bool_, arg3: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> ::aya_bpf::cty::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut swap_info_struct,
            arg2: *mut file,
            arg3: *mut sector_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub user_backed: bool_,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub count: usize,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
    pub __bindgen_anon_3: iov_iter__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub iov_offset: usize,
    pub last_offset: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub xarray: *mut xarray,
    pub pipe: *mut pipe_inode_info,
    pub ubuf: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_3 {
    pub nr_segs: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_3__bindgen_ty_1,
    pub xarray_start: loff_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iov_iter__bindgen_ty_3__bindgen_ty_1 {
    pub head: ::aya_bpf::cty::c_uint,
    pub start_head: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const ::aya_bpf::cty::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_inode_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
        ) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const ::aya_bpf::cty::c_char,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
        ) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            arg3: u64_,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: umode_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: ::aya_bpf::cty::c_int,
        ) -> *mut posix_acl,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: *mut posix_acl,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: *mut fileattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut fileattr) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32_,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_blocker: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_blocked_requests: list_head,
    pub fl_blocked_member: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: ::aya_bpf::cty::c_uint,
    pub fl_type: ::aya_bpf::cty::c_uchar,
    pub fl_pid: ::aya_bpf::cty::c_uint,
    pub fl_link_cpu: ::aya_bpf::cty::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: ::aya_bpf::cty::c_ulong,
    pub fl_downgrade_time: ::aya_bpf::cty::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    pub ceph: file_lock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: ::aya_bpf::cty::c_int,
    pub debug_id: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_2 {
    pub inode: *mut inode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_mod_owner: *mut ::aya_bpf::cty::c_void,
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut list_head,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut ::aya_bpf::cty::c_void),
    >,
    pub lm_breaker_owns_lease:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_lock_expirable:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_expire_lock: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: ::aya_bpf::cty::c_int,
    pub fa_fd: ::aya_bpf::cty::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, arg2: ::aya_bpf::cty::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut writeback_control,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf::cty::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf::cty::c_int,
    >,
    pub freeze_fs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf::cty::c_int,
    >,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf::cty::c_int,
    >,
    pub unfreeze_fs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::aya_bpf::cty::c_int,
    >,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ::aya_bpf::cty::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_char,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub get_inode_dev: ::core::option::Option<unsafe extern "C" fn(arg1: *const inode) -> dev_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    pub encode_fh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut __u32,
            arg3: *mut ::aya_bpf::cty::c_int,
            arg4: *mut inode,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fh_to_dentry: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut fid,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
        ) -> *mut dentry,
    >,
    pub fh_to_parent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut fid,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
        ) -> *mut dentry,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: *mut dentry,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_parent: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> *mut dentry>,
    pub commit_metadata:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::aya_bpf::cty::c_int>,
    pub get_uuid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut u8_,
            arg3: *mut u32_,
            arg4: *mut u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_blocks: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: loff_t,
            arg3: u64_,
            arg4: *mut iomap,
            arg5: bool_,
            arg6: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub commit_blocks: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut iomap,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut iattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fetch_iversion: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> u64_>,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xattr_handler {
    pub name: *const ::aya_bpf::cty::c_char,
    pub prefix: *const ::aya_bpf::cty::c_char,
    pub flags: ::aya_bpf::cty::c_int,
    pub list: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> bool_>,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const xattr_handler,
            arg2: *mut dentry,
            arg3: *mut inode,
            arg4: *const ::aya_bpf::cty::c_char,
            arg5: *mut ::aya_bpf::cty::c_void,
            arg6: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const xattr_handler,
            arg2: *mut user_namespace,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *const ::aya_bpf::cty::c_char,
            arg6: *const ::aya_bpf::cty::c_void,
            arg7: usize,
            arg8: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    pub flags: ::aya_bpf::cty::c_uint,
    pub key_prefix: *const ::aya_bpf::cty::c_char,
    pub get_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: usize,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dummy_policy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> *const fscrypt_policy,
    >,
    pub empty_dir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> bool_>,
    pub has_stable_inodes:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> bool_>,
    pub get_ino_and_lblk_bits: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_int,
        ),
    >,
    pub get_devices: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::aya_bpf::cty::c_uint,
        ) -> *mut *mut block_device,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_operations {
    pub begin_enable_verity:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf::cty::c_int>,
    pub end_enable_verity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: usize,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_verity_descriptor: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_merkle_tree_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> *mut page,
    >,
    pub write_merkle_tree_block: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: u64_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const ::aya_bpf::cty::c_char,
        arg3: ::aya_bpf::cty::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: ::aya_bpf::cty::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
pub type fs_param_type = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_parameter_spec {
    pub name: *const ::aya_bpf::cty::c_char,
    pub type_: fs_param_type,
    pub opt: u8_,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub data: *const ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dev_pagemap,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_buf {
    pub buffer: *mut ::aya_bpf::cty::c_char,
    pub size: usize,
    pub len: usize,
    pub readpos: loff_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_seq {
    pub buffer: [::aya_bpf::cty::c_char; 4096usize],
    pub seq: seq_buf,
    pub full: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_mem_data_src {
    pub val: __u64,
    pub __bindgen_anon_1: perf_mem_data_src__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct perf_mem_data_src__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_mem_data_src__bindgen_ty_1 {
    #[inline]
    pub fn mem_op(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_op(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 14u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoop(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoop(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lock(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lock(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_dtlb(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_mem_dtlb(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_lvl_num(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_mem_lvl_num(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_remote(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mem_remote(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_snoopx(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_mem_snoopx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_blk(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_mem_blk(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_hops(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_mem_hops(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mem_rsvd(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 18u8) as u64) }
    }
    #[inline]
    pub fn set_mem_rsvd(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_op: __u64,
        mem_lvl: __u64,
        mem_snoop: __u64,
        mem_lock: __u64,
        mem_dtlb: __u64,
        mem_lvl_num: __u64,
        mem_remote: __u64,
        mem_snoopx: __u64,
        mem_blk: __u64,
        mem_hops: __u64,
        mem_rsvd: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mem_op: u64 = unsafe { ::core::mem::transmute(mem_op) };
            mem_op as u64
        });
        __bindgen_bitfield_unit.set(5usize, 14u8, {
            let mem_lvl: u64 = unsafe { ::core::mem::transmute(mem_lvl) };
            mem_lvl as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let mem_snoop: u64 = unsafe { ::core::mem::transmute(mem_snoop) };
            mem_snoop as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let mem_lock: u64 = unsafe { ::core::mem::transmute(mem_lock) };
            mem_lock as u64
        });
        __bindgen_bitfield_unit.set(26usize, 7u8, {
            let mem_dtlb: u64 = unsafe { ::core::mem::transmute(mem_dtlb) };
            mem_dtlb as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let mem_lvl_num: u64 = unsafe { ::core::mem::transmute(mem_lvl_num) };
            mem_lvl_num as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let mem_remote: u64 = unsafe { ::core::mem::transmute(mem_remote) };
            mem_remote as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let mem_snoopx: u64 = unsafe { ::core::mem::transmute(mem_snoopx) };
            mem_snoopx as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let mem_blk: u64 = unsafe { ::core::mem::transmute(mem_blk) };
            mem_blk as u64
        });
        __bindgen_bitfield_unit.set(43usize, 3u8, {
            let mem_hops: u64 = unsafe { ::core::mem::transmute(mem_hops) };
            mem_hops as u64
        });
        __bindgen_bitfield_unit.set(46usize, 18u8, {
            let mem_rsvd: u64 = unsafe { ::core::mem::transmute(mem_rsvd) };
            mem_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_branch_entry {
    pub from: __u64,
    pub to: __u64,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_branch_entry {
    #[inline]
    pub fn mispred(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mispred(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn predicted(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_predicted(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_tx(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_in_tx(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abort(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_abort(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cycles(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_cycles(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn spec(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_spec(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_type(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_new_type(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn priv_(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_priv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 31u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mispred: __u64,
        predicted: __u64,
        in_tx: __u64,
        abort: __u64,
        cycles: __u64,
        type_: __u64,
        spec: __u64,
        new_type: __u64,
        priv_: __u64,
        reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mispred: u64 = unsafe { ::core::mem::transmute(mispred) };
            mispred as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let predicted: u64 = unsafe { ::core::mem::transmute(predicted) };
            predicted as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_tx: u64 = unsafe { ::core::mem::transmute(in_tx) };
            in_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let abort: u64 = unsafe { ::core::mem::transmute(abort) };
            abort as u64
        });
        __bindgen_bitfield_unit.set(4usize, 16u8, {
            let cycles: u64 = unsafe { ::core::mem::transmute(cycles) };
            cycles as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let type_: u64 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let spec: u64 = unsafe { ::core::mem::transmute(spec) };
            spec as u64
        });
        __bindgen_bitfield_unit.set(26usize, 4u8, {
            let new_type: u64 = unsafe { ::core::mem::transmute(new_type) };
            new_type as u64
        });
        __bindgen_bitfield_unit.set(30usize, 3u8, {
            let priv_: u64 = unsafe { ::core::mem::transmute(priv_) };
            priv_ as u64
        });
        __bindgen_bitfield_unit.set(33usize, 31u8, {
            let reserved: u64 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_sample_weight {
    pub full: __u64,
    pub __bindgen_anon_1: perf_sample_weight__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_weight__bindgen_ty_1 {
    pub var1_dw: __u32,
    pub var2_w: __u16,
    pub var3_w: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_namespace {
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ns_operations {
    pub name: *const ::aya_bpf::cty::c_char,
    pub real_ns_name: *const ::aya_bpf::cty::c_char,
    pub type_: ::aya_bpf::cty::c_int,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct) -> *mut ns_common>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common)>,
    pub install: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nsset, arg2: *mut ns_common) -> ::aya_bpf::cty::c_int,
    >,
    pub owner:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut user_namespace>,
    pub get_parent:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ns_common) -> *mut ns_common>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmu {
    pub entry: list_head,
    pub module: *mut module,
    pub dev: *mut device,
    pub attr_groups: *mut *const attribute_group,
    pub attr_update: *mut *const attribute_group,
    pub name: *const ::aya_bpf::cty::c_char,
    pub type_: ::aya_bpf::cty::c_int,
    pub capabilities: ::aya_bpf::cty::c_int,
    pub pmu_disable_count: *mut ::aya_bpf::cty::c_int,
    pub cpu_pmu_context: *mut perf_cpu_pmu_context,
    pub exclusive_cnt: atomic_t,
    pub task_ctx_nr: ::aya_bpf::cty::c_int,
    pub hrtimer_interval_ms: ::aya_bpf::cty::c_int,
    pub nr_addr_filters: ::aya_bpf::cty::c_uint,
    pub pmu_enable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub pmu_disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub event_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf::cty::c_int,
    >,
    pub event_mapped:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    pub event_unmapped:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event, arg2: *mut mm_struct)>,
    pub add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf::cty::c_int),
    >,
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf::cty::c_int),
    >,
    pub stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: ::aya_bpf::cty::c_int),
    >,
    pub read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub start_txn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu, arg2: ::aya_bpf::cty::c_uint)>,
    pub commit_txn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu) -> ::aya_bpf::cty::c_int>,
    pub cancel_txn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pmu)>,
    pub event_idx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf::cty::c_int,
    >,
    pub sched_task: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event_pmu_context, arg2: bool_),
    >,
    pub task_ctx_cache: *mut kmem_cache,
    pub swap_task_ctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event_pmu_context, arg2: *mut perf_event_pmu_context),
    >,
    pub setup_aux: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: *mut *mut ::aya_bpf::cty::c_void,
            arg3: ::aya_bpf::cty::c_int,
            arg4: bool_,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub free_aux: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub snapshot_aux: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut perf_event,
            arg2: *mut perf_output_handle,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub addr_filters_validate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut list_head) -> ::aya_bpf::cty::c_int>,
    pub addr_filters_sync: ::core::option::Option<unsafe extern "C" fn(arg1: *mut perf_event)>,
    pub aux_output_match: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event) -> ::aya_bpf::cty::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pmu, arg2: ::aya_bpf::cty::c_int) -> bool_,
    >,
    pub check_period: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut perf_event, arg2: u64_) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_regs {
    pub regs: pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::aya_bpf::cty::c_void,
    pub iov_len: __kernel_size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut ::aya_bpf::cty::c_void,
    pub iov_len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: ::aya_bpf::cty::c_uint,
    pub bv_offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_regs {
    pub abi: __u64,
    pub regs: *mut pt_regs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psi_group_cpu {
    pub seq: seqcount_t,
    pub tasks: [::aya_bpf::cty::c_uint; 4usize],
    pub state_mask: u32_,
    pub times: [u32_; 7usize],
    pub state_start: u64_,
    pub times_prev: [u32_; 14usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl psi_group_cpu {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psi_group {
    pub parent: *mut psi_group,
    pub enabled: bool_,
    pub avgs_lock: mutex,
    pub pcpu: *mut psi_group_cpu,
    pub avg_total: [u64_; 6usize],
    pub avg_last_update: u64_,
    pub avg_next_update: u64_,
    pub avgs_work: delayed_work,
    pub total: [u64_; 12usize],
    pub avg: [::aya_bpf::cty::c_ulong; 18usize],
    pub poll_task: *mut task_struct,
    pub poll_timer: timer_list,
    pub poll_wait: wait_queue_head_t,
    pub poll_wakeup: atomic_t,
    pub poll_scheduled: atomic_t,
    pub trigger_lock: mutex,
    pub triggers: list_head,
    pub nr_triggers: [u32_; 6usize],
    pub poll_states: u32_,
    pub poll_min_period: u64_,
    pub polling_total: [u64_; 6usize],
    pub polling_next_update: u64_,
    pub polling_until: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state) -> ::aya_bpf::cty::c_int,
    >,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: ::aya_bpf::cty::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut cgroup_subsys_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub can_attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_taskset) -> ::aya_bpf::cty::c_int,
    >,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_taskset)>,
    pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
    pub can_fork: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut css_set) -> ::aya_bpf::cty::c_int,
    >,
    pub cancel_fork:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct, arg2: *mut css_set)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cgroup_subsys_state)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub id: ::aya_bpf::cty::c_int,
    pub name: *const ::aya_bpf::cty::c_char,
    pub legacy_name: *const ::aya_bpf::cty::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: ::aya_bpf::cty::c_uint,
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_rstat_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub updated_children: *mut cgroup,
    pub updated_next: *mut cgroup,
}
#[repr(C)]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: ::aya_bpf::cty::c_uint,
    pub hierarchy_id: ::aya_bpf::cty::c_int,
    pub cgrp: cgroup,
    pub cgrp_ancestor_storage: *mut cgroup,
    pub nr_cgrps: atomic_t,
    pub root_list: list_head,
    pub flags: ::aya_bpf::cty::c_uint,
    pub release_agent_path: [::aya_bpf::cty::c_char; 4096usize],
    pub name: [::aya_bpf::cty::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cftype {
    pub name: [::aya_bpf::cty::c_char; 64usize],
    pub private: ::aya_bpf::cty::c_ulong,
    pub max_write_len: usize,
    pub flags: ::aya_bpf::cty::c_uint,
    pub file_offset: ::aya_bpf::cty::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cgroup_subsys_state, arg2: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut loff_t,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub seq_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cgroup_subsys_state,
            arg2: *mut cftype,
            arg3: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cgroup_subsys_state,
            arg2: *mut cftype,
            arg3: s64,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_open_file,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_open_file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct perf_callchain_entry {
    pub nr: __u64,
    pub ip: __IncompleteArrayField<__u64>,
}
pub type perf_copy_f = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf::cty::c_void,
        arg2: *const ::aya_bpf::cty::c_void,
        arg3: ::aya_bpf::cty::c_ulong,
        arg4: ::aya_bpf::cty::c_ulong,
    ) -> ::aya_bpf::cty::c_ulong,
>;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct perf_raw_frag {
    pub __bindgen_anon_1: perf_raw_frag__bindgen_ty_1,
    pub copy: perf_copy_f,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub size: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_raw_frag__bindgen_ty_1 {
    pub next: *mut perf_raw_frag,
    pub pad: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_raw_record {
    pub frag: perf_raw_frag,
    pub size: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct perf_branch_stack {
    pub nr: __u64,
    pub hw_idx: __u64,
    pub entries: __IncompleteArrayField<perf_branch_entry>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_pmu_context {
    pub pmu: *mut pmu,
    pub ctx: *mut perf_event_context,
    pub pmu_ctx_entry: list_head,
    pub pinned_active: list_head,
    pub flexible_active: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: ::aya_bpf::cty::c_uint,
    pub refcount: atomic_t,
    pub callback_head: callback_head,
    pub task_ctx_data: *mut ::aya_bpf::cty::c_void,
    pub rotate_necessary: ::aya_bpf::cty::c_int,
}
impl perf_event_pmu_context {
    #[inline]
    pub fn embedded(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_embedded(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(embedded: ::aya_bpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let embedded: u32 = unsafe { ::core::mem::transmute(embedded) };
            embedded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_cpu_pmu_context {
    pub epc: perf_event_pmu_context,
    pub task_epc: *mut perf_event_pmu_context,
    pub sched_cb_entry: list_head,
    pub sched_cb_usage: ::aya_bpf::cty::c_int,
    pub active_oncpu: ::aya_bpf::cty::c_int,
    pub exclusive: ::aya_bpf::cty::c_int,
    pub hrtimer_lock: raw_spinlock_t,
    pub hrtimer: hrtimer,
    pub hrtimer_interval: ktime_t,
    pub hrtimer_active: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_output_handle {
    pub event: *mut perf_event,
    pub rb: *mut perf_buffer,
    pub wakeup: ::aya_bpf::cty::c_ulong,
    pub size: ::aya_bpf::cty::c_ulong,
    pub aux_flags: u64_,
    pub __bindgen_anon_1: perf_output_handle__bindgen_ty_1,
    pub page: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_output_handle__bindgen_ty_1 {
    pub addr: *mut ::aya_bpf::cty::c_void,
    pub head: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_addr_filter_range {
    pub start: ::aya_bpf::cty::c_ulong,
    pub size: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_sample_data {
    pub sample_flags: u64_,
    pub period: u64_,
    pub br_stack: *mut perf_branch_stack,
    pub weight: perf_sample_weight,
    pub data_src: perf_mem_data_src,
    pub txn: u64_,
    pub addr: u64_,
    pub raw: *mut perf_raw_record,
    pub type_: u64_,
    pub ip: u64_,
    pub tid_entry: perf_sample_data__bindgen_ty_1,
    pub time: u64_,
    pub id: u64_,
    pub stream_id: u64_,
    pub cpu_entry: perf_sample_data__bindgen_ty_2,
    pub callchain: *mut perf_callchain_entry,
    pub aux_size: u64_,
    pub regs_user: perf_regs,
    pub regs_intr: perf_regs,
    pub stack_user_size: u64_,
    pub phys_addr: u64_,
    pub cgroup: u64_,
    pub data_page_size: u64_,
    pub code_page_size: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_data__bindgen_ty_1 {
    pub pid: u32_,
    pub tid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_sample_data__bindgen_ty_2 {
    pub cpu: u32_,
    pub reserved: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_cgroup {
    pub css: cgroup_subsys_state,
    pub info: *mut perf_cgroup_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_cgroup_info {
    pub time: u64_,
    pub timestamp: u64_,
    pub timeoffset: u64_,
    pub active: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_entry {
    pub type_: ::aya_bpf::cty::c_ushort,
    pub flags: ::aya_bpf::cty::c_uchar,
    pub preempt_count: ::aya_bpf::cty::c_uchar,
    pub pid: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_iterator {
    pub tr: *mut trace_array,
    pub trace: *mut tracer,
    pub array_buffer: *mut array_buffer,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub cpu_file: ::aya_bpf::cty::c_int,
    pub mutex: mutex,
    pub buffer_iter: *mut *mut ring_buffer_iter,
    pub iter_flags: ::aya_bpf::cty::c_ulong,
    pub temp: *mut ::aya_bpf::cty::c_void,
    pub temp_size: ::aya_bpf::cty::c_uint,
    pub fmt: *mut ::aya_bpf::cty::c_char,
    pub fmt_size: ::aya_bpf::cty::c_uint,
    pub wait_index: ::aya_bpf::cty::c_long,
    pub tmp_seq: trace_seq,
    pub started: cpumask_var_t,
    pub snapshot: bool_,
    pub seq: trace_seq,
    pub ent: *mut trace_entry,
    pub lost_events: ::aya_bpf::cty::c_ulong,
    pub leftover: ::aya_bpf::cty::c_int,
    pub ent_size: ::aya_bpf::cty::c_int,
    pub cpu: ::aya_bpf::cty::c_int,
    pub ts: u64_,
    pub pos: loff_t,
    pub idx: ::aya_bpf::cty::c_long,
}
pub mod print_line_t {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TRACE_TYPE_PARTIAL_LINE: Type = 0;
    pub const TRACE_TYPE_HANDLED: Type = 1;
    pub const TRACE_TYPE_UNHANDLED: Type = 2;
    pub const TRACE_TYPE_NO_CONSUME: Type = 3;
}
pub type trace_print_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut trace_iterator,
        arg2: ::aya_bpf::cty::c_int,
        arg3: *mut trace_event,
    ) -> print_line_t::Type,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_functions {
    pub trace: trace_print_func,
    pub raw: trace_print_func,
    pub hex: trace_print_func,
    pub binary: trace_print_func,
}
pub mod trace_reg {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TRACE_REG_REGISTER: Type = 0;
    pub const TRACE_REG_UNREGISTER: Type = 1;
    pub const TRACE_REG_PERF_REGISTER: Type = 2;
    pub const TRACE_REG_PERF_UNREGISTER: Type = 3;
    pub const TRACE_REG_PERF_OPEN: Type = 4;
    pub const TRACE_REG_PERF_CLOSE: Type = 5;
    pub const TRACE_REG_PERF_ADD: Type = 6;
    pub const TRACE_REG_PERF_DEL: Type = 7;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_event_fields {
    pub type_: *const ::aya_bpf::cty::c_char,
    pub __bindgen_anon_1: trace_event_fields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union trace_event_fields__bindgen_ty_1 {
    pub __bindgen_anon_1: trace_event_fields__bindgen_ty_1__bindgen_ty_1,
    pub define_fields: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_fields__bindgen_ty_1__bindgen_ty_1 {
    pub name: *const ::aya_bpf::cty::c_char,
    pub size: ::aya_bpf::cty::c_int,
    pub align: ::aya_bpf::cty::c_int,
    pub is_signed: ::aya_bpf::cty::c_int,
    pub filter_type: ::aya_bpf::cty::c_int,
    pub len: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_class {
    pub system: *const ::aya_bpf::cty::c_char,
    pub probe: *mut ::aya_bpf::cty::c_void,
    pub perf_probe: *mut ::aya_bpf::cty::c_void,
    pub reg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_event_call,
            arg2: trace_reg::Type,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fields_array: *mut trace_event_fields,
    pub get_fields:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_event_call) -> *mut list_head>,
    pub fields: list_head,
    pub raw_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_event_call) -> ::aya_bpf::cty::c_int,
    >,
}
pub mod dev_dma_attr {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEV_DMA_NOT_SUPPORTED: Type = 0;
    pub const DEV_DMA_NON_COHERENT: Type = 1;
    pub const DEV_DMA_COHERENT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const device,
        ) -> *const ::aya_bpf::cty::c_void,
    >,
    pub device_dma_supported:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const fwnode_handle) -> bool_>,
    pub device_get_dma_attr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> dev_dma_attr::Type,
    >,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf::cty::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut ::aya_bpf::cty::c_void,
            arg5: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: *mut *const ::aya_bpf::cty::c_char,
            arg4: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf::cty::c_char,
    >,
    pub get_name_prefix: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *const ::aya_bpf::cty::c_char,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf::cty::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: ::aya_bpf::cty::c_uint,
            arg6: *mut fwnode_reference_args,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: *mut fwnode_endpoint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iomap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fwnode_handle,
            arg2: ::aya_bpf::cty::c_int,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub irq_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const fwnode_handle,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub add_links: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fwnode_handle) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: ::aya_bpf::cty::c_uint,
    pub id: ::aya_bpf::cty::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: ::aya_bpf::cty::c_uint,
    pub args: [u64_; 8usize],
}
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const ::aya_bpf::cty::c_void,
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_void, arg2: u32_, arg3: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_void, arg2: u32_, arg3: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rhashtable_compare_arg,
        arg2: *const ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: ::aya_bpf::cty::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: ::aya_bpf::cty::c_uint,
    pub max_elems: ::aya_bpf::cty::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    pub mutex: mutex,
    pub rd_wait: wait_queue_head_t,
    pub wr_wait: wait_queue_head_t,
    pub head: ::aya_bpf::cty::c_uint,
    pub tail: ::aya_bpf::cty::c_uint,
    pub max_usage: ::aya_bpf::cty::c_uint,
    pub ring_size: ::aya_bpf::cty::c_uint,
    pub note_loss: bool_,
    pub nr_accounted: ::aya_bpf::cty::c_uint,
    pub readers: ::aya_bpf::cty::c_uint,
    pub writers: ::aya_bpf::cty::c_uint,
    pub files: ::aya_bpf::cty::c_uint,
    pub r_counter: ::aya_bpf::cty::c_uint,
    pub w_counter: ::aya_bpf::cty::c_uint,
    pub poll_usage: bool_,
    pub tmp_page: *mut page,
    pub fasync_readers: *mut fasync_struct,
    pub fasync_writers: *mut fasync_struct,
    pub bufs: *mut pipe_buffer,
    pub user: *mut user_struct,
    pub watch_queue: *mut watch_queue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct new_utsname {
    pub sysname: [::aya_bpf::cty::c_char; 65usize],
    pub nodename: [::aya_bpf::cty::c_char; 65usize],
    pub release: [::aya_bpf::cty::c_char; 65usize],
    pub version: [::aya_bpf::cty::c_char; 65usize],
    pub machine: [::aya_bpf::cty::c_char; 65usize],
    pub domainname: [::aya_bpf::cty::c_char; 65usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uts_namespace {
    pub name: new_utsname,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ref_tracker_dir {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_core {
    pub sysctl_hdr: *mut ctl_table_header,
    pub sysctl_somaxconn: ::aya_bpf::cty::c_int,
    pub sysctl_txrehash: u8_,
    pub prot_inuse: *mut prot_inuse,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mib {
    pub ip_statistics: *mut ipstats_mib,
    pub ipv6_statistics: *mut ipstats_mib,
    pub tcp_statistics: *mut tcp_mib,
    pub net_statistics: *mut linux_mib,
    pub udp_statistics: *mut udp_mib,
    pub udp_stats_in6: *mut udp_mib,
    pub tls_statistics: *mut linux_tls_mib,
    pub mptcp_statistics: *mut mptcp_mib,
    pub udplite_statistics: *mut udp_mib,
    pub udplite_stats_in6: *mut udp_mib,
    pub icmp_statistics: *mut icmp_mib,
    pub icmpmsg_statistics: *mut icmpmsg_mib,
    pub icmpv6_statistics: *mut icmpv6_mib,
    pub icmpv6msg_statistics: *mut icmpv6msg_mib,
    pub proc_net_devsnmp6: *mut proc_dir_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_packet {
    pub sklist_lock: mutex,
    pub sklist: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unix_table {
    pub locks: *mut spinlock_t,
    pub buckets: *mut hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_unix {
    pub table: unix_table,
    pub sysctl_max_dgram_qlen: ::aya_bpf::cty::c_int,
    pub ctl: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nexthop {
    pub rb_root: rb_root,
    pub devhash: *mut hlist_head,
    pub seq: ::aya_bpf::cty::c_uint,
    pub last_id_allocated: u32_,
    pub notifier_chain: blocking_notifier_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_timewait_death_row {
    pub tw_refcount: refcount_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub hashinfo: *mut inet_hashinfo,
    pub sysctl_max_tw_buckets: ::aya_bpf::cty::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_ports {
    pub lock: seqlock_t,
    pub range: [::aya_bpf::cty::c_int; 2usize],
    pub warned: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ping_group_range {
    pub lock: seqlock_t,
    pub range: [kgid_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv4 {
    pub tcp_death_row: inet_timewait_death_row,
    pub udp_table: *mut udp_table,
    pub forw_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub ipv4_hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub xfrm4_hdr: *mut ctl_table_header,
    pub devconf_all: *mut ipv4_devconf,
    pub devconf_dflt: *mut ipv4_devconf,
    pub ra_chain: *mut ip_ra_chain,
    pub ra_mutex: mutex,
    pub rules_ops: *mut fib_rules_ops,
    pub fib_main: *mut fib_table,
    pub fib_default: *mut fib_table,
    pub fib_rules_require_fldissect: ::aya_bpf::cty::c_uint,
    pub fib_has_custom_rules: bool_,
    pub fib_has_custom_local_routes: bool_,
    pub fib_offload_disabled: bool_,
    pub fib_num_tclassid_users: atomic_t,
    pub fib_table_hash: *mut hlist_head,
    pub fibnl: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub sysctl_icmp_echo_ignore_all: u8_,
    pub sysctl_icmp_echo_enable_probe: u8_,
    pub sysctl_icmp_echo_ignore_broadcasts: u8_,
    pub sysctl_icmp_ignore_bogus_error_responses: u8_,
    pub sysctl_icmp_errors_use_inbound_ifaddr: u8_,
    pub sysctl_icmp_ratelimit: ::aya_bpf::cty::c_int,
    pub sysctl_icmp_ratemask: ::aya_bpf::cty::c_int,
    pub ip_rt_min_pmtu: u32_,
    pub ip_rt_mtu_expires: ::aya_bpf::cty::c_int,
    pub ip_rt_min_advmss: ::aya_bpf::cty::c_int,
    pub ip_local_ports: local_ports,
    pub sysctl_tcp_ecn: u8_,
    pub sysctl_tcp_ecn_fallback: u8_,
    pub sysctl_ip_default_ttl: u8_,
    pub sysctl_ip_no_pmtu_disc: u8_,
    pub sysctl_ip_fwd_use_pmtu: u8_,
    pub sysctl_ip_fwd_update_priority: u8_,
    pub sysctl_ip_nonlocal_bind: u8_,
    pub sysctl_ip_autobind_reuse: u8_,
    pub sysctl_ip_dynaddr: u8_,
    pub sysctl_ip_early_demux: u8_,
    pub sysctl_raw_l3mdev_accept: u8_,
    pub sysctl_tcp_early_demux: u8_,
    pub sysctl_udp_early_demux: u8_,
    pub sysctl_nexthop_compat_mode: u8_,
    pub sysctl_fwmark_reflect: u8_,
    pub sysctl_tcp_fwmark_accept: u8_,
    pub sysctl_tcp_l3mdev_accept: u8_,
    pub sysctl_tcp_mtu_probing: u8_,
    pub sysctl_tcp_mtu_probe_floor: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_base_mss: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_min_snd_mss: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_probe_threshold: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_probe_interval: u32_,
    pub sysctl_tcp_keepalive_time: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_keepalive_intvl: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_keepalive_probes: u8_,
    pub sysctl_tcp_syn_retries: u8_,
    pub sysctl_tcp_synack_retries: u8_,
    pub sysctl_tcp_syncookies: u8_,
    pub sysctl_tcp_migrate_req: u8_,
    pub sysctl_tcp_comp_sack_nr: u8_,
    pub sysctl_tcp_reordering: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_retries1: u8_,
    pub sysctl_tcp_retries2: u8_,
    pub sysctl_tcp_orphan_retries: u8_,
    pub sysctl_tcp_tw_reuse: u8_,
    pub sysctl_tcp_fin_timeout: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_notsent_lowat: ::aya_bpf::cty::c_uint,
    pub sysctl_tcp_sack: u8_,
    pub sysctl_tcp_window_scaling: u8_,
    pub sysctl_tcp_timestamps: u8_,
    pub sysctl_tcp_early_retrans: u8_,
    pub sysctl_tcp_recovery: u8_,
    pub sysctl_tcp_thin_linear_timeouts: u8_,
    pub sysctl_tcp_slow_start_after_idle: u8_,
    pub sysctl_tcp_retrans_collapse: u8_,
    pub sysctl_tcp_stdurg: u8_,
    pub sysctl_tcp_rfc1337: u8_,
    pub sysctl_tcp_abort_on_overflow: u8_,
    pub sysctl_tcp_fack: u8_,
    pub sysctl_tcp_max_reordering: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_adv_win_scale: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_dsack: u8_,
    pub sysctl_tcp_app_win: u8_,
    pub sysctl_tcp_frto: u8_,
    pub sysctl_tcp_nometrics_save: u8_,
    pub sysctl_tcp_no_ssthresh_metrics_save: u8_,
    pub sysctl_tcp_moderate_rcvbuf: u8_,
    pub sysctl_tcp_tso_win_divisor: u8_,
    pub sysctl_tcp_workaround_signed_windows: u8_,
    pub sysctl_tcp_limit_output_bytes: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_challenge_ack_limit: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_min_rtt_wlen: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_min_tso_segs: u8_,
    pub sysctl_tcp_tso_rtt_log: u8_,
    pub sysctl_tcp_autocorking: u8_,
    pub sysctl_tcp_reflect_tos: u8_,
    pub sysctl_tcp_invalid_ratelimit: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_pacing_ss_ratio: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_pacing_ca_ratio: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_wmem: [::aya_bpf::cty::c_int; 3usize],
    pub sysctl_tcp_rmem: [::aya_bpf::cty::c_int; 3usize],
    pub sysctl_tcp_child_ehash_entries: ::aya_bpf::cty::c_uint,
    pub sysctl_tcp_comp_sack_delay_ns: ::aya_bpf::cty::c_ulong,
    pub sysctl_tcp_comp_sack_slack_ns: ::aya_bpf::cty::c_ulong,
    pub sysctl_max_syn_backlog: ::aya_bpf::cty::c_int,
    pub sysctl_tcp_fastopen: ::aya_bpf::cty::c_int,
    pub tcp_congestion_control: *const tcp_congestion_ops,
    pub tcp_fastopen_ctx: *mut tcp_fastopen_context,
    pub sysctl_tcp_fastopen_blackhole_timeout: ::aya_bpf::cty::c_uint,
    pub tfo_active_disable_times: atomic_t,
    pub tfo_active_disable_stamp: ::aya_bpf::cty::c_ulong,
    pub tcp_challenge_timestamp: u32_,
    pub tcp_challenge_count: u32_,
    pub sysctl_tcp_plb_enabled: u8_,
    pub sysctl_tcp_plb_idle_rehash_rounds: u8_,
    pub sysctl_tcp_plb_rehash_rounds: u8_,
    pub sysctl_tcp_plb_suspend_rto_sec: u8_,
    pub sysctl_tcp_plb_cong_thresh: ::aya_bpf::cty::c_int,
    pub sysctl_udp_wmem_min: ::aya_bpf::cty::c_int,
    pub sysctl_udp_rmem_min: ::aya_bpf::cty::c_int,
    pub sysctl_fib_notify_on_flag_change: u8_,
    pub sysctl_udp_l3mdev_accept: u8_,
    pub sysctl_igmp_llm_reports: u8_,
    pub sysctl_igmp_max_memberships: ::aya_bpf::cty::c_int,
    pub sysctl_igmp_max_msf: ::aya_bpf::cty::c_int,
    pub sysctl_igmp_qrv: ::aya_bpf::cty::c_int,
    pub ping_group_range: ping_group_range,
    pub dev_addr_genid: atomic_t,
    pub sysctl_udp_child_hash_entries: ::aya_bpf::cty::c_uint,
    pub sysctl_local_reserved_ports: *mut ::aya_bpf::cty::c_ulong,
    pub sysctl_ip_prot_sock: ::aya_bpf::cty::c_int,
    pub mr_tables: list_head,
    pub mr_rules_ops: *mut fib_rules_ops,
    pub sysctl_fib_multipath_hash_fields: u32_,
    pub sysctl_fib_multipath_use_neigh: u8_,
    pub sysctl_fib_multipath_hash_policy: u8_,
    pub notifier_ops: *mut fib_notifier_ops,
    pub fib_seq: ::aya_bpf::cty::c_uint,
    pub ipmr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: ::aya_bpf::cty::c_uint,
    pub rt_genid: atomic_t,
    pub ip_id_key: siphash_key_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl netns_ipv4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_ops {
    pub family: ::aya_bpf::cty::c_ushort,
    pub gc_thresh: ::aya_bpf::cty::c_uint,
    pub gc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_ops) -> ::aya_bpf::cty::c_int>,
    pub check: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: __u32) -> *mut dst_entry,
    >,
    pub default_advmss: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf::cty::c_uint,
    >,
    pub mtu: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry) -> ::aya_bpf::cty::c_uint,
    >,
    pub cow_metrics: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: ::aya_bpf::cty::c_ulong) -> *mut u32_,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>,
    pub ifdown: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dst_entry,
            arg2: *mut net_device,
            arg3: ::aya_bpf::cty::c_int,
        ),
    >,
    pub negative_advice:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>,
    pub link_failure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub update_pmtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dst_entry,
            arg2: *mut sock,
            arg3: *mut sk_buff,
            arg4: u32_,
            arg5: bool_,
        ),
    >,
    pub redirect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: *mut sock, arg3: *mut sk_buff),
    >,
    pub local_out: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub neigh_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dst_entry,
            arg2: *mut sk_buff,
            arg3: *const ::aya_bpf::cty::c_void,
        ) -> *mut neighbour,
    >,
    pub confirm_neigh: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dst_entry, arg2: *const ::aya_bpf::cty::c_void),
    >,
    pub kmem_cachep: *mut kmem_cache,
    pub pcpuc_entries: percpu_counter,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl dst_ops {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_ipv6 {
    pub hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub icmp_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub xfrm6_hdr: *mut ctl_table_header,
    pub flush_delay: ::aya_bpf::cty::c_int,
    pub ip6_rt_max_size: ::aya_bpf::cty::c_int,
    pub ip6_rt_gc_min_interval: ::aya_bpf::cty::c_int,
    pub ip6_rt_gc_timeout: ::aya_bpf::cty::c_int,
    pub ip6_rt_gc_interval: ::aya_bpf::cty::c_int,
    pub ip6_rt_gc_elasticity: ::aya_bpf::cty::c_int,
    pub ip6_rt_mtu_expires: ::aya_bpf::cty::c_int,
    pub ip6_rt_min_advmss: ::aya_bpf::cty::c_int,
    pub multipath_hash_fields: u32_,
    pub multipath_hash_policy: u8_,
    pub bindv6only: u8_,
    pub flowlabel_consistency: u8_,
    pub auto_flowlabels: u8_,
    pub icmpv6_time: ::aya_bpf::cty::c_int,
    pub icmpv6_echo_ignore_all: u8_,
    pub icmpv6_echo_ignore_multicast: u8_,
    pub icmpv6_echo_ignore_anycast: u8_,
    pub icmpv6_ratemask: [::aya_bpf::cty::c_ulong; 4usize],
    pub icmpv6_ratemask_ptr: *mut ::aya_bpf::cty::c_ulong,
    pub anycast_src_echo_reply: u8_,
    pub ip_nonlocal_bind: u8_,
    pub fwmark_reflect: u8_,
    pub flowlabel_state_ranges: u8_,
    pub idgen_retries: ::aya_bpf::cty::c_int,
    pub idgen_delay: ::aya_bpf::cty::c_int,
    pub flowlabel_reflect: ::aya_bpf::cty::c_int,
    pub max_dst_opts_cnt: ::aya_bpf::cty::c_int,
    pub max_hbh_opts_cnt: ::aya_bpf::cty::c_int,
    pub max_dst_opts_len: ::aya_bpf::cty::c_int,
    pub max_hbh_opts_len: ::aya_bpf::cty::c_int,
    pub seg6_flowlabel: ::aya_bpf::cty::c_int,
    pub ioam6_id: u32_,
    pub ioam6_id_wide: u64_,
    pub skip_notify_on_dev_down: bool_,
    pub fib_notify_on_flag_change: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6 {
    pub ip6_dst_ops: dst_ops,
    pub sysctl: netns_sysctl_ipv6,
    pub devconf_all: *mut ipv6_devconf,
    pub devconf_dflt: *mut ipv6_devconf,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub fib6_null_entry: *mut fib6_info,
    pub ip6_null_entry: *mut rt6_info,
    pub rt6_stats: *mut rt6_statistics,
    pub ip6_fib_timer: timer_list,
    pub fib_table_hash: *mut hlist_head,
    pub fib6_main_tbl: *mut fib6_table,
    pub fib6_walkers: list_head,
    pub fib6_walker_lock: rwlock_t,
    pub fib6_gc_lock: spinlock_t,
    pub ip6_rt_gc_expire: atomic_t,
    pub ip6_rt_last_gc: ::aya_bpf::cty::c_ulong,
    pub flowlabel_has_excl: ::aya_bpf::cty::c_uchar,
    pub fib6_has_custom_rules: bool_,
    pub fib6_rules_require_fldissect: ::aya_bpf::cty::c_uint,
    pub fib6_routes_require_src: ::aya_bpf::cty::c_uint,
    pub ip6_prohibit_entry: *mut rt6_info,
    pub ip6_blk_hole_entry: *mut rt6_info,
    pub fib6_local_tbl: *mut fib6_table,
    pub fib6_rules_ops: *mut fib_rules_ops,
    pub ndisc_sk: *mut sock,
    pub tcp_sk: *mut sock,
    pub igmp_sk: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub inet6_addr_lst: *mut hlist_head,
    pub addrconf_hash_lock: spinlock_t,
    pub addr_chk_work: delayed_work,
    pub mr6_tables: list_head,
    pub mr6_rules_ops: *mut fib_rules_ops,
    pub dev_addr_genid: atomic_t,
    pub fib6_sernum: atomic_t,
    pub seg6_data: *mut seg6_pernet_data,
    pub notifier_ops: *mut fib_notifier_ops,
    pub ip6mr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: ::aya_bpf::cty::c_uint,
    pub ip6addrlbl_table: netns_ipv6__bindgen_ty_1,
    pub ioam6_data: *mut ioam6_pernet_data,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6__bindgen_ty_1 {
    pub head: hlist_head,
    pub lock: spinlock_t,
    pub seq: u32_,
}
impl netns_ipv6 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_sysctl_lowpan {
    pub frags_hdr: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ieee802154_lowpan {
    pub sysctl: netns_sysctl_lowpan,
    pub fqdir: *mut fqdir,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sctp_mib {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sctp {
    pub sctp_statistics: *mut sctp_mib,
    pub proc_net_sctp: *mut proc_dir_entry,
    pub sysctl_header: *mut ctl_table_header,
    pub ctl_sock: *mut sock,
    pub udp4_sock: *mut sock,
    pub udp6_sock: *mut sock,
    pub udp_port: ::aya_bpf::cty::c_int,
    pub encap_port: ::aya_bpf::cty::c_int,
    pub local_addr_list: list_head,
    pub addr_waitq: list_head,
    pub addr_wq_timer: timer_list,
    pub auto_asconf_splist: list_head,
    pub addr_wq_lock: spinlock_t,
    pub local_addr_lock: spinlock_t,
    pub rto_initial: ::aya_bpf::cty::c_uint,
    pub rto_min: ::aya_bpf::cty::c_uint,
    pub rto_max: ::aya_bpf::cty::c_uint,
    pub rto_alpha: ::aya_bpf::cty::c_int,
    pub rto_beta: ::aya_bpf::cty::c_int,
    pub max_burst: ::aya_bpf::cty::c_int,
    pub cookie_preserve_enable: ::aya_bpf::cty::c_int,
    pub sctp_hmac_alg: *mut ::aya_bpf::cty::c_char,
    pub valid_cookie_life: ::aya_bpf::cty::c_uint,
    pub sack_timeout: ::aya_bpf::cty::c_uint,
    pub hb_interval: ::aya_bpf::cty::c_uint,
    pub probe_interval: ::aya_bpf::cty::c_uint,
    pub max_retrans_association: ::aya_bpf::cty::c_int,
    pub max_retrans_path: ::aya_bpf::cty::c_int,
    pub max_retrans_init: ::aya_bpf::cty::c_int,
    pub pf_retrans: ::aya_bpf::cty::c_int,
    pub ps_retrans: ::aya_bpf::cty::c_int,
    pub pf_enable: ::aya_bpf::cty::c_int,
    pub pf_expose: ::aya_bpf::cty::c_int,
    pub sndbuf_policy: ::aya_bpf::cty::c_int,
    pub rcvbuf_policy: ::aya_bpf::cty::c_int,
    pub default_auto_asconf: ::aya_bpf::cty::c_int,
    pub addip_enable: ::aya_bpf::cty::c_int,
    pub addip_noauth: ::aya_bpf::cty::c_int,
    pub prsctp_enable: ::aya_bpf::cty::c_int,
    pub reconf_enable: ::aya_bpf::cty::c_int,
    pub auth_enable: ::aya_bpf::cty::c_int,
    pub intl_enable: ::aya_bpf::cty::c_int,
    pub ecn_enable: ::aya_bpf::cty::c_int,
    pub scope_policy: ::aya_bpf::cty::c_int,
    pub rwnd_upd_shift: ::aya_bpf::cty::c_int,
    pub max_autoclose: ::aya_bpf::cty::c_ulong,
    pub l3mdev_accept: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nf {
    pub proc_netfilter: *mut proc_dir_entry,
    pub nf_loggers: [*const nf_logger; 11usize],
    pub nf_log_dir_header: *mut ctl_table_header,
    pub hooks_ipv4: [*mut nf_hook_entries; 5usize],
    pub hooks_ipv6: [*mut nf_hook_entries; 5usize],
    pub hooks_arp: [*mut nf_hook_entries; 3usize],
    pub hooks_bridge: [*mut nf_hook_entries; 5usize],
    pub defrag_ipv4_users: ::aya_bpf::cty::c_uint,
    pub defrag_ipv6_users: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_generic_net {
    pub timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_tcp_net {
    pub timeouts: [::aya_bpf::cty::c_uint; 14usize],
    pub tcp_loose: u8_,
    pub tcp_be_liberal: u8_,
    pub tcp_max_retrans: u8_,
    pub tcp_ignore_invalid_rst: u8_,
    pub offload_timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_udp_net {
    pub timeouts: [::aya_bpf::cty::c_uint; 2usize],
    pub offload_timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_icmp_net {
    pub timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_dccp_net {
    pub dccp_loose: u8_,
    pub dccp_timeout: [::aya_bpf::cty::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_sctp_net {
    pub timeouts: [::aya_bpf::cty::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_gre_net {
    pub keymap_list: list_head,
    pub timeouts: [::aya_bpf::cty::c_uint; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ip_net {
    pub generic: nf_generic_net,
    pub tcp: nf_tcp_net,
    pub udp: nf_udp_net,
    pub icmp: nf_icmp_net,
    pub icmpv6: nf_icmp_net,
    pub dccp: nf_dccp_net,
    pub sctp: nf_sctp_net,
    pub gre: nf_gre_net,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ct {
    pub ecache_dwork_pending: bool_,
    pub sysctl_log_invalid: u8_,
    pub sysctl_events: u8_,
    pub sysctl_acct: u8_,
    pub sysctl_tstamp: u8_,
    pub sysctl_checksum: u8_,
    pub stat: *mut ip_conntrack_stat,
    pub nf_conntrack_event_cb: *mut nf_ct_event_notifier,
    pub nf_ct_proto: nf_ip_net,
    pub labels_used: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_nftables {
    pub gencursor: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ft {
    pub stat: *mut nf_flow_table_stat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff_list {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff_head__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1__bindgen_ty_1,
    pub list: sk_buff_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_bpf {
    pub run_array: [*mut bpf_prog_array; 2usize],
    pub progs: [*mut bpf_prog; 2usize],
    pub links: [list_head; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy_hash {
    pub table: *mut hlist_head,
    pub hmask: ::aya_bpf::cty::c_uint,
    pub dbits4: u8_,
    pub sbits4: u8_,
    pub dbits6: u8_,
    pub sbits6: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_hthresh {
    pub work: work_struct,
    pub lock: seqlock_t,
    pub lbits4: u8_,
    pub rbits4: u8_,
    pub lbits6: u8_,
    pub rbits6: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xfrm {
    pub state_all: list_head,
    pub state_bydst: *mut hlist_head,
    pub state_bysrc: *mut hlist_head,
    pub state_byspi: *mut hlist_head,
    pub state_byseq: *mut hlist_head,
    pub state_hmask: ::aya_bpf::cty::c_uint,
    pub state_num: ::aya_bpf::cty::c_uint,
    pub state_hash_work: work_struct,
    pub policy_all: list_head,
    pub policy_byidx: *mut hlist_head,
    pub policy_idx_hmask: ::aya_bpf::cty::c_uint,
    pub policy_inexact: [hlist_head; 3usize],
    pub policy_bydst: [xfrm_policy_hash; 3usize],
    pub policy_count: [::aya_bpf::cty::c_uint; 6usize],
    pub policy_hash_work: work_struct,
    pub policy_hthresh: xfrm_policy_hthresh,
    pub inexact_bins: list_head,
    pub nlsk: *mut sock,
    pub nlsk_stash: *mut sock,
    pub sysctl_aevent_etime: u32_,
    pub sysctl_aevent_rseqth: u32_,
    pub sysctl_larval_drop: ::aya_bpf::cty::c_int,
    pub sysctl_acq_expires: u32_,
    pub policy_default: [u8_; 3usize],
    pub sysctl_hdr: *mut ctl_table_header,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub xfrm4_dst_ops: dst_ops,
    pub xfrm6_dst_ops: dst_ops,
    pub xfrm_state_lock: spinlock_t,
    pub xfrm_state_hash_generation: seqcount_spinlock_t,
    pub xfrm_policy_hash_generation: seqcount_spinlock_t,
    pub xfrm_policy_lock: spinlock_t,
    pub xfrm_cfg_mutex: mutex,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl netns_xfrm {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_ipvs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_mpls {
    pub ip_ttl_propagate: ::aya_bpf::cty::c_int,
    pub default_ttl: ::aya_bpf::cty::c_int,
    pub platform_labels: usize,
    pub platform_label: *mut *mut mpls_route,
    pub ctl: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_dev_rcv_lists {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_pkg_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct can_rcv_lists_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_can {
    pub proc_dir: *mut proc_dir_entry,
    pub pde_stats: *mut proc_dir_entry,
    pub pde_reset_stats: *mut proc_dir_entry,
    pub pde_rcvlist_all: *mut proc_dir_entry,
    pub pde_rcvlist_fil: *mut proc_dir_entry,
    pub pde_rcvlist_inv: *mut proc_dir_entry,
    pub pde_rcvlist_sff: *mut proc_dir_entry,
    pub pde_rcvlist_eff: *mut proc_dir_entry,
    pub pde_rcvlist_err: *mut proc_dir_entry,
    pub bcmproc_dir: *mut proc_dir_entry,
    pub rx_alldev_list: *mut can_dev_rcv_lists,
    pub rcvlists_lock: spinlock_t,
    pub stattimer: timer_list,
    pub pkg_stats: *mut can_pkg_stats,
    pub rcv_lists_stats: *mut can_rcv_lists_stats,
    pub cgw_list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xdp {
    pub lock: mutex,
    pub list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_mctp {
    pub routes: list_head,
    pub bind_lock: mutex,
    pub binds: hlist_head,
    pub keys_lock: spinlock_t,
    pub keys: hlist_head,
    pub default_net: ::aya_bpf::cty::c_uint,
    pub neigh_lock: mutex,
    pub neighbours: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smc_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smc_stats_rsn {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_smc {
    pub smc_stats: *mut smc_stats,
    pub mutex_fback_rsn: mutex,
    pub fback_rsn: *mut smc_stats_rsn,
    pub limit_smc_hs: bool_,
    pub smc_hdr: *mut ctl_table_header,
    pub sysctl_autocorking_size: ::aya_bpf::cty::c_uint,
    pub sysctl_smcr_buf_type: ::aya_bpf::cty::c_uint,
    pub sysctl_smcr_testlink_time: ::aya_bpf::cty::c_int,
    pub sysctl_wmem: ::aya_bpf::cty::c_int,
    pub sysctl_rmem: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net {
    pub passive: refcount_t,
    pub rules_mod_lock: spinlock_t,
    pub dev_unreg_count: atomic_t,
    pub dev_base_seq: ::aya_bpf::cty::c_uint,
    pub ifindex: ::aya_bpf::cty::c_int,
    pub nsid_lock: spinlock_t,
    pub fnhe_genid: atomic_t,
    pub list: list_head,
    pub exit_list: list_head,
    pub cleanup_list: llist_node,
    pub key_domain: *mut key_tag,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub netns_ids: idr,
    pub ns: ns_common,
    pub refcnt_tracker: ref_tracker_dir,
    pub notrefcnt_tracker: ref_tracker_dir,
    pub dev_base_head: list_head,
    pub proc_net: *mut proc_dir_entry,
    pub proc_net_stat: *mut proc_dir_entry,
    pub sysctls: ctl_table_set,
    pub rtnl: *mut sock,
    pub genl_sock: *mut sock,
    pub uevent_sock: *mut uevent_sock,
    pub dev_name_head: *mut hlist_head,
    pub dev_index_head: *mut hlist_head,
    pub netdev_chain: raw_notifier_head,
    pub hash_mix: u32_,
    pub loopback_dev: *mut net_device,
    pub rules_ops: list_head,
    pub core: netns_core,
    pub mib: netns_mib,
    pub packet: netns_packet,
    pub unx: netns_unix,
    pub nexthop: netns_nexthop,
    pub ipv4: netns_ipv4,
    pub ipv6: netns_ipv6,
    pub ieee802154_lowpan: netns_ieee802154_lowpan,
    pub sctp: netns_sctp,
    pub nf: netns_nf,
    pub ct: netns_ct,
    pub nft: netns_nftables,
    pub ft: netns_ft,
    pub wext_nlevents: sk_buff_head,
    pub gen: *mut net_generic,
    pub bpf: netns_bpf,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub xfrm: netns_xfrm,
    pub net_cookie: u64_,
    pub ipvs: *mut netns_ipvs,
    pub mpls: netns_mpls,
    pub can: netns_can,
    pub xdp: netns_xdp,
    pub mctp: netns_mctp,
    pub crypto_nlsk: *mut sock,
    pub diag_nlsk: *mut sock,
    pub smc: netns_smc,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl net {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut notifier_block,
        arg2: ::aya_bpf::cty::c_ulong,
        arg3: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_pool_params {
    pub flags: ::aya_bpf::cty::c_uint,
    pub order: ::aya_bpf::cty::c_uint,
    pub pool_size: ::aya_bpf::cty::c_uint,
    pub nid: ::aya_bpf::cty::c_int,
    pub dev: *mut device,
    pub dma_dir: dma_data_direction::Type,
    pub max_len: ::aya_bpf::cty::c_uint,
    pub offset: ::aya_bpf::cty::c_uint,
    pub init_callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut page, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub init_arg: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pp_alloc_cache {
    pub count: u32_,
    pub cache: [*mut page; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ptr_ring {
    pub producer: ::aya_bpf::cty::c_int,
    pub producer_lock: spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub consumer_head: ::aya_bpf::cty::c_int,
    pub consumer_tail: ::aya_bpf::cty::c_int,
    pub consumer_lock: spinlock_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: u32,
    pub size: ::aya_bpf::cty::c_int,
    pub batch: ::aya_bpf::cty::c_int,
    pub queue: *mut *mut ::aya_bpf::cty::c_void,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_pool {
    pub p: page_pool_params,
    pub release_dw: delayed_work,
    pub disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub defer_start: ::aya_bpf::cty::c_ulong,
    pub defer_warn: ::aya_bpf::cty::c_ulong,
    pub pages_state_hold_cnt: u32_,
    pub frag_offset: ::aya_bpf::cty::c_uint,
    pub frag_page: *mut page,
    pub frag_users: ::aya_bpf::cty::c_long,
    pub xdp_mem_id: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub alloc: pp_alloc_cache,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub ring: ptr_ring,
    pub pages_state_release_cnt: atomic_t,
    pub user_cnt: refcount_t,
    pub destroy_cnt: u64_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 48usize]>,
}
pub type sk_buff_data_t = ::aya_bpf::cty::c_uint;
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub cb: [::aya_bpf::cty::c_char; 48usize],
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub _nfct: ::aya_bpf::cty::c_ulong,
    pub len: ::aya_bpf::cty::c_uint,
    pub data_len: ::aya_bpf::cty::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub active_extensions: __u8,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut ::aya_bpf::cty::c_uchar,
    pub data: *mut ::aya_bpf::cty::c_uchar,
    pub truesize: ::aya_bpf::cty::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    pub ll_node: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub sk: *mut sock,
    pub ip_defrag_offset: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    pub _sk_redir: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub _skb_refdst: ::aya_bpf::cty::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5 {
    pub __bindgen_anon_1: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_1>,
    pub headers: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 15usize],
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub tc_index: __u16,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: ::aya_bpf::cty::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    pub alloc_cpu: u16_,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub napi_id: ::aya_bpf::cty::c_uint,
    pub sender_cpu: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl sk_buff__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_skip_egress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_skip_egress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scm_io_uring(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scm_io_uring(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        dst_pending_confirm: __u8,
        mono_delivery_time: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        redirected: __u8,
        from_ingress: __u8,
        nf_skip_egress: __u8,
        decrypted: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
        scm_io_uring: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
            nf_skip_egress as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scm_io_uring: u8 = unsafe { ::core::mem::transmute(scm_io_uring) };
            scm_io_uring as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_2 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub tc_index: __u16,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: ::aya_bpf::cty::c_int,
    pub hash: __u32,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3,
    pub alloc_cpu: u16_,
    pub secmark: __u32,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2 {
    pub vlan_all: u32_,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3 {
    pub napi_id: ::aya_bpf::cty::c_uint,
    pub sender_cpu: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
}
impl sk_buff__bindgen_ty_5__bindgen_ty_2 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_skip_classify(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_skip_classify(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tc_at_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tc_at_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_l3_fwd_mark(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn from_ingress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_from_ingress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_skip_egress(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_skip_egress(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn decrypted(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_decrypted(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scm_io_uring(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scm_io_uring(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        remcsum_offload: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        dst_pending_confirm: __u8,
        mono_delivery_time: __u8,
        tc_skip_classify: __u8,
        tc_at_ingress: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        offload_fwd_mark: __u8,
        offload_l3_fwd_mark: __u8,
        redirected: __u8,
        from_ingress: __u8,
        nf_skip_egress: __u8,
        decrypted: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
        scm_io_uring: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
            tc_skip_classify as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
            tc_at_ingress as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
            offload_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let offload_l3_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
            offload_l3_fwd_mark as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
            from_ingress as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
            nf_skip_egress as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
            decrypted as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scm_io_uring: u8 = unsafe { ::core::mem::transmute(scm_io_uring) };
            scm_io_uring as u64
        });
        __bindgen_bitfield_unit
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp_recycle(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pp_recycle(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
        pp_recycle: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pp_recycle: u8 = unsafe { ::core::mem::transmute(pp_recycle) };
            pp_recycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipstats_mib {
    pub mibs: [u64_; 37usize],
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmp_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 28usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpmsg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6msg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 127usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_tls_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fqdir {
    pub high_thresh: ::aya_bpf::cty::c_long,
    pub low_thresh: ::aya_bpf::cty::c_long,
    pub timeout: ::aya_bpf::cty::c_int,
    pub max_dist: ::aya_bpf::cty::c_int,
    pub f: *mut inet_frags,
    pub net: *mut net,
    pub dead: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub rhashtable: rhashtable,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub mem: atomic_long_t,
    pub destroy_work: work_struct,
    pub free_list: llist_node,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl fqdir {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frags {
    pub qsize: ::aya_bpf::cty::c_uint,
    pub constructor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inet_frag_queue, arg2: *const ::aya_bpf::cty::c_void),
    >,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>,
    pub frag_expire: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub frags_cachep: *mut kmem_cache,
    pub frags_cache_name: *const ::aya_bpf::cty::c_char,
    pub rhash_params: rhashtable_params,
    pub refcnt: refcount_t,
    pub completion: completion,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frag_v4_compare_key {
    pub saddr: __be32,
    pub daddr: __be32,
    pub user: u32_,
    pub vif: u32_,
    pub id: __be16,
    pub protocol: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct frag_v6_compare_key {
    pub saddr: in6_addr,
    pub daddr: in6_addr,
    pub user: u32_,
    pub id: __be32,
    pub iif: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frag_queue {
    pub node: rhash_head,
    pub key: inet_frag_queue__bindgen_ty_1,
    pub timer: timer_list,
    pub lock: spinlock_t,
    pub refcnt: refcount_t,
    pub rb_fragments: rb_root,
    pub fragments_tail: *mut sk_buff,
    pub last_run_head: *mut sk_buff,
    pub stamp: ktime_t,
    pub len: ::aya_bpf::cty::c_int,
    pub meat: ::aya_bpf::cty::c_int,
    pub mono_delivery_time: u8_,
    pub flags: __u8,
    pub max_size: u16_,
    pub fqdir: *mut fqdir,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_frag_queue__bindgen_ty_1 {
    pub v4: frag_v4_compare_key,
    pub v6: frag_v6_compare_key,
}
pub mod tcp_ca_event {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const CA_EVENT_TX_START: Type = 0;
    pub const CA_EVENT_CWND_RESTART: Type = 1;
    pub const CA_EVENT_COMPLETE_CWR: Type = 2;
    pub const CA_EVENT_LOSS: Type = 3;
    pub const CA_EVENT_ECN_NO_CE: Type = 4;
    pub const CA_EVENT_ECN_IS_CE: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_congestion_ops {
    pub ssthresh: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub cong_avoid:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_, arg3: u32_)>,
    pub set_state: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u8_)>,
    pub cwnd_event:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: tcp_ca_event::Type)>,
    pub in_ack_event: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: u32_)>,
    pub pkts_acked:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const ack_sample)>,
    pub min_tso_segs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub cong_control:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: *const rate_sample)>,
    pub undo_cwnd: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub sndbuf_expand: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> u32_>,
    pub get_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: u32_,
            arg3: *mut ::aya_bpf::cty::c_int,
            arg4: *mut tcp_cc_info,
        ) -> usize,
    >,
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub owner: *mut module,
    pub list: list_head,
    pub key: u32_,
    pub flags: u32_,
    pub init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdevice_tracker {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_entry {
    pub dev: *mut net_device,
    pub ops: *mut dst_ops,
    pub _metrics: ::aya_bpf::cty::c_ulong,
    pub expires: ::aya_bpf::cty::c_ulong,
    pub xfrm: *mut xfrm_state,
    pub input:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf::cty::c_int>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub obsolete: ::aya_bpf::cty::c_short,
    pub header_len: ::aya_bpf::cty::c_ushort,
    pub trailer_len: ::aya_bpf::cty::c_ushort,
    pub __refcnt: atomic_t,
    pub __use: ::aya_bpf::cty::c_int,
    pub lastuse: ::aya_bpf::cty::c_ulong,
    pub lwtstate: *mut lwtunnel_state,
    pub callback_head: callback_head,
    pub error: ::aya_bpf::cty::c_short,
    pub __pad: ::aya_bpf::cty::c_short,
    pub tclassid: __u32,
    pub dev_tracker: netdevice_tracker,
}
pub mod nf_log_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NF_LOG_TYPE_LOG: Type = 0;
    pub const NF_LOG_TYPE_ULOG: Type = 1;
    pub const NF_LOG_TYPE_MAX: Type = 2;
}
pub type u_int8_t = u8_;
pub type nf_logfn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut net,
        arg2: u_int8_t,
        arg3: ::aya_bpf::cty::c_uint,
        arg4: *const sk_buff,
        arg5: *const net_device,
        arg6: *const net_device,
        arg7: *const nf_loginfo,
        arg8: *const ::aya_bpf::cty::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_logger {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub type_: nf_log_type::Type,
    pub logfn: nf_logfn,
    pub me: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: ::aya_bpf::cty::c_uint,
    pub invalid: ::aya_bpf::cty::c_uint,
    pub insert: ::aya_bpf::cty::c_uint,
    pub insert_failed: ::aya_bpf::cty::c_uint,
    pub clash_resolve: ::aya_bpf::cty::c_uint,
    pub drop: ::aya_bpf::cty::c_uint,
    pub early_drop: ::aya_bpf::cty::c_uint,
    pub error: ::aya_bpf::cty::c_uint,
    pub expect_new: ::aya_bpf::cty::c_uint,
    pub expect_create: ::aya_bpf::cty::c_uint,
    pub expect_delete: ::aya_bpf::cty::c_uint,
    pub search_restart: ::aya_bpf::cty::c_uint,
    pub chaintoolong: ::aya_bpf::cty::c_uint,
}
pub mod ip_conntrack_dir {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IP_CT_DIR_ORIGINAL: Type = 0;
    pub const IP_CT_DIR_REPLY: Type = 1;
    pub const IP_CT_DIR_MAX: Type = 2;
}
pub mod sctp_conntrack {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const SCTP_CONNTRACK_NONE: Type = 0;
    pub const SCTP_CONNTRACK_CLOSED: Type = 1;
    pub const SCTP_CONNTRACK_COOKIE_WAIT: Type = 2;
    pub const SCTP_CONNTRACK_COOKIE_ECHOED: Type = 3;
    pub const SCTP_CONNTRACK_ESTABLISHED: Type = 4;
    pub const SCTP_CONNTRACK_SHUTDOWN_SENT: Type = 5;
    pub const SCTP_CONNTRACK_SHUTDOWN_RECD: Type = 6;
    pub const SCTP_CONNTRACK_SHUTDOWN_ACK_SENT: Type = 7;
    pub const SCTP_CONNTRACK_HEARTBEAT_SENT: Type = 8;
    pub const SCTP_CONNTRACK_HEARTBEAT_ACKED: Type = 9;
    pub const SCTP_CONNTRACK_MAX: Type = 10;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_flow_table_stat {
    pub count_wq_add: ::aya_bpf::cty::c_uint,
    pub count_wq_del: ::aya_bpf::cty::c_uint,
    pub count_wq_stats: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buffer {
    pub page: *mut page,
    pub offset: ::aya_bpf::cty::c_uint,
    pub len: ::aya_bpf::cty::c_uint,
    pub ops: *const pipe_buf_operations,
    pub flags: ::aya_bpf::cty::c_uint,
    pub private: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_buf_operations {
    pub confirm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut pipe_buffer,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
    >,
    pub try_steal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 4usize],
    pub chunks: u8_,
    pub __bindgen_padding_0: [u8; 7usize],
    pub data: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
pub type irq_hw_number_t = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_bitmap {
    pub sequence: u64_,
    pub refcnt: refcount_t,
    pub max: ::aya_bpf::cty::c_uint,
    pub bitmap: [::aya_bpf::cty::c_ulong; 1024usize],
}
pub mod irq_domain_bus_token {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DOMAIN_BUS_ANY: Type = 0;
    pub const DOMAIN_BUS_WIRED: Type = 1;
    pub const DOMAIN_BUS_GENERIC_MSI: Type = 2;
    pub const DOMAIN_BUS_PCI_MSI: Type = 3;
    pub const DOMAIN_BUS_PLATFORM_MSI: Type = 4;
    pub const DOMAIN_BUS_NEXUS: Type = 5;
    pub const DOMAIN_BUS_IPI: Type = 6;
    pub const DOMAIN_BUS_FSL_MC_MSI: Type = 7;
    pub const DOMAIN_BUS_TI_SCI_INTA_MSI: Type = 8;
    pub const DOMAIN_BUS_WAKEUP: Type = 9;
    pub const DOMAIN_BUS_VMD_MSI: Type = 10;
    pub const DOMAIN_BUS_PCI_DEVICE_MSI: Type = 11;
    pub const DOMAIN_BUS_PCI_DEVICE_MSIX: Type = 12;
    pub const DOMAIN_BUS_DMAR: Type = 13;
    pub const DOMAIN_BUS_AMDVI: Type = 14;
    pub const DOMAIN_BUS_PCI_DEVICE_IMS: Type = 15;
}
#[repr(C)]
pub struct irq_domain {
    pub link: list_head,
    pub name: *const ::aya_bpf::cty::c_char,
    pub ops: *const irq_domain_ops,
    pub host_data: *mut ::aya_bpf::cty::c_void,
    pub flags: ::aya_bpf::cty::c_uint,
    pub mapcount: ::aya_bpf::cty::c_uint,
    pub fwnode: *mut fwnode_handle,
    pub bus_token: irq_domain_bus_token::Type,
    pub gc: *mut irq_domain_chip_generic,
    pub dev: *mut device,
    pub pm_dev: *mut device,
    pub parent: *mut irq_domain,
    pub msi_parent_ops: *const msi_parent_ops,
    pub hwirq_max: irq_hw_number_t,
    pub revmap_size: ::aya_bpf::cty::c_uint,
    pub revmap_tree: xarray,
    pub revmap_mutex: mutex,
    pub revmap: __IncompleteArrayField<*mut irq_data>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    pub kobj: kobject,
    pub owner: *mut module,
    pub ops: *const file_operations,
    pub list: list_head,
    pub dev: dev_t,
    pub count: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut device_attribute,
            arg3: *mut ::aya_bpf::cty::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut device_attribute,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_dev_domain {
    pub store: xarray,
    pub domain: *mut irq_domain,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_device_data {
    pub properties: ::aya_bpf::cty::c_ulong,
    pub platform_data: *mut platform_msi_priv_data,
    pub mutex: mutex,
    pub __domains: [msi_dev_domain; 2usize],
    pub __iter_idx: ::aya_bpf::cty::c_ulong,
}
pub type phandle = u32_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    pub name: *const ::aya_bpf::cty::c_char,
    pub phandle: phandle,
    pub full_name: *const ::aya_bpf::cty::c_char,
    pub fwnode: fwnode_handle,
    pub properties: *mut property,
    pub deadprops: *mut property,
    pub parent: *mut device_node,
    pub child: *mut device_node,
    pub sibling: *mut device_node,
    pub _flags: ::aya_bpf::cty::c_ulong,
    pub data: *mut ::aya_bpf::cty::c_void,
}
pub mod irqreturn {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IRQ_NONE: Type = 0;
    pub const IRQ_HANDLED: Type = 1;
    pub const IRQ_WAKE_THREAD: Type = 2;
}
pub use self::irqreturn::Type as irqreturn_t;
pub type irq_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: ::aya_bpf::cty::c_int,
        arg2: *mut ::aya_bpf::cty::c_void,
    ) -> irqreturn_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irqaction {
    pub handler: irq_handler_t,
    pub dev_id: *mut ::aya_bpf::cty::c_void,
    pub percpu_dev_id: *mut ::aya_bpf::cty::c_void,
    pub next: *mut irqaction,
    pub thread_fn: irq_handler_t,
    pub thread: *mut task_struct,
    pub secondary: *mut irqaction,
    pub irq: ::aya_bpf::cty::c_uint,
    pub flags: ::aya_bpf::cty::c_uint,
    pub thread_flags: ::aya_bpf::cty::c_ulong,
    pub thread_mask: ::aya_bpf::cty::c_ulong,
    pub name: *const ::aya_bpf::cty::c_char,
    pub dir: *mut proc_dir_entry,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl irqaction {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_affinity_notify {
    pub irq: ::aya_bpf::cty::c_uint,
    pub kref: kref,
    pub work: work_struct,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_affinity_notify, arg2: *const cpumask_t),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut kref)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_affinity_desc {
    pub mask: cpumask,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl irq_affinity_desc {
    #[inline]
    pub fn is_managed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_managed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_managed: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_managed: u32 = unsafe { ::core::mem::transmute(is_managed) };
            is_managed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod irqchip_irq_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IRQCHIP_STATE_PENDING: Type = 0;
    pub const IRQCHIP_STATE_ACTIVE: Type = 1;
    pub const IRQCHIP_STATE_MASKED: Type = 2;
    pub const IRQCHIP_STATE_LINE_LEVEL: Type = 3;
}
pub type irq_flow_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_desc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_common_data {
    pub state_use_accessors: ::aya_bpf::cty::c_uint,
    pub node: ::aya_bpf::cty::c_uint,
    pub handler_data: *mut ::aya_bpf::cty::c_void,
    pub msi_desc: *mut msi_desc,
    pub affinity: cpumask_var_t,
    pub effective_affinity: cpumask_var_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_data {
    pub mask: u32_,
    pub irq: ::aya_bpf::cty::c_uint,
    pub hwirq: ::aya_bpf::cty::c_ulong,
    pub common: *mut irq_common_data,
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub parent_data: *mut irq_data,
    pub chip_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_desc {
    pub irq_common_data: irq_common_data,
    pub irq_data: irq_data,
    pub kstat_irqs: *mut ::aya_bpf::cty::c_uint,
    pub handle_irq: irq_flow_handler_t,
    pub action: *mut irqaction,
    pub status_use_accessors: ::aya_bpf::cty::c_uint,
    pub core_internal_state__do_not_mess_with_it: ::aya_bpf::cty::c_uint,
    pub depth: ::aya_bpf::cty::c_uint,
    pub wake_depth: ::aya_bpf::cty::c_uint,
    pub tot_count: ::aya_bpf::cty::c_uint,
    pub irq_count: ::aya_bpf::cty::c_uint,
    pub last_unhandled: ::aya_bpf::cty::c_ulong,
    pub irqs_unhandled: ::aya_bpf::cty::c_uint,
    pub threads_handled: atomic_t,
    pub threads_handled_last: ::aya_bpf::cty::c_int,
    pub lock: raw_spinlock_t,
    pub percpu_enabled: *mut cpumask,
    pub percpu_affinity: *const cpumask,
    pub affinity_hint: *const cpumask,
    pub affinity_notify: *mut irq_affinity_notify,
    pub pending_mask: cpumask_var_t,
    pub threads_oneshot: ::aya_bpf::cty::c_ulong,
    pub threads_active: atomic_t,
    pub wait_for_threads: wait_queue_head_t,
    pub nr_actions: ::aya_bpf::cty::c_uint,
    pub no_suspend_depth: ::aya_bpf::cty::c_uint,
    pub cond_suspend_depth: ::aya_bpf::cty::c_uint,
    pub force_resume_depth: ::aya_bpf::cty::c_uint,
    pub dir: *mut proc_dir_entry,
    pub debugfs_file: *mut dentry,
    pub dev_name: *const ::aya_bpf::cty::c_char,
    pub rcu: callback_head,
    pub kobj: kobject,
    pub request_mutex: mutex,
    pub parent_irq: ::aya_bpf::cty::c_int,
    pub owner: *mut module,
    pub name: *const ::aya_bpf::cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl irq_desc {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_msi_addr_lo {
    pub __bindgen_anon_1: x86_msi_addr_lo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x86_msi_addr_lo__bindgen_ty_1 {
    pub __bindgen_anon_1: x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved_0(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_0(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode_logical(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_mode_logical(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect_hint(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect_hint(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved_1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved_1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virt_destid_8_14(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_virt_destid_8_14(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn destid_0_7(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_destid_0_7(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn base_address(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_base_address(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved_0: u32_,
        dest_mode_logical: u32_,
        redirect_hint: u32_,
        reserved_1: u32_,
        virt_destid_8_14: u32_,
        destid_0_7: u32_,
        base_address: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved_0: u32 = unsafe { ::core::mem::transmute(reserved_0) };
            reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dest_mode_logical: u32 = unsafe { ::core::mem::transmute(dest_mode_logical) };
            dest_mode_logical as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let redirect_hint: u32 = unsafe { ::core::mem::transmute(redirect_hint) };
            redirect_hint as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved_1: u32 = unsafe { ::core::mem::transmute(reserved_1) };
            reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let virt_destid_8_14: u32 = unsafe { ::core::mem::transmute(virt_destid_8_14) };
            virt_destid_8_14 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let destid_0_7: u32 = unsafe { ::core::mem::transmute(destid_0_7) };
            destid_0_7 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let base_address: u32 = unsafe { ::core::mem::transmute(base_address) };
            base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_lo__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn dmar_reserved_0(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_reserved_0(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_index_15(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_index_15(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_subhandle_valid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_subhandle_valid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_format(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_format(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_index_0_14(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_index_0_14(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn dmar_base_address(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_dmar_base_address(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dmar_reserved_0: u32_,
        dmar_index_15: u32_,
        dmar_subhandle_valid: u32_,
        dmar_format: u32_,
        dmar_index_0_14: u32_,
        dmar_base_address: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dmar_reserved_0: u32 = unsafe { ::core::mem::transmute(dmar_reserved_0) };
            dmar_reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dmar_index_15: u32 = unsafe { ::core::mem::transmute(dmar_index_15) };
            dmar_index_15 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dmar_subhandle_valid: u32 = unsafe { ::core::mem::transmute(dmar_subhandle_valid) };
            dmar_subhandle_valid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dmar_format: u32 = unsafe { ::core::mem::transmute(dmar_format) };
            dmar_format as u64
        });
        __bindgen_bitfield_unit.set(5usize, 15u8, {
            let dmar_index_0_14: u32 = unsafe { ::core::mem::transmute(dmar_index_0_14) };
            dmar_index_0_14 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let dmar_base_address: u32 = unsafe { ::core::mem::transmute(dmar_base_address) };
            dmar_base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_addr_lo_t = x86_msi_addr_lo;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_addr_hi {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl x86_msi_addr_hi {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn destid_8_31(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_destid_8_31(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        destid_8_31: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let destid_8_31: u32 = unsafe { ::core::mem::transmute(destid_8_31) };
            destid_8_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_addr_hi_t = x86_msi_addr_hi;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_msi_data {
    pub __bindgen_anon_1: x86_msi_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x86_msi_data__bindgen_ty_1 {
    pub __bindgen_anon_1: x86_msi_data__bindgen_ty_1__bindgen_ty_1,
    pub dmar_subhandle: u32_,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_data__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl x86_msi_data__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn vector(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode_logical(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dest_mode_logical(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn active_low(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_level(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_level(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: u32_,
        delivery_mode: u32_,
        dest_mode_logical: u32_,
        reserved: u32_,
        active_low: u32_,
        is_level: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::core::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::core::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dest_mode_logical: u32 = unsafe { ::core::mem::transmute(dest_mode_logical) };
            dest_mode_logical as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is_level: u32 = unsafe { ::core::mem::transmute(is_level) };
            is_level as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type arch_msi_msg_data_t = x86_msi_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_msg {
    pub __bindgen_anon_1: msi_msg__bindgen_ty_1,
    pub __bindgen_anon_2: msi_msg__bindgen_ty_2,
    pub __bindgen_anon_3: msi_msg__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_1 {
    pub address_lo: u32_,
    pub arch_addr_lo: arch_msi_msg_addr_lo_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_2 {
    pub address_hi: u32_,
    pub arch_addr_hi: arch_msi_msg_addr_hi_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_msg__bindgen_ty_3 {
    pub data: u32_,
    pub arch_data: arch_msi_msg_data_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_msi_desc {
    pub __bindgen_anon_1: pci_msi_desc__bindgen_ty_1,
    pub msi_attrib: pci_msi_desc__bindgen_ty_2,
    pub __bindgen_anon_2: pci_msi_desc__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pci_msi_desc__bindgen_ty_1 {
    pub msi_mask: u32_,
    pub msix_ctrl: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_msi_desc__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub default_irq: ::aya_bpf::cty::c_uint,
}
impl pci_msi_desc__bindgen_ty_2 {
    #[inline]
    pub fn is_msix(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_msix(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multiple(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_cap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_multi_cap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn can_mask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_mask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_64(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_64(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_virtual(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_virtual(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_msix: u8_,
        multiple: u8_,
        multi_cap: u8_,
        can_mask: u8_,
        is_64: u8_,
        is_virtual: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_msix: u8 = unsafe { ::core::mem::transmute(is_msix) };
            is_msix as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let multiple: u8 = unsafe { ::core::mem::transmute(multiple) };
            multiple as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let multi_cap: u8 = unsafe { ::core::mem::transmute(multi_cap) };
            multi_cap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let can_mask: u8 = unsafe { ::core::mem::transmute(can_mask) };
            can_mask as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_64: u8 = unsafe { ::core::mem::transmute(is_64) };
            is_64 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_virtual: u8 = unsafe { ::core::mem::transmute(is_virtual) };
            is_virtual as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pci_msi_desc__bindgen_ty_3 {
    pub mask_pos: u8_,
    pub mask_base: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_domain_cookie {
    pub value: u64_,
    pub ptr: *mut ::aya_bpf::cty::c_void,
    pub iobase: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_instance_cookie {
    pub value: u64_,
    pub ptr: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc_data {
    pub dcookie: msi_domain_cookie,
    pub icookie: msi_instance_cookie,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc {
    pub irq: ::aya_bpf::cty::c_uint,
    pub nvec_used: ::aya_bpf::cty::c_uint,
    pub dev: *mut device,
    pub msg: msi_msg,
    pub affinity: *mut irq_affinity_desc,
    pub iommu_cookie: *const ::aya_bpf::cty::c_void,
    pub sysfs_attrs: *mut device_attribute,
    pub write_msi_msg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut msi_desc, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub write_msi_msg_data: *mut ::aya_bpf::cty::c_void,
    pub msi_index: u16_,
    pub __bindgen_anon_1: msi_desc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_desc__bindgen_ty_1 {
    pub pci: pci_msi_desc,
    pub data: msi_desc_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip {
    pub name: *const ::aya_bpf::cty::c_char,
    pub irq_startup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf::cty::c_uint>,
    pub irq_shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_ack: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_mask_ack: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_eoi: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_set_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: *const cpumask,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub irq_retrigger:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf::cty::c_int>,
    pub irq_set_type: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub irq_set_wake: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub irq_bus_lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_bus_sync_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_suspend: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_resume: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_pm_shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_calc_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_print_chip:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut seq_file)>,
    pub irq_request_resources:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf::cty::c_int>,
    pub irq_release_resources: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_compose_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>,
    pub irq_write_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *mut msi_msg)>,
    pub irq_get_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: irqchip_irq_state::Type,
            arg3: *mut bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub irq_set_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: irqchip_irq_state::Type,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub irq_set_vcpu_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_data,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ipi_send_single: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_data, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub ipi_send_mask:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data, arg2: *const cpumask)>,
    pub irq_nmi_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data) -> ::aya_bpf::cty::c_int>,
    pub irq_nmi_teardown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub flags: ::aya_bpf::cty::c_ulong,
}
pub mod irq_alloc_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const X86_IRQ_ALLOC_TYPE_IOAPIC: Type = 1;
    pub const X86_IRQ_ALLOC_TYPE_HPET: Type = 2;
    pub const X86_IRQ_ALLOC_TYPE_PCI_MSI: Type = 3;
    pub const X86_IRQ_ALLOC_TYPE_PCI_MSIX: Type = 4;
    pub const X86_IRQ_ALLOC_TYPE_DMAR: Type = 5;
    pub const X86_IRQ_ALLOC_TYPE_AMDVI: Type = 6;
    pub const X86_IRQ_ALLOC_TYPE_UV: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioapic_alloc_info {
    pub pin: ::aya_bpf::cty::c_int,
    pub node: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ioapic_alloc_info {
    #[inline]
    pub fn is_level(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_level(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active_low(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active_low(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_level: u32_,
        active_low: u32_,
        valid: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_level: u32 = unsafe { ::core::mem::transmute(is_level) };
            is_level as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let active_low: u32 = unsafe { ::core::mem::transmute(active_low) };
            active_low as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_alloc_info {
    pub limit: ::aya_bpf::cty::c_int,
    pub blade: ::aya_bpf::cty::c_int,
    pub offset: ::aya_bpf::cty::c_ulong,
    pub name: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_alloc_info {
    pub type_: irq_alloc_type::Type,
    pub flags: u32_,
    pub devid: u32_,
    pub hwirq: irq_hw_number_t,
    pub mask: *const cpumask,
    pub desc: *mut msi_desc,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: irq_alloc_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union irq_alloc_info__bindgen_ty_1 {
    pub ioapic: ioapic_alloc_info,
    pub uv: uv_alloc_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip_regs {
    pub enable: ::aya_bpf::cty::c_ulong,
    pub disable: ::aya_bpf::cty::c_ulong,
    pub mask: ::aya_bpf::cty::c_ulong,
    pub ack: ::aya_bpf::cty::c_ulong,
    pub eoi: ::aya_bpf::cty::c_ulong,
    pub type_: ::aya_bpf::cty::c_ulong,
    pub polarity: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_chip_type {
    pub chip: irq_chip,
    pub regs: irq_chip_regs,
    pub handler: irq_flow_handler_t,
    pub type_: u32_,
    pub mask_cache_priv: u32_,
    pub mask_cache: *mut u32_,
}
#[repr(C)]
pub struct irq_chip_generic {
    pub lock: raw_spinlock_t,
    pub reg_base: *mut ::aya_bpf::cty::c_void,
    pub reg_readl:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> u32_>,
    pub reg_writel:
        ::core::option::Option<unsafe extern "C" fn(arg1: u32_, arg2: *mut ::aya_bpf::cty::c_void)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_chip_generic)>,
    pub irq_base: ::aya_bpf::cty::c_uint,
    pub irq_cnt: ::aya_bpf::cty::c_uint,
    pub mask_cache: u32_,
    pub type_cache: u32_,
    pub polarity_cache: u32_,
    pub wake_enabled: u32_,
    pub wake_active: u32_,
    pub num_ct: ::aya_bpf::cty::c_uint,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub installed: ::aya_bpf::cty::c_ulong,
    pub unused: ::aya_bpf::cty::c_ulong,
    pub domain: *mut irq_domain,
    pub list: list_head,
    pub chip_types: __IncompleteArrayField<irq_chip_type>,
}
pub mod irq_gc_flags {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IRQ_GC_INIT_MASK_CACHE: Type = 1;
    pub const IRQ_GC_INIT_NESTED_LOCK: Type = 2;
    pub const IRQ_GC_MASK_CACHE_PER_TYPE: Type = 4;
    pub const IRQ_GC_NO_MASK: Type = 8;
    pub const IRQ_GC_BE_IO: Type = 16;
}
#[repr(C)]
#[derive(Debug)]
pub struct irq_domain_chip_generic {
    pub irqs_per_chip: ::aya_bpf::cty::c_uint,
    pub num_chips: ::aya_bpf::cty::c_uint,
    pub irq_flags_to_clear: ::aya_bpf::cty::c_uint,
    pub irq_flags_to_set: ::aya_bpf::cty::c_uint,
    pub gc_flags: irq_gc_flags::Type,
    pub gc: __IncompleteArrayField<*mut irq_chip_generic>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct property {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub length: ::aya_bpf::cty::c_int,
    pub value: *mut ::aya_bpf::cty::c_void,
    pub next: *mut property,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_fwspec {
    pub fwnode: *mut fwnode_handle,
    pub param_count: ::aya_bpf::cty::c_int,
    pub param: [u32_; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_domain_ops {
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device_node,
            arg3: irq_domain_bus_token::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub select: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_fwspec,
            arg3: irq_domain_bus_token::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: irq_hw_number_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_domain, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub xlate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device_node,
            arg3: *const u32_,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: *mut ::aya_bpf::cty::c_ulong,
            arg6: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_data,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub deactivate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_domain, arg2: *mut irq_data)>,
    pub translate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut irq_fwspec,
            arg3: *mut ::aya_bpf::cty::c_ulong,
            arg4: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub debug_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut irq_domain,
            arg3: *mut irq_data,
            arg4: ::aya_bpf::cty::c_int,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msi_parent_ops {
    pub supported_flags: u32_,
    pub prefix: *const ::aya_bpf::cty::c_char,
    pub init_dev_msi_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut device,
            arg2: *mut irq_domain,
            arg3: *mut irq_domain,
            arg4: *mut msi_domain_info,
        ) -> bool_,
    >,
}
pub type msi_alloc_info_t = irq_alloc_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msi_domain_ops {
    pub get_hwirq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut msi_domain_info,
            arg2: *mut msi_alloc_info_t,
        ) -> irq_hw_number_t,
    >,
    pub msi_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut msi_domain_info,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: irq_hw_number_t,
            arg5: *mut msi_alloc_info_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub msi_free: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut msi_domain_info,
            arg3: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub msi_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut msi_alloc_info_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub prepare_desc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut msi_alloc_info_t,
            arg3: *mut msi_desc,
        ),
    >,
    pub set_desc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut msi_alloc_info_t, arg2: *mut msi_desc),
    >,
    pub domain_alloc_irqs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut irq_domain,
            arg2: *mut device,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub domain_free_irqs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_domain, arg2: *mut device)>,
    pub msi_post_free:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_domain, arg2: *mut device)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msi_domain_info {
    pub flags: u32_,
    pub bus_token: irq_domain_bus_token::Type,
    pub hwsize: ::aya_bpf::cty::c_uint,
    pub ops: *mut msi_domain_ops,
    pub chip: *mut irq_chip,
    pub chip_data: *mut ::aya_bpf::cty::c_void,
    pub handler: irq_flow_handler_t,
    pub handler_data: *mut ::aya_bpf::cty::c_void,
    pub handler_name: *const ::aya_bpf::cty::c_char,
    pub data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut wait_queue_entry,
        arg2: ::aya_bpf::cty::c_uint,
        arg3: ::aya_bpf::cty::c_int,
        arg4: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: ::aya_bpf::cty::c_uint,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
pub type wait_queue_entry_t = wait_queue_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_id {
    pub id: ::aya_bpf::cty::c_int,
    pub ref_: refcount_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct page_counter {
    pub usage: atomic_long_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub _pad1_: cacheline_padding,
    pub emin: ::aya_bpf::cty::c_ulong,
    pub min_usage: atomic_long_t,
    pub children_min_usage: atomic_long_t,
    pub elow: ::aya_bpf::cty::c_ulong,
    pub low_usage: atomic_long_t,
    pub children_low_usage: atomic_long_t,
    pub watermark: ::aya_bpf::cty::c_ulong,
    pub failcnt: ::aya_bpf::cty::c_ulong,
    pub _pad2_: cacheline_padding,
    pub min: ::aya_bpf::cty::c_ulong,
    pub low: ::aya_bpf::cty::c_ulong,
    pub high: ::aya_bpf::cty::c_ulong,
    pub max: ::aya_bpf::cty::c_ulong,
    pub parent: *mut page_counter,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl page_counter {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmpressure {
    pub scanned: ::aya_bpf::cty::c_ulong,
    pub reclaimed: ::aya_bpf::cty::c_ulong,
    pub tree_scanned: ::aya_bpf::cty::c_ulong,
    pub tree_reclaimed: ::aya_bpf::cty::c_ulong,
    pub sr_lock: spinlock_t,
    pub events: list_head,
    pub events_lock: mutex,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_thresholds {
    pub primary: *mut mem_cgroup_threshold_ary,
    pub spare: *mut mem_cgroup_threshold_ary,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_global {
    pub events: percpu_counter,
    pub period: ::aya_bpf::cty::c_uint,
    pub sequence: seqcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_domain {
    pub lock: spinlock_t,
    pub completions: fprop_global,
    pub period_timer: timer_list,
    pub period_time: ::aya_bpf::cty::c_ulong,
    pub dirty_limit_tstamp: ::aya_bpf::cty::c_ulong,
    pub dirty_limit: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wb_completion {
    pub cnt: atomic_t,
    pub waitq: *mut wait_queue_head_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memcg_cgwb_frn {
    pub bdi_id: u64_,
    pub memcg_id: ::aya_bpf::cty::c_int,
    pub at: u64_,
    pub done: wb_completion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct deferred_split {
    pub split_queue_lock: spinlock_t,
    pub split_queue: list_head,
    pub split_queue_len: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_mm_list {
    pub fifo: list_head,
    pub lock: spinlock_t,
}
#[repr(C)]
pub struct mem_cgroup {
    pub css: cgroup_subsys_state,
    pub id: mem_cgroup_id,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub memory: page_counter,
    pub __bindgen_anon_1: mem_cgroup__bindgen_ty_1,
    pub kmem: page_counter,
    pub tcpmem: page_counter,
    pub high_work: work_struct,
    pub zswap_max: ::aya_bpf::cty::c_ulong,
    pub soft_limit: ::aya_bpf::cty::c_ulong,
    pub vmpressure: vmpressure,
    pub oom_group: bool_,
    pub oom_lock: bool_,
    pub under_oom: ::aya_bpf::cty::c_int,
    pub swappiness: ::aya_bpf::cty::c_int,
    pub oom_kill_disable: ::aya_bpf::cty::c_int,
    pub events_file: cgroup_file,
    pub events_local_file: cgroup_file,
    pub swap_events_file: cgroup_file,
    pub thresholds_lock: mutex,
    pub thresholds: mem_cgroup_thresholds,
    pub memsw_thresholds: mem_cgroup_thresholds,
    pub oom_notify: list_head,
    pub move_charge_at_immigrate: ::aya_bpf::cty::c_ulong,
    pub move_lock: spinlock_t,
    pub move_lock_flags: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub _pad1_: cacheline_padding,
    pub vmstats: *mut memcg_vmstats,
    pub memory_events: [atomic_long_t; 9usize],
    pub memory_events_local: [atomic_long_t; 9usize],
    pub socket_pressure: ::aya_bpf::cty::c_ulong,
    pub tcpmem_active: bool_,
    pub tcpmem_pressure: ::aya_bpf::cty::c_int,
    pub kmemcg_id: ::aya_bpf::cty::c_int,
    pub objcg: *mut obj_cgroup,
    pub objcg_list: list_head,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub _pad2_: cacheline_padding,
    pub moving_account: atomic_t,
    pub move_lock_task: *mut task_struct,
    pub vmstats_percpu: *mut memcg_vmstats_percpu,
    pub cgwb_list: list_head,
    pub cgwb_domain: wb_domain,
    pub cgwb_frn: [memcg_cgwb_frn; 4usize],
    pub event_list: list_head,
    pub event_list_lock: spinlock_t,
    pub deferred_split_queue: deferred_split,
    pub mm_list: lru_gen_mm_list,
    pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
pub struct mem_cgroup__bindgen_ty_1 {
    pub swap: __BindgenUnionField<page_counter>,
    pub memsw: __BindgenUnionField<page_counter>,
    pub bindgen_union_field: [u64; 24usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const ::aya_bpf::cty::c_char,
    pub pages: *mut *mut page,
    pub fault: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const vm_special_mapping,
            arg2: *mut vm_area_struct,
            arg3: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const vm_special_mapping,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 6usize],
    pub nr_free: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lru_gen_struct {
    pub max_seq: ::aya_bpf::cty::c_ulong,
    pub min_seq: [::aya_bpf::cty::c_ulong; 2usize],
    pub timestamps: [::aya_bpf::cty::c_ulong; 4usize],
    pub lists: [list_head; 40usize],
    pub nr_pages: [::aya_bpf::cty::c_long; 40usize],
    pub avg_refaulted: [::aya_bpf::cty::c_ulong; 8usize],
    pub avg_total: [::aya_bpf::cty::c_ulong; 8usize],
    pub protected: [::aya_bpf::cty::c_ulong; 6usize],
    pub evicted: [atomic_long_t; 8usize],
    pub refaulted: [atomic_long_t; 8usize],
    pub enabled: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lru_gen_mm_state {
    pub seq: ::aya_bpf::cty::c_ulong,
    pub head: *mut list_head,
    pub tail: *mut list_head,
    pub wait: wait_queue_head,
    pub filters: [*mut ::aya_bpf::cty::c_ulong; 2usize],
    pub stats: [::aya_bpf::cty::c_ulong; 6usize],
    pub nr_walkers: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lru_gen_mm_walk {
    pub lruvec: *mut lruvec,
    pub max_seq: ::aya_bpf::cty::c_ulong,
    pub next_addr: ::aya_bpf::cty::c_ulong,
    pub nr_pages: [::aya_bpf::cty::c_int; 40usize],
    pub mm_stats: [::aya_bpf::cty::c_int; 6usize],
    pub batched: ::aya_bpf::cty::c_int,
    pub can_swap: bool_,
    pub force_scan: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: ::aya_bpf::cty::c_ulong,
    pub file_cost: ::aya_bpf::cty::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [::aya_bpf::cty::c_ulong; 2usize],
    pub flags: ::aya_bpf::cty::c_ulong,
    pub lrugen: lru_gen_struct,
    pub mm_state: lru_gen_mm_state,
    pub pgdat: *mut pglist_data,
}
#[repr(C)]
pub struct zone {
    pub _watermark: [::aya_bpf::cty::c_ulong; 4usize],
    pub watermark_boost: ::aya_bpf::cty::c_ulong,
    pub nr_reserved_highatomic: ::aya_bpf::cty::c_ulong,
    pub lowmem_reserve: [::aya_bpf::cty::c_long; 5usize],
    pub node: ::aya_bpf::cty::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub per_cpu_pageset: *mut per_cpu_pages,
    pub per_cpu_zonestats: *mut per_cpu_zonestat,
    pub pageset_high: ::aya_bpf::cty::c_int,
    pub pageset_batch: ::aya_bpf::cty::c_int,
    pub zone_start_pfn: ::aya_bpf::cty::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: ::aya_bpf::cty::c_ulong,
    pub present_pages: ::aya_bpf::cty::c_ulong,
    pub present_early_pages: ::aya_bpf::cty::c_ulong,
    pub cma_pages: ::aya_bpf::cty::c_ulong,
    pub name: *const ::aya_bpf::cty::c_char,
    pub nr_isolate_pageblock: ::aya_bpf::cty::c_ulong,
    pub span_seqlock: seqlock_t,
    pub initialized: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: [u8; 4usize],
    pub _pad1_: cacheline_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ::aya_bpf::cty::c_ulong,
    pub lock: spinlock_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_1: [u8; 4usize],
    pub _pad2_: cacheline_padding,
    pub percpu_drift_mark: ::aya_bpf::cty::c_ulong,
    pub compact_cached_free_pfn: ::aya_bpf::cty::c_ulong,
    pub compact_cached_migrate_pfn: [::aya_bpf::cty::c_ulong; 2usize],
    pub compact_init_migrate_pfn: ::aya_bpf::cty::c_ulong,
    pub compact_init_free_pfn: ::aya_bpf::cty::c_ulong,
    pub compact_considered: ::aya_bpf::cty::c_uint,
    pub compact_defer_shift: ::aya_bpf::cty::c_uint,
    pub compact_order_failed: ::aya_bpf::cty::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u8; 2usize],
    pub _pad3_: cacheline_padding,
    pub vm_stat: [atomic_long_t; 11usize],
    pub vm_numa_event: [atomic_long_t; 6usize],
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 5121usize],
}
pub mod zone_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ZONE_DMA: Type = 0;
    pub const ZONE_DMA32: Type = 1;
    pub const ZONE_NORMAL: Type = 2;
    pub const ZONE_MOVABLE: Type = 3;
    pub const ZONE_DEVICE: Type = 4;
    pub const __MAX_NR_ZONES: Type = 5;
}
#[repr(C)]
pub struct pglist_data {
    pub node_zones: [zone; 5usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: ::aya_bpf::cty::c_int,
    pub node_size_lock: spinlock_t,
    pub node_start_pfn: ::aya_bpf::cty::c_ulong,
    pub node_present_pages: ::aya_bpf::cty::c_ulong,
    pub node_spanned_pages: ::aya_bpf::cty::c_ulong,
    pub node_id: ::aya_bpf::cty::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub reclaim_wait: [wait_queue_head_t; 4usize],
    pub nr_writeback_throttled: atomic_t,
    pub nr_reclaim_start: ::aya_bpf::cty::c_ulong,
    pub kswapd_lock: mutex,
    pub kswapd: *mut task_struct,
    pub kswapd_order: ::aya_bpf::cty::c_int,
    pub kswapd_highest_zoneidx: zone_type::Type,
    pub kswapd_failures: ::aya_bpf::cty::c_int,
    pub kcompactd_max_order: ::aya_bpf::cty::c_int,
    pub kcompactd_highest_zoneidx: zone_type::Type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub proactive_compact_trigger: bool_,
    pub totalreserve_pages: ::aya_bpf::cty::c_ulong,
    pub min_unmapped_pages: ::aya_bpf::cty::c_ulong,
    pub min_slab_pages: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub _pad1_: cacheline_padding,
    pub first_deferred_pfn: ::aya_bpf::cty::c_ulong,
    pub deferred_split_queue: deferred_split,
    pub nbp_rl_start: ::aya_bpf::cty::c_uint,
    pub nbp_rl_nr_cand: ::aya_bpf::cty::c_ulong,
    pub nbp_threshold: ::aya_bpf::cty::c_uint,
    pub nbp_th_start: ::aya_bpf::cty::c_uint,
    pub nbp_th_nr_cand: ::aya_bpf::cty::c_ulong,
    pub __lruvec: lruvec,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub mm_walk: lru_gen_mm_walk,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub _pad2_: cacheline_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 43usize],
    pub memtier: *mut memory_tier,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl pglist_data {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub lock: spinlock_t,
    pub count: ::aya_bpf::cty::c_int,
    pub high: ::aya_bpf::cty::c_int,
    pub batch: ::aya_bpf::cty::c_int,
    pub free_factor: ::aya_bpf::cty::c_short,
    pub expire: ::aya_bpf::cty::c_short,
    pub lists: [list_head; 13usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl per_cpu_pages {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_zonestat {
    pub vm_stat_diff: [s8; 11usize],
    pub stat_threshold: s8,
    pub vm_numa_event: [::aya_bpf::cty::c_ulong; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 43usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    pub head: *mut bio,
    pub tail: *mut bio,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    pub reclaimed_slab: ::aya_bpf::cty::c_ulong,
    pub mm_walk: *mut lru_gen_mm_walk,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: ::aya_bpf::cty::c_uint,
    pub lock: raw_spinlock_t,
}
pub mod wb_reason {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const WB_REASON_BACKGROUND: Type = 0;
    pub const WB_REASON_VMSCAN: Type = 1;
    pub const WB_REASON_SYNC: Type = 2;
    pub const WB_REASON_PERIODIC: Type = 3;
    pub const WB_REASON_LAPTOP_TIMER: Type = 4;
    pub const WB_REASON_FS_FREE_SPACE: Type = 5;
    pub const WB_REASON_FORKER_THREAD: Type = 6;
    pub const WB_REASON_FOREIGN_FLUSH: Type = 7;
    pub const WB_REASON_MAX: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: ::aya_bpf::cty::c_ulong,
    pub last_old_flush: ::aya_bpf::cty::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub writeback_inodes: atomic_t,
    pub stat: [percpu_counter; 4usize],
    pub bw_time_stamp: ::aya_bpf::cty::c_ulong,
    pub dirtied_stamp: ::aya_bpf::cty::c_ulong,
    pub written_stamp: ::aya_bpf::cty::c_ulong,
    pub write_bandwidth: ::aya_bpf::cty::c_ulong,
    pub avg_write_bandwidth: ::aya_bpf::cty::c_ulong,
    pub dirty_ratelimit: ::aya_bpf::cty::c_ulong,
    pub balanced_dirty_ratelimit: ::aya_bpf::cty::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: ::aya_bpf::cty::c_int,
    pub start_all_reason: wb_reason::Type,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub bw_dwork: delayed_work,
    pub dirty_sleep: ::aya_bpf::cty::c_ulong,
    pub bdi_node: list_head,
    pub refcnt: percpu_ref,
    pub memcg_completions: fprop_local_percpu,
    pub memcg_css: *mut cgroup_subsys_state,
    pub blkcg_css: *mut cgroup_subsys_state,
    pub memcg_node: list_head,
    pub blkcg_node: list_head,
    pub b_attached: list_head,
    pub offline_node: list_head,
    pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bdi_writeback__bindgen_ty_1 {
    pub release_work: work_struct,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: ::aya_bpf::cty::c_ulong,
    pub io_pages: ::aya_bpf::cty::c_ulong,
    pub refcnt: kref,
    pub capabilities: ::aya_bpf::cty::c_uint,
    pub min_ratio: ::aya_bpf::cty::c_uint,
    pub max_ratio: ::aya_bpf::cty::c_uint,
    pub max_prop_frac: ::aya_bpf::cty::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub cgwb_tree: xarray,
    pub cgwb_release_mutex: mutex,
    pub wb_switch_rwsem: rw_semaphore,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [::aya_bpf::cty::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_page_queue {
    pub folio: *mut folio,
    pub bit_nr: ::aya_bpf::cty::c_int,
    pub wait: wait_queue_entry_t,
}
pub mod writeback_sync_modes {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const WB_SYNC_NONE: Type = 0;
    pub const WB_SYNC_ALL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: ::aya_bpf::cty::c_long,
    pub pages_skipped: ::aya_bpf::cty::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes::Type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub swap_plug: *mut *mut swap_iocb,
    pub wb: *mut bdi_writeback,
    pub inode: *mut inode,
    pub wb_id: ::aya_bpf::cty::c_int,
    pub wb_lcand_id: ::aya_bpf::cty::c_int,
    pub wb_tcand_id: ::aya_bpf::cty::c_int,
    pub wb_bytes: usize,
    pub wb_lcand_bytes: usize,
    pub wb_tcand_bytes: usize,
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_background(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_reclaim(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_reclaim(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_sync(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unpinned_fscache_wb(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unpinned_fscache_wb(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn punt_to_cgroup(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_punt_to_cgroup(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: ::aya_bpf::cty::c_uint,
        for_background: ::aya_bpf::cty::c_uint,
        tagged_writepages: ::aya_bpf::cty::c_uint,
        for_reclaim: ::aya_bpf::cty::c_uint,
        range_cyclic: ::aya_bpf::cty::c_uint,
        for_sync: ::aya_bpf::cty::c_uint,
        unpinned_fscache_wb: ::aya_bpf::cty::c_uint,
        no_cgroup_owner: ::aya_bpf::cty::c_uint,
        punt_to_cgroup: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let for_reclaim: u32 = unsafe { ::core::mem::transmute(for_reclaim) };
            for_reclaim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let unpinned_fscache_wb: u32 = unsafe { ::core::mem::transmute(unpinned_fscache_wb) };
            unpinned_fscache_wb as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let punt_to_cgroup: u32 = unsafe { ::core::mem::transmute(punt_to_cgroup) };
            punt_to_cgroup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct readahead_control {
    pub file: *mut file,
    pub mapping: *mut address_space,
    pub ra: *mut file_ra_state,
    pub _index: ::aya_bpf::cty::c_ulong,
    pub _nr_pages: ::aya_bpf::cty::c_uint,
    pub _batch_count: ::aya_bpf::cty::c_uint,
    pub _workingset: bool_,
    pub _pflags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_cluster_info {
    pub lock: spinlock_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl swap_cluster_info {
    #[inline]
    pub fn data(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: ::aya_bpf::cty::c_uint,
        flags: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_cluster_list {
    pub head: swap_cluster_info,
    pub tail: swap_cluster_info,
}
#[repr(C)]
pub struct swap_info_struct {
    pub users: percpu_ref,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub prio: ::aya_bpf::cty::c_short,
    pub list: plist_node,
    pub type_: ::aya_bpf::cty::c_schar,
    pub max: ::aya_bpf::cty::c_uint,
    pub swap_map: *mut ::aya_bpf::cty::c_uchar,
    pub cluster_info: *mut swap_cluster_info,
    pub free_clusters: swap_cluster_list,
    pub lowest_bit: ::aya_bpf::cty::c_uint,
    pub highest_bit: ::aya_bpf::cty::c_uint,
    pub pages: ::aya_bpf::cty::c_uint,
    pub inuse_pages: ::aya_bpf::cty::c_uint,
    pub cluster_next: ::aya_bpf::cty::c_uint,
    pub cluster_nr: ::aya_bpf::cty::c_uint,
    pub cluster_next_cpu: *mut ::aya_bpf::cty::c_uint,
    pub percpu_cluster: *mut percpu_cluster,
    pub swap_extent_root: rb_root,
    pub bdev: *mut block_device,
    pub swap_file: *mut file,
    pub old_block_size: ::aya_bpf::cty::c_uint,
    pub comp: completion,
    pub frontswap_map: *mut ::aya_bpf::cty::c_ulong,
    pub frontswap_pages: atomic_t,
    pub lock: spinlock_t,
    pub cont_lock: spinlock_t,
    pub discard_work: work_struct,
    pub discard_clusters: swap_cluster_list,
    pub avail_lists: __IncompleteArrayField<plist_node>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_nr_sectors: sector_t,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: ::aya_bpf::cty::c_ulong,
    pub bd_read_only: bool_,
    pub bd_dev: dev_t,
    pub bd_openers: atomic_t,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_claiming: *mut ::aya_bpf::cty::c_void,
    pub bd_device: device,
    pub bd_holder: *mut ::aya_bpf::cty::c_void,
    pub bd_holders: ::aya_bpf::cty::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_dir: *mut kobject,
    pub bd_partno: u8_,
    pub bd_size_lock: spinlock_t,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_fsfreeze_count: ::aya_bpf::cty::c_int,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_fsfreeze_sb: *mut super_block,
    pub bd_meta_info: *mut partition_meta_info,
    pub bd_make_it_fail: bool_,
}
pub type blk_opf_t = __u32;
pub type blk_status_t = u8_;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: ::aya_bpf::cty::c_uint,
    pub bi_idx: ::aya_bpf::cty::c_uint,
    pub bi_bvec_done: ::aya_bpf::cty::c_uint,
}
pub type blk_qc_t = ::aya_bpf::cty::c_uint;
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_bdev: *mut block_device,
    pub bi_opf: blk_opf_t,
    pub bi_flags: ::aya_bpf::cty::c_ushort,
    pub bi_ioprio: ::aya_bpf::cty::c_ushort,
    pub bi_status: blk_status_t,
    pub __bi_remaining: atomic_t,
    pub bi_iter: bvec_iter,
    pub bi_cookie: blk_qc_t,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut ::aya_bpf::cty::c_void,
    pub bi_blkg: *mut blkcg_gq,
    pub bi_issue: bio_issue,
    pub bi_iocost_cost: u64_,
    pub bi_crypt_context: *mut bio_crypt_ctx,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: ::aya_bpf::cty::c_ushort,
    pub bi_max_vecs: ::aya_bpf::cty::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    pub bi_integrity: *mut bio_integrity_payload,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timens_offsets {
    pub monotonic: timespec64,
    pub boottime: timespec64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_namespace {
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub ns: ns_common,
    pub offsets: timens_offsets,
    pub vvar_page: *mut page,
    pub frozen_offsets: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct bio_integrity_payload {
    pub bip_bio: *mut bio,
    pub bip_iter: bvec_iter,
    pub bip_vcnt: ::aya_bpf::cty::c_ushort,
    pub bip_max_vcnt: ::aya_bpf::cty::c_ushort,
    pub bip_flags: ::aya_bpf::cty::c_ushort,
    pub bio_iter: bvec_iter,
    pub bip_work: work_struct,
    pub bip_vec: *mut bio_vec,
    pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
}
pub type mempool_alloc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: gfp_t,
        arg2: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_void,
>;
pub type mempool_free_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void, arg2: *mut ::aya_bpf::cty::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempool_s {
    pub lock: spinlock_t,
    pub min_nr: ::aya_bpf::cty::c_int,
    pub curr_nr: ::aya_bpf::cty::c_int,
    pub elements: *mut *mut ::aya_bpf::cty::c_void,
    pub pool_data: *mut ::aya_bpf::cty::c_void,
    pub alloc: mempool_alloc_t,
    pub free: mempool_free_t,
    pub wait: wait_queue_head_t,
}
pub type mempool_t = mempool_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    pub bio_slab: *mut kmem_cache,
    pub front_pad: ::aya_bpf::cty::c_uint,
    pub cache: *mut bio_alloc_cache,
    pub bio_pool: mempool_t,
    pub bvec_pool: mempool_t,
    pub bio_integrity_pool: mempool_t,
    pub bvec_integrity_pool: mempool_t,
    pub back_pad: ::aya_bpf::cty::c_uint,
    pub rescue_lock: spinlock_t,
    pub rescue_list: bio_list,
    pub rescue_work: work_struct,
    pub rescue_workqueue: *mut workqueue_struct,
    pub cpuhp_dead: hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_reclaim_iter {
    pub position: *mut mem_cgroup,
    pub generation: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker_info {
    pub rcu: callback_head,
    pub nr_deferred: *mut atomic_long_t,
    pub map: *mut ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lruvec_stats_percpu {
    pub state: [::aya_bpf::cty::c_long; 43usize],
    pub state_prev: [::aya_bpf::cty::c_long; 43usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lruvec_stats {
    pub state: [::aya_bpf::cty::c_long; 43usize],
    pub state_pending: [::aya_bpf::cty::c_long; 43usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_per_node {
    pub lruvec: lruvec,
    pub lruvec_stats_percpu: *mut lruvec_stats_percpu,
    pub lruvec_stats: lruvec_stats,
    pub lru_zone_size: [::aya_bpf::cty::c_ulong; 25usize],
    pub iter: mem_cgroup_reclaim_iter,
    pub shrinker_info: *mut shrinker_info,
    pub tree_node: rb_node,
    pub usage_in_excess: ::aya_bpf::cty::c_ulong,
    pub on_tree: bool_,
    pub memcg: *mut mem_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup_threshold {
    pub eventfd: *mut eventfd_ctx,
    pub threshold: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct mem_cgroup_threshold_ary {
    pub current_threshold: ::aya_bpf::cty::c_int,
    pub size: ::aya_bpf::cty::c_uint,
    pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obj_cgroup {
    pub refcnt: percpu_ref,
    pub memcg: *mut mem_cgroup,
    pub nr_charged_bytes: atomic_t,
    pub __bindgen_anon_1: obj_cgroup__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obj_cgroup__bindgen_ty_1 {
    pub list: list_head,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_cluster {
    pub index: swap_cluster_info,
    pub next: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct ring_buffer_event {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub array: __IncompleteArrayField<u32_>,
}
impl ring_buffer_event {
    #[inline]
    pub fn type_len(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_type_len(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn time_delta(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_time_delta(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_len: u32_, time_delta: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let type_len: u32 = unsafe { ::core::mem::transmute(type_len) };
            type_len as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let time_delta: u32 = unsafe { ::core::mem::transmute(time_delta) };
            time_delta as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_event_file {
    pub list: list_head,
    pub event_call: *mut trace_event_call,
    pub filter: *mut event_filter,
    pub dir: *mut dentry,
    pub tr: *mut trace_array,
    pub system: *mut trace_subsystem_dir,
    pub triggers: list_head,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub sm_ref: atomic_t,
    pub tm_ref: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_mmap_page {
    pub version: __u32,
    pub compat_version: __u32,
    pub lock: __u32,
    pub index: __u32,
    pub offset: __s64,
    pub time_enabled: __u64,
    pub time_running: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1,
    pub pmc_width: __u16,
    pub time_shift: __u16,
    pub time_mult: __u32,
    pub time_offset: __u64,
    pub time_zero: __u64,
    pub size: __u32,
    pub __reserved_1: __u32,
    pub time_cycles: __u64,
    pub time_mask: __u64,
    pub __reserved: [__u8; 928usize],
    pub data_head: __u64,
    pub data_tail: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
    pub aux_head: __u64,
    pub aux_tail: __u64,
    pub aux_offset: __u64,
    pub aux_size: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union perf_event_mmap_page__bindgen_ty_1 {
    pub capabilities: __u64,
    pub __bindgen_anon_1: perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl perf_event_mmap_page__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn cap_bit0(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_bit0_is_deprecated(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_bit0_is_deprecated(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_rdpmc(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_rdpmc(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_zero(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_zero(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_user_time_short(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cap_user_time_short(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cap_____res(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_cap_____res(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cap_bit0: __u64,
        cap_bit0_is_deprecated: __u64,
        cap_user_rdpmc: __u64,
        cap_user_time: __u64,
        cap_user_time_zero: __u64,
        cap_user_time_short: __u64,
        cap_____res: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cap_bit0: u64 = unsafe { ::core::mem::transmute(cap_bit0) };
            cap_bit0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cap_bit0_is_deprecated: u64 =
                unsafe { ::core::mem::transmute(cap_bit0_is_deprecated) };
            cap_bit0_is_deprecated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cap_user_rdpmc: u64 = unsafe { ::core::mem::transmute(cap_user_rdpmc) };
            cap_user_rdpmc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cap_user_time: u64 = unsafe { ::core::mem::transmute(cap_user_time) };
            cap_user_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cap_user_time_zero: u64 = unsafe { ::core::mem::transmute(cap_user_time_zero) };
            cap_user_time_zero as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cap_user_time_short: u64 = unsafe { ::core::mem::transmute(cap_user_time_short) };
            cap_user_time_short as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let cap_____res: u64 = unsafe { ::core::mem::transmute(cap_____res) };
            cap_____res as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type smp_call_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldt_struct {
    pub entries: *mut desc_struct,
    pub nr_entries: ::aya_bpf::cty::c_uint,
    pub slot: ::aya_bpf::cty::c_int,
}
pub type slab_flags_t = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ops {
    pub proc_flags: ::aya_bpf::cty::c_uint,
    pub proc_open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf::cty::c_int,
    >,
    pub proc_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub proc_read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub proc_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub proc_lseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::aya_bpf::cty::c_int) -> loff_t,
    >,
    pub proc_release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::aya_bpf::cty::c_int,
    >,
    pub proc_poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub proc_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub proc_compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub proc_mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub proc_get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: ::aya_bpf::cty::c_ulong,
            arg5: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct firmware {
    pub size: usize,
    pub data: *const u8_,
    pub priv_: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    pub refcnt: atomic_t,
    pub mode: ::aya_bpf::cty::c_ushort,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub nodes: nodemask_t,
    pub home_node: ::aya_bpf::cty::c_int,
    pub w: mempolicy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mempolicy__bindgen_ty_1 {
    pub cpuset_mems_allowed: nodemask_t,
    pub user_nodemask: nodemask_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_log {
    pub prefix: *const ::aya_bpf::cty::c_char,
    pub log: *mut fc_log,
}
pub mod fs_context_purpose {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FS_CONTEXT_FOR_MOUNT: Type = 0;
    pub const FS_CONTEXT_FOR_SUBMOUNT: Type = 1;
    pub const FS_CONTEXT_FOR_RECONFIGURE: Type = 2;
}
pub mod fs_context_phase {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FS_CONTEXT_CREATE_PARAMS: Type = 0;
    pub const FS_CONTEXT_CREATING: Type = 1;
    pub const FS_CONTEXT_AWAITING_MOUNT: Type = 2;
    pub const FS_CONTEXT_AWAITING_RECONF: Type = 3;
    pub const FS_CONTEXT_RECONF_PARAMS: Type = 4;
    pub const FS_CONTEXT_RECONFIGURING: Type = 5;
    pub const FS_CONTEXT_FAILED: Type = 6;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    pub ops: *const fs_context_operations,
    pub uapi_mutex: mutex,
    pub fs_type: *mut file_system_type,
    pub fs_private: *mut ::aya_bpf::cty::c_void,
    pub sget_key: *mut ::aya_bpf::cty::c_void,
    pub root: *mut dentry,
    pub user_ns: *mut user_namespace,
    pub net_ns: *mut net,
    pub cred: *const cred,
    pub log: p_log,
    pub source: *const ::aya_bpf::cty::c_char,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub s_fs_info: *mut ::aya_bpf::cty::c_void,
    pub sb_flags: ::aya_bpf::cty::c_uint,
    pub sb_flags_mask: ::aya_bpf::cty::c_uint,
    pub s_iflags: ::aya_bpf::cty::c_uint,
    pub lsm_flags: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl fs_context {
    #[inline]
    pub fn purpose(&self) -> fs_context_purpose::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_purpose(&mut self, val: fs_context_purpose::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn phase(&self) -> fs_context_phase::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_phase(&mut self, val: fs_context_phase::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn need_free(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_need_free(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn global(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_global(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oldapi(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oldapi(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        purpose: fs_context_purpose::Type,
        phase: fs_context_phase::Type,
        need_free: bool_,
        global: bool_,
        oldapi: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let purpose: u32 = unsafe { ::core::mem::transmute(purpose) };
            purpose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let phase: u32 = unsafe { ::core::mem::transmute(phase) };
            phase as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let need_free: u8 = unsafe { ::core::mem::transmute(need_free) };
            need_free as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let global: u8 = unsafe { ::core::mem::transmute(global) };
            global as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oldapi: u8 = unsafe { ::core::mem::transmute(oldapi) };
            oldapi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct filename {
    pub name: *const ::aya_bpf::cty::c_char,
    pub uptr: *const ::aya_bpf::cty::c_char,
    pub refcnt: ::aya_bpf::cty::c_int,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
pub mod fs_value_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const fs_value_is_undefined: Type = 0;
    pub const fs_value_is_flag: Type = 1;
    pub const fs_value_is_string: Type = 2;
    pub const fs_value_is_blob: Type = 3;
    pub const fs_value_is_filename: Type = 4;
    pub const fs_value_is_file: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    pub key: *const ::aya_bpf::cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: fs_parameter__bindgen_ty_1,
    pub size: usize,
    pub dirfd: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parameter__bindgen_ty_1 {
    pub string: *mut ::aya_bpf::cty::c_char,
    pub blob: *mut ::aya_bpf::cty::c_void,
    pub name: *mut filename,
    pub file: *mut file,
}
impl fs_parameter {
    #[inline]
    pub fn type_(&self) -> fs_value_type::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: fs_value_type::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: fs_value_type::Type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fc_log {
    pub usage: refcount_t,
    pub head: u8_,
    pub tail: u8_,
    pub need_free: u8_,
    pub owner: *mut module,
    pub buffer: [*mut ::aya_bpf::cty::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_context_operations {
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context)>,
    pub dup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context, arg2: *mut fs_context) -> ::aya_bpf::cty::c_int,
    >,
    pub parse_param: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fs_context,
            arg2: *mut fs_parameter,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub parse_monolithic: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fs_context,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_tree: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf::cty::c_int,
    >,
    pub reconfigure: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parse_result {
    pub negated: bool_,
    pub __bindgen_anon_1: fs_parse_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parse_result__bindgen_ty_1 {
    pub boolean: bool_,
    pub int_32: ::aya_bpf::cty::c_int,
    pub uint_32: ::aya_bpf::cty::c_uint,
    pub uint_64: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_tlb_mem {
    pub start: phys_addr_t,
    pub end: phys_addr_t,
    pub vaddr: *mut ::aya_bpf::cty::c_void,
    pub nslabs: ::aya_bpf::cty::c_ulong,
    pub used: ::aya_bpf::cty::c_ulong,
    pub debugfs: *mut dentry,
    pub late_alloc: bool_,
    pub force_bounce: bool_,
    pub for_alloc: bool_,
    pub nareas: ::aya_bpf::cty::c_uint,
    pub area_nslabs: ::aya_bpf::cty::c_uint,
    pub areas: *mut io_tlb_area,
    pub slots: *mut io_tlb_slot,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scatterlist {
    pub page_link: ::aya_bpf::cty::c_ulong,
    pub offset: ::aya_bpf::cty::c_uint,
    pub length: ::aya_bpf::cty::c_uint,
    pub dma_address: dma_addr_t,
    pub dma_length: ::aya_bpf::cty::c_uint,
    pub dma_flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: ::aya_bpf::cty::c_uint,
    pub orig_nents: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsset {
    pub flags: ::aya_bpf::cty::c_uint,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub cred: *const cred,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_binfmt {
    pub lh: list_head,
    pub module: *mut module,
    pub load_binary: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut linux_binprm) -> ::aya_bpf::cty::c_int,
    >,
    pub load_shlib:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file) -> ::aya_bpf::cty::c_int>,
    pub core_dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut coredump_params) -> ::aya_bpf::cty::c_int,
    >,
    pub min_coredump: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_struct {
    pub users: ::aya_bpf::cty::c_int,
    pub lock: spinlock_t,
    pub seq: seqcount_spinlock_t,
    pub umask: ::aya_bpf::cty::c_int,
    pub in_exec: ::aya_bpf::cty::c_int,
    pub root: path,
    pub pwd: path,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ld_semaphore {
    pub count: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub wait_readers: ::aya_bpf::cty::c_uint,
    pub read_wait: list_head,
    pub write_wait: list_head,
}
pub type tcflag_t = ::aya_bpf::cty::c_uint;
pub type cc_t = ::aya_bpf::cty::c_uchar;
pub type speed_t = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktermios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 19usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::aya_bpf::cty::c_ushort,
    pub ws_col: ::aya_bpf::cty::c_ushort,
    pub ws_xpixel: ::aya_bpf::cty::c_ushort,
    pub ws_ypixel: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
pub struct tty_struct {
    pub kref: kref,
    pub dev: *mut device,
    pub driver: *mut tty_driver,
    pub ops: *const tty_operations,
    pub index: ::aya_bpf::cty::c_int,
    pub ldisc_sem: ld_semaphore,
    pub ldisc: *mut tty_ldisc,
    pub atomic_write_lock: mutex,
    pub legacy_mutex: mutex,
    pub throttle_mutex: mutex,
    pub termios_rwsem: rw_semaphore,
    pub winsize_mutex: mutex,
    pub termios: ktermios,
    pub termios_locked: ktermios,
    pub name: [::aya_bpf::cty::c_char; 64usize],
    pub flags: ::aya_bpf::cty::c_ulong,
    pub count: ::aya_bpf::cty::c_int,
    pub winsize: winsize,
    pub flow: tty_struct__bindgen_ty_1,
    pub ctrl: tty_struct__bindgen_ty_2,
    pub hw_stopped: ::aya_bpf::cty::c_int,
    pub receive_room: ::aya_bpf::cty::c_uint,
    pub flow_change: ::aya_bpf::cty::c_int,
    pub link: *mut tty_struct,
    pub fasync: *mut fasync_struct,
    pub write_wait: wait_queue_head_t,
    pub read_wait: wait_queue_head_t,
    pub hangup_work: work_struct,
    pub disc_data: *mut ::aya_bpf::cty::c_void,
    pub driver_data: *mut ::aya_bpf::cty::c_void,
    pub files_lock: spinlock_t,
    pub tty_files: list_head,
    pub closing: ::aya_bpf::cty::c_int,
    pub write_buf: *mut ::aya_bpf::cty::c_uchar,
    pub write_cnt: ::aya_bpf::cty::c_int,
    pub SAK_work: work_struct,
    pub port: *mut tty_port,
}
#[repr(C)]
pub struct tty_struct__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub stopped: bool_,
    pub tco_stopped: bool_,
    pub unused: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
pub struct tty_struct__bindgen_ty_2 {
    pub lock: spinlock_t,
    pub pgrp: *mut pid,
    pub session: *mut pid,
    pub pktstatus: ::aya_bpf::cty::c_uchar,
    pub packet: bool_,
    pub unused: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
pub struct tty_buffer {
    pub __bindgen_anon_1: tty_buffer__bindgen_ty_1,
    pub used: ::aya_bpf::cty::c_int,
    pub size: ::aya_bpf::cty::c_int,
    pub commit: ::aya_bpf::cty::c_int,
    pub lookahead: ::aya_bpf::cty::c_int,
    pub read: ::aya_bpf::cty::c_int,
    pub flags: bool_,
    pub data: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tty_buffer__bindgen_ty_1 {
    pub next: *mut tty_buffer,
    pub free: llist_node,
}
#[repr(C)]
pub struct tty_bufhead {
    pub head: *mut tty_buffer,
    pub work: work_struct,
    pub lock: mutex,
    pub priority: atomic_t,
    pub sentinel: tty_buffer,
    pub free: llist_head,
    pub mem_used: atomic_t,
    pub mem_limit: ::aya_bpf::cty::c_int,
    pub tail: *mut tty_buffer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: *mut file,
            arg3: ::aya_bpf::cty::c_int,
        ) -> *mut tty_struct,
    >,
    pub install: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_driver, arg2: *mut tty_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_driver, arg2: *mut tty_struct)>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file) -> ::aya_bpf::cty::c_int,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut file)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub put_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uchar,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flush_chars: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub write_room: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf::cty::c_uint,
    >,
    pub chars_in_buffer: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf::cty::c_uint,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub set_termios:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *const ktermios)>,
    pub throttle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub unthrottle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub hangup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub break_ctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flush_buffer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub set_ldisc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub wait_until_sent: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf::cty::c_int),
    >,
    pub send_xchar: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf::cty::c_char),
    >,
    pub tiocmget: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub tiocmset: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub resize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut winsize) -> ::aya_bpf::cty::c_int,
    >,
    pub get_icount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_icounter_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_serial: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_serial: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut serial_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *mut seq_file)>,
    pub poll_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_char,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub poll_get_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub poll_put_char: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_driver,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_char,
        ),
    >,
    pub proc_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_driver {
    pub kref: kref,
    pub cdevs: *mut *mut cdev,
    pub owner: *mut module,
    pub driver_name: *const ::aya_bpf::cty::c_char,
    pub name: *const ::aya_bpf::cty::c_char,
    pub name_base: ::aya_bpf::cty::c_int,
    pub major: ::aya_bpf::cty::c_int,
    pub minor_start: ::aya_bpf::cty::c_int,
    pub num: ::aya_bpf::cty::c_uint,
    pub type_: ::aya_bpf::cty::c_short,
    pub subtype: ::aya_bpf::cty::c_short,
    pub init_termios: ktermios,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub proc_entry: *mut proc_dir_entry,
    pub other: *mut tty_driver,
    pub ttys: *mut *mut tty_struct,
    pub ports: *mut *mut tty_port,
    pub termios: *mut *mut ktermios,
    pub driver_state: *mut ::aya_bpf::cty::c_void,
    pub ops: *const tty_operations,
    pub tty_drivers: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kfifo {
    pub in_: ::aya_bpf::cty::c_uint,
    pub out: ::aya_bpf::cty::c_uint,
    pub mask: ::aya_bpf::cty::c_uint,
    pub esize: ::aya_bpf::cty::c_uint,
    pub data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
pub struct tty_port {
    pub buf: tty_bufhead,
    pub tty: *mut tty_struct,
    pub itty: *mut tty_struct,
    pub ops: *const tty_port_operations,
    pub client_ops: *const tty_port_client_operations,
    pub lock: spinlock_t,
    pub blocked_open: ::aya_bpf::cty::c_int,
    pub count: ::aya_bpf::cty::c_int,
    pub open_wait: wait_queue_head_t,
    pub delta_msr_wait: wait_queue_head_t,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub iflags: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mutex: mutex,
    pub buf_mutex: mutex,
    pub xmit_buf: *mut ::aya_bpf::cty::c_uchar,
    pub xmit_fifo: tty_port__bindgen_ty_1,
    pub close_delay: ::aya_bpf::cty::c_uint,
    pub closing_wait: ::aya_bpf::cty::c_uint,
    pub drain_delay: ::aya_bpf::cty::c_int,
    pub kref: kref,
    pub client_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
pub struct tty_port__bindgen_ty_1 {
    pub __bindgen_anon_1: tty_port__bindgen_ty_1__bindgen_ty_1,
    pub buf: __IncompleteArrayField<::aya_bpf::cty::c_uchar>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tty_port__bindgen_ty_1__bindgen_ty_1 {
    pub kfifo: __kfifo,
    pub type_: *mut ::aya_bpf::cty::c_uchar,
    pub const_type: *const ::aya_bpf::cty::c_uchar,
    pub rectype: *mut [::aya_bpf::cty::c_char; 0usize],
    pub ptr: *mut ::aya_bpf::cty::c_uchar,
    pub ptr_const: *const ::aya_bpf::cty::c_uchar,
}
impl tty_port {
    #[inline]
    pub fn console(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_console(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(console: ::aya_bpf::cty::c_uchar) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let console: u8 = unsafe { ::core::mem::transmute(console) };
            console as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_ldisc_ops {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub num: ::aya_bpf::cty::c_int,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub flush_buffer: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *mut ::aya_bpf::cty::c_uchar,
            arg4: usize,
            arg5: *mut *mut ::aya_bpf::cty::c_void,
            arg6: ::aya_bpf::cty::c_ulong,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: usize,
        ) -> isize,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_termios:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct, arg2: *const ktermios)>,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *mut file,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub hangup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub receive_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: ::aya_bpf::cty::c_int,
        ),
    >,
    pub write_wakeup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_struct)>,
    pub dcd_change: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_struct, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub receive_buf2: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lookahead_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_struct,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_ldisc {
    pub ops: *mut tty_ldisc_ops,
    pub tty: *mut tty_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_port_operations {
    pub carrier_raised:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port) -> ::aya_bpf::cty::c_int>,
    pub dtr_rts: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_port, arg2: ::aya_bpf::cty::c_int),
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tty_port, arg2: *mut tty_struct) -> ::aya_bpf::cty::c_int,
    >,
    pub destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_port_client_operations {
    pub receive_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_port,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lookahead_buf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tty_port,
            arg2: *const ::aya_bpf::cty::c_uchar,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub write_wakeup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tty_port)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_binprm {
    pub vma: *mut vm_area_struct,
    pub vma_pages: ::aya_bpf::cty::c_ulong,
    pub mm: *mut mm_struct,
    pub p: ::aya_bpf::cty::c_ulong,
    pub argmin: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub executable: *mut file,
    pub interpreter: *mut file,
    pub file: *mut file,
    pub cred: *mut cred,
    pub unsafe_: ::aya_bpf::cty::c_int,
    pub per_clear: ::aya_bpf::cty::c_uint,
    pub argc: ::aya_bpf::cty::c_int,
    pub envc: ::aya_bpf::cty::c_int,
    pub filename: *const ::aya_bpf::cty::c_char,
    pub interp: *const ::aya_bpf::cty::c_char,
    pub fdpath: *const ::aya_bpf::cty::c_char,
    pub interp_flags: ::aya_bpf::cty::c_uint,
    pub execfd: ::aya_bpf::cty::c_int,
    pub loader: ::aya_bpf::cty::c_ulong,
    pub exec: ::aya_bpf::cty::c_ulong,
    pub rlim_stack: rlimit,
    pub buf: [::aya_bpf::cty::c_char; 256usize],
}
impl linux_binprm {
    #[inline]
    pub fn have_execfd(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_have_execfd(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn execfd_creds(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_execfd_creds(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secureexec(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secureexec(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn point_of_no_return(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_point_of_no_return(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        have_execfd: ::aya_bpf::cty::c_uint,
        execfd_creds: ::aya_bpf::cty::c_uint,
        secureexec: ::aya_bpf::cty::c_uint,
        point_of_no_return: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let have_execfd: u32 = unsafe { ::core::mem::transmute(have_execfd) };
            have_execfd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let execfd_creds: u32 = unsafe { ::core::mem::transmute(execfd_creds) };
            execfd_creds as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let secureexec: u32 = unsafe { ::core::mem::transmute(secureexec) };
            secureexec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let point_of_no_return: u32 = unsafe { ::core::mem::transmute(point_of_no_return) };
            point_of_no_return as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pin_cookie {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ::aya_bpf::cty::c_void,
}
pub type call_single_data_t = __call_single_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dl_bw {
    pub lock: raw_spinlock_t,
    pub bw: u64_,
    pub total_bw: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpudl {
    pub lock: raw_spinlock_t,
    pub size: ::aya_bpf::cty::c_int,
    pub free_cpus: cpumask_var_t,
    pub elements: *mut cpudl_item,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpupri_vec {
    pub count: atomic_t,
    pub mask: cpumask_var_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpupri {
    pub pri_to_cpu: [cpupri_vec; 101usize],
    pub cpu_to_pri: *mut ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct root_domain {
    pub refcount: atomic_t,
    pub rto_count: atomic_t,
    pub rcu: callback_head,
    pub span: cpumask_var_t,
    pub online: cpumask_var_t,
    pub overload: ::aya_bpf::cty::c_int,
    pub overutilized: ::aya_bpf::cty::c_int,
    pub dlo_mask: cpumask_var_t,
    pub dlo_count: atomic_t,
    pub dl_bw: dl_bw,
    pub cpudl: cpudl,
    pub visit_gen: u64_,
    pub rto_push_work: irq_work,
    pub rto_lock: raw_spinlock_t,
    pub rto_loop: ::aya_bpf::cty::c_int,
    pub rto_cpu: ::aya_bpf::cty::c_int,
    pub rto_loop_next: atomic_t,
    pub rto_loop_start: atomic_t,
    pub rto_mask: cpumask_var_t,
    pub cpupri: cpupri,
    pub max_cpu_capacity: ::aya_bpf::cty::c_ulong,
    pub pd: *mut perf_domain,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq {
    pub load: load_weight,
    pub nr_running: ::aya_bpf::cty::c_uint,
    pub h_nr_running: ::aya_bpf::cty::c_uint,
    pub idle_nr_running: ::aya_bpf::cty::c_uint,
    pub idle_h_nr_running: ::aya_bpf::cty::c_uint,
    pub exec_clock: u64_,
    pub min_vruntime: u64_,
    pub forceidle_seq: ::aya_bpf::cty::c_uint,
    pub min_vruntime_fi: u64_,
    pub tasks_timeline: rb_root_cached,
    pub curr: *mut sched_entity,
    pub next: *mut sched_entity,
    pub last: *mut sched_entity,
    pub skip: *mut sched_entity,
    pub nr_spread_over: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub avg: sched_avg,
    pub removed: cfs_rq__bindgen_ty_1,
    pub tg_load_avg_contrib: ::aya_bpf::cty::c_ulong,
    pub propagate: ::aya_bpf::cty::c_long,
    pub prop_runnable_sum: ::aya_bpf::cty::c_long,
    pub h_load: ::aya_bpf::cty::c_ulong,
    pub last_h_load_update: u64_,
    pub h_load_next: *mut sched_entity,
    pub rq: *mut rq,
    pub on_list: ::aya_bpf::cty::c_int,
    pub leaf_cfs_rq_list: list_head,
    pub tg: *mut task_group,
    pub idle: ::aya_bpf::cty::c_int,
    pub runtime_enabled: ::aya_bpf::cty::c_int,
    pub runtime_remaining: s64,
    pub throttled_pelt_idle: u64_,
    pub throttled_clock: u64_,
    pub throttled_clock_pelt: u64_,
    pub throttled_clock_pelt_time: u64_,
    pub throttled: ::aya_bpf::cty::c_int,
    pub throttle_count: ::aya_bpf::cty::c_int,
    pub throttled_list: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq__bindgen_ty_1 {
    pub lock: raw_spinlock_t,
    pub nr: ::aya_bpf::cty::c_int,
    pub load_avg: ::aya_bpf::cty::c_ulong,
    pub util_avg: ::aya_bpf::cty::c_ulong,
    pub runnable_avg: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl cfs_rq__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl cfs_rq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_bandwidth {
    pub lock: raw_spinlock_t,
    pub period: ktime_t,
    pub quota: u64_,
    pub runtime: u64_,
    pub burst: u64_,
    pub runtime_snap: u64_,
    pub hierarchical_quota: s64,
    pub idle: u8_,
    pub period_active: u8_,
    pub slack_started: u8_,
    pub period_timer: hrtimer,
    pub slack_timer: hrtimer,
    pub throttled_cfs_rq: list_head,
    pub nr_periods: ::aya_bpf::cty::c_int,
    pub nr_throttled: ::aya_bpf::cty::c_int,
    pub nr_burst: ::aya_bpf::cty::c_int,
    pub throttled_time: u64_,
    pub burst_time: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_group {
    pub css: cgroup_subsys_state,
    pub se: *mut *mut sched_entity,
    pub cfs_rq: *mut *mut cfs_rq,
    pub shares: ::aya_bpf::cty::c_ulong,
    pub idle: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub load_avg: atomic_long_t,
    pub rcu: callback_head,
    pub list: list_head,
    pub parent: *mut task_group,
    pub siblings: list_head,
    pub children: list_head,
    pub cfs_bandwidth: cfs_bandwidth,
}
impl task_group {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct numa_group {
    pub refcount: refcount_t,
    pub lock: spinlock_t,
    pub nr_tasks: ::aya_bpf::cty::c_int,
    pub gid: pid_t,
    pub active_nodes: ::aya_bpf::cty::c_int,
    pub rcu: callback_head,
    pub total_faults: ::aya_bpf::cty::c_ulong,
    pub max_faults_cpu: ::aya_bpf::cty::c_ulong,
    pub faults: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
pub mod pm_qos_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PM_QOS_UNITIALIZED: Type = 0;
    pub const PM_QOS_MAX: Type = 1;
    pub const PM_QOS_MIN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_constraints {
    pub list: plist_head,
    pub target_value: s32,
    pub default_value: s32,
    pub no_constraint_value: s32,
    pub type_: pm_qos_type::Type,
    pub notifiers: *mut blocking_notifier_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct freq_constraints {
    pub min_freq: pm_qos_constraints,
    pub min_freq_notifiers: blocking_notifier_head,
    pub max_freq: pm_qos_constraints,
    pub max_freq_notifiers: blocking_notifier_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_flags {
    pub list: list_head,
    pub effective_flags: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos {
    pub resume_latency: pm_qos_constraints,
    pub latency_tolerance: pm_qos_constraints,
    pub freq: freq_constraints,
    pub flags: pm_qos_flags,
    pub resume_latency_req: *mut dev_pm_qos_request,
    pub latency_tolerance_req: *mut dev_pm_qos_request,
    pub flags_req: *mut dev_pm_qos_request,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_domain_shared {
    pub ref_: atomic_t,
    pub nr_busy_cpus: atomic_t,
    pub has_idle_cores: ::aya_bpf::cty::c_int,
    pub nr_idle_scan: ::aya_bpf::cty::c_int,
}
#[repr(C)]
pub struct sched_domain {
    pub parent: *mut sched_domain,
    pub child: *mut sched_domain,
    pub groups: *mut sched_group,
    pub min_interval: ::aya_bpf::cty::c_ulong,
    pub max_interval: ::aya_bpf::cty::c_ulong,
    pub busy_factor: ::aya_bpf::cty::c_uint,
    pub imbalance_pct: ::aya_bpf::cty::c_uint,
    pub cache_nice_tries: ::aya_bpf::cty::c_uint,
    pub imb_numa_nr: ::aya_bpf::cty::c_uint,
    pub nohz_idle: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub level: ::aya_bpf::cty::c_int,
    pub last_balance: ::aya_bpf::cty::c_ulong,
    pub balance_interval: ::aya_bpf::cty::c_uint,
    pub nr_balance_failed: ::aya_bpf::cty::c_uint,
    pub max_newidle_lb_cost: u64_,
    pub last_decay_max_lb_cost: ::aya_bpf::cty::c_ulong,
    pub avg_scan_cost: u64_,
    pub lb_count: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_failed: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_balanced: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_imbalance: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_gained: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_hot_gained: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_nobusyg: [::aya_bpf::cty::c_uint; 3usize],
    pub lb_nobusyq: [::aya_bpf::cty::c_uint; 3usize],
    pub alb_count: ::aya_bpf::cty::c_uint,
    pub alb_failed: ::aya_bpf::cty::c_uint,
    pub alb_pushed: ::aya_bpf::cty::c_uint,
    pub sbe_count: ::aya_bpf::cty::c_uint,
    pub sbe_balanced: ::aya_bpf::cty::c_uint,
    pub sbe_pushed: ::aya_bpf::cty::c_uint,
    pub sbf_count: ::aya_bpf::cty::c_uint,
    pub sbf_balanced: ::aya_bpf::cty::c_uint,
    pub sbf_pushed: ::aya_bpf::cty::c_uint,
    pub ttwu_wake_remote: ::aya_bpf::cty::c_uint,
    pub ttwu_move_affine: ::aya_bpf::cty::c_uint,
    pub ttwu_move_balance: ::aya_bpf::cty::c_uint,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub __bindgen_anon_1: sched_domain__bindgen_ty_1,
    pub shared: *mut sched_domain_shared,
    pub span_weight: ::aya_bpf::cty::c_uint,
    pub span: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_domain__bindgen_ty_1 {
    pub private: *mut ::aya_bpf::cty::c_void,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug)]
pub struct sched_group {
    pub next: *mut sched_group,
    pub ref_: atomic_t,
    pub group_weight: ::aya_bpf::cty::c_uint,
    pub sgc: *mut sched_group_capacity,
    pub asym_prefer_cpu: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub cpumask: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug)]
pub struct sched_group_capacity {
    pub ref_: atomic_t,
    pub capacity: ::aya_bpf::cty::c_ulong,
    pub min_capacity: ::aya_bpf::cty::c_ulong,
    pub max_capacity: ::aya_bpf::cty::c_ulong,
    pub next_update: ::aya_bpf::cty::c_ulong,
    pub imbalance: ::aya_bpf::cty::c_int,
    pub id: ::aya_bpf::cty::c_int,
    pub cpumask: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_state_usage {
    pub disable: ::aya_bpf::cty::c_ulonglong,
    pub usage: ::aya_bpf::cty::c_ulonglong,
    pub time_ns: u64_,
    pub above: ::aya_bpf::cty::c_ulonglong,
    pub below: ::aya_bpf::cty::c_ulonglong,
    pub rejected: ::aya_bpf::cty::c_ulonglong,
    pub s2idle_usage: ::aya_bpf::cty::c_ulonglong,
    pub s2idle_time: ::aya_bpf::cty::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_state {
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub desc: [::aya_bpf::cty::c_char; 32usize],
    pub exit_latency_ns: s64,
    pub target_residency_ns: s64,
    pub flags: ::aya_bpf::cty::c_uint,
    pub exit_latency: ::aya_bpf::cty::c_uint,
    pub power_usage: ::aya_bpf::cty::c_int,
    pub target_residency: ::aya_bpf::cty::c_uint,
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: *mut cpuidle_driver,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub enter_dead: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub enter_s2idle: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cpuidle_device,
            arg2: *mut cpuidle_driver,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_driver_kobj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_device {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cpu: ::aya_bpf::cty::c_uint,
    pub next_hrtimer: ktime_t,
    pub last_state_idx: ::aya_bpf::cty::c_int,
    pub last_residency_ns: u64_,
    pub poll_limit_ns: u64_,
    pub forced_idle_latency_limit_ns: u64_,
    pub states_usage: [cpuidle_state_usage; 10usize],
    pub kobjs: [*mut cpuidle_state_kobj; 10usize],
    pub kobj_driver: *mut cpuidle_driver_kobj,
    pub kobj_dev: *mut cpuidle_device_kobj,
    pub device_list: list_head,
}
impl cpuidle_device {
    #[inline]
    pub fn registered(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn poll_time_limit(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_poll_time_limit(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        registered: ::aya_bpf::cty::c_uint,
        enabled: ::aya_bpf::cty::c_uint,
        poll_time_limit: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let registered: u32 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let poll_time_limit: u32 = unsafe { ::core::mem::transmute(poll_time_limit) };
            poll_time_limit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuidle_driver {
    pub name: *const ::aya_bpf::cty::c_char,
    pub owner: *mut module,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub states: [cpuidle_state; 10usize],
    pub state_count: ::aya_bpf::cty::c_int,
    pub safe_state_index: ::aya_bpf::cty::c_int,
    pub cpumask: *mut cpumask,
    pub governor: *const ::aya_bpf::cty::c_char,
}
impl cpuidle_driver {
    #[inline]
    pub fn bctimer(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bctimer(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bctimer: ::aya_bpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bctimer: u32 = unsafe { ::core::mem::transmute(bctimer) };
            bctimer as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod task_work_notify_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TWA_NONE: Type = 0;
    pub const TWA_RESUME: Type = 1;
    pub const TWA_SIGNAL: Type = 2;
    pub const TWA_SIGNAL_NO_IPI: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_qos_flags_request {
    pub node: list_head,
    pub flags: s32,
}
pub mod freq_qos_req_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FREQ_QOS_MIN: Type = 1;
    pub const FREQ_QOS_MAX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct freq_qos_request {
    pub type_: freq_qos_req_type::Type,
    pub pnode: plist_node,
    pub qos: *mut freq_constraints,
}
pub mod dev_pm_qos_req_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEV_PM_QOS_RESUME_LATENCY: Type = 1;
    pub const DEV_PM_QOS_LATENCY_TOLERANCE: Type = 2;
    pub const DEV_PM_QOS_MIN_FREQUENCY: Type = 3;
    pub const DEV_PM_QOS_MAX_FREQUENCY: Type = 4;
    pub const DEV_PM_QOS_FLAGS: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_qos_request {
    pub type_: dev_pm_qos_req_type::Type,
    pub data: dev_pm_qos_request__bindgen_ty_1,
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dev_pm_qos_request__bindgen_ty_1 {
    pub pnode: plist_node,
    pub flr: pm_qos_flags_request,
    pub freq: freq_qos_request,
}
pub type cpu_stop_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_stop_work {
    pub list: list_head,
    pub fn_: cpu_stop_fn_t,
    pub caller: ::aya_bpf::cty::c_ulong,
    pub arg: *mut ::aya_bpf::cty::c_void,
    pub done: *mut cpu_stop_done,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpudl_item {
    pub dl: u64_,
    pub cpu: ::aya_bpf::cty::c_int,
    pub idx: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_prio_array {
    pub bitmap: [::aya_bpf::cty::c_ulong; 2usize],
    pub queue: [list_head; 100usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_rq {
    pub active: rt_prio_array,
    pub rt_nr_running: ::aya_bpf::cty::c_uint,
    pub rr_nr_running: ::aya_bpf::cty::c_uint,
    pub highest_prio: rt_rq__bindgen_ty_1,
    pub rt_nr_migratory: ::aya_bpf::cty::c_uint,
    pub rt_nr_total: ::aya_bpf::cty::c_uint,
    pub overloaded: ::aya_bpf::cty::c_int,
    pub pushable_tasks: plist_head,
    pub rt_queued: ::aya_bpf::cty::c_int,
    pub rt_throttled: ::aya_bpf::cty::c_int,
    pub rt_time: u64_,
    pub rt_runtime: u64_,
    pub rt_runtime_lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rq__bindgen_ty_1 {
    pub curr: ::aya_bpf::cty::c_int,
    pub next: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_rq {
    pub root: rb_root_cached,
    pub dl_nr_running: ::aya_bpf::cty::c_uint,
    pub earliest_dl: dl_rq__bindgen_ty_1,
    pub dl_nr_migratory: ::aya_bpf::cty::c_uint,
    pub overloaded: ::aya_bpf::cty::c_int,
    pub pushable_dl_tasks_root: rb_root_cached,
    pub running_bw: u64_,
    pub this_bw: u64_,
    pub extra_bw: u64_,
    pub bw_ratio: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_rq__bindgen_ty_1 {
    pub curr: u64_,
    pub next: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq {
    pub __lock: raw_spinlock_t,
    pub nr_running: ::aya_bpf::cty::c_uint,
    pub nr_numa_running: ::aya_bpf::cty::c_uint,
    pub nr_preferred_running: ::aya_bpf::cty::c_uint,
    pub numa_migrate_on: ::aya_bpf::cty::c_uint,
    pub last_blocked_load_update_tick: ::aya_bpf::cty::c_ulong,
    pub has_blocked_load: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub nohz_csd: call_single_data_t,
    pub nohz_tick_stopped: ::aya_bpf::cty::c_uint,
    pub nohz_flags: atomic_t,
    pub ttwu_pending: ::aya_bpf::cty::c_uint,
    pub nr_switches: u64_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub cfs: cfs_rq,
    pub rt: rt_rq,
    pub dl: dl_rq,
    pub leaf_cfs_rq_list: list_head,
    pub tmp_alone_branch: *mut list_head,
    pub nr_uninterruptible: ::aya_bpf::cty::c_uint,
    pub curr: *mut task_struct,
    pub idle: *mut task_struct,
    pub stop: *mut task_struct,
    pub next_balance: ::aya_bpf::cty::c_ulong,
    pub prev_mm: *mut mm_struct,
    pub clock_update_flags: ::aya_bpf::cty::c_uint,
    pub clock: u64_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub clock_task: u64_,
    pub clock_pelt: u64_,
    pub lost_idle_time: ::aya_bpf::cty::c_ulong,
    pub clock_pelt_idle: u64_,
    pub clock_idle: u64_,
    pub nr_iowait: atomic_t,
    pub last_seen_need_resched_ns: u64_,
    pub ticks_without_resched: ::aya_bpf::cty::c_int,
    pub membarrier_state: ::aya_bpf::cty::c_int,
    pub rd: *mut root_domain,
    pub sd: *mut sched_domain,
    pub cpu_capacity: ::aya_bpf::cty::c_ulong,
    pub cpu_capacity_orig: ::aya_bpf::cty::c_ulong,
    pub cpu_capacity_inverted: ::aya_bpf::cty::c_ulong,
    pub balance_callback: *mut balance_callback,
    pub nohz_idle_balance: ::aya_bpf::cty::c_uchar,
    pub idle_balance: ::aya_bpf::cty::c_uchar,
    pub misfit_task_load: ::aya_bpf::cty::c_ulong,
    pub active_balance: ::aya_bpf::cty::c_int,
    pub push_cpu: ::aya_bpf::cty::c_int,
    pub active_balance_work: cpu_stop_work,
    pub cpu: ::aya_bpf::cty::c_int,
    pub online: ::aya_bpf::cty::c_int,
    pub cfs_tasks: list_head,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub avg_rt: sched_avg,
    pub avg_dl: sched_avg,
    pub idle_stamp: u64_,
    pub avg_idle: u64_,
    pub wake_stamp: ::aya_bpf::cty::c_ulong,
    pub wake_avg_idle: u64_,
    pub max_idle_balance_cost: u64_,
    pub hotplug_wait: rcuwait,
    pub prev_steal_time: u64_,
    pub calc_load_update: ::aya_bpf::cty::c_ulong,
    pub calc_load_active: ::aya_bpf::cty::c_long,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub hrtick_csd: call_single_data_t,
    pub hrtick_timer: hrtimer,
    pub hrtick_time: ktime_t,
    pub rq_sched_info: sched_info,
    pub rq_cpu_time: ::aya_bpf::cty::c_ulonglong,
    pub yld_count: ::aya_bpf::cty::c_uint,
    pub sched_count: ::aya_bpf::cty::c_uint,
    pub sched_goidle: ::aya_bpf::cty::c_uint,
    pub ttwu_count: ::aya_bpf::cty::c_uint,
    pub ttwu_local: ::aya_bpf::cty::c_uint,
    pub idle_state: *mut cpuidle_state,
    pub nr_pinned: ::aya_bpf::cty::c_uint,
    pub push_busy: ::aya_bpf::cty::c_uint,
    pub push_work: cpu_stop_work,
    pub core: *mut rq,
    pub core_pick: *mut task_struct,
    pub core_enabled: ::aya_bpf::cty::c_uint,
    pub core_sched_seq: ::aya_bpf::cty::c_uint,
    pub core_tree: rb_root,
    pub core_task_seq: ::aya_bpf::cty::c_uint,
    pub core_pick_seq: ::aya_bpf::cty::c_uint,
    pub core_cookie: ::aya_bpf::cty::c_ulong,
    pub core_forceidle_count: ::aya_bpf::cty::c_uint,
    pub core_forceidle_seq: ::aya_bpf::cty::c_uint,
    pub core_forceidle_occupation: ::aya_bpf::cty::c_uint,
    pub core_forceidle_start: u64_,
    pub scratch_mask: cpumask_var_t,
    pub _bitfield_align_6: [u8; 0],
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 40usize]>,
}
impl rq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_5() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_domain {
    pub em_pd: *mut em_perf_domain,
    pub next: *mut perf_domain,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct balance_callback {
    pub next: *mut balance_callback,
    pub func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_flags {
    pub flags: ::aya_bpf::cty::c_ulong,
    pub cookie: pin_cookie,
    pub clock_update_flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct affinity_context {
    pub new_mask: *const cpumask,
    pub user_mask: *mut cpumask,
    pub flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: ::aya_bpf::cty::c_uint,
    pub wait_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_run_ctx {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_array_item {
    pub prog: *mut bpf_prog,
    pub __bindgen_anon_1: bpf_prog_array_item__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_array_item__bindgen_ty_1 {
    pub cgroup_storage: [*mut bpf_cgroup_storage; 2usize],
    pub bpf_cookie: u64_,
}
#[repr(C)]
pub struct bpf_prog_array {
    pub rcu: callback_head,
    pub items: __IncompleteArrayField<bpf_prog_array_item>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_taskset {
    pub src_csets: list_head,
    pub dst_csets: list_head,
    pub nr_tasks: ::aya_bpf::cty::c_int,
    pub ssid: ::aya_bpf::cty::c_int,
    pub csets: *mut list_head,
    pub cur_cset: *mut css_set,
    pub cur_task: *mut task_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub off: __s16,
    pub imm: __s32,
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod bpf_cgroup_iter_order {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_CGROUP_ITER_ORDER_UNSPEC: Type = 0;
    pub const BPF_CGROUP_ITER_SELF_ONLY: Type = 1;
    pub const BPF_CGROUP_ITER_DESCENDANTS_PRE: Type = 2;
    pub const BPF_CGROUP_ITER_DESCENDANTS_POST: Type = 3;
    pub const BPF_CGROUP_ITER_ANCESTORS_UP: Type = 4;
}
pub mod bpf_map_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_MAP_TYPE_UNSPEC: Type = 0;
    pub const BPF_MAP_TYPE_HASH: Type = 1;
    pub const BPF_MAP_TYPE_ARRAY: Type = 2;
    pub const BPF_MAP_TYPE_PROG_ARRAY: Type = 3;
    pub const BPF_MAP_TYPE_PERF_EVENT_ARRAY: Type = 4;
    pub const BPF_MAP_TYPE_PERCPU_HASH: Type = 5;
    pub const BPF_MAP_TYPE_PERCPU_ARRAY: Type = 6;
    pub const BPF_MAP_TYPE_STACK_TRACE: Type = 7;
    pub const BPF_MAP_TYPE_CGROUP_ARRAY: Type = 8;
    pub const BPF_MAP_TYPE_LRU_HASH: Type = 9;
    pub const BPF_MAP_TYPE_LRU_PERCPU_HASH: Type = 10;
    pub const BPF_MAP_TYPE_LPM_TRIE: Type = 11;
    pub const BPF_MAP_TYPE_ARRAY_OF_MAPS: Type = 12;
    pub const BPF_MAP_TYPE_HASH_OF_MAPS: Type = 13;
    pub const BPF_MAP_TYPE_DEVMAP: Type = 14;
    pub const BPF_MAP_TYPE_SOCKMAP: Type = 15;
    pub const BPF_MAP_TYPE_CPUMAP: Type = 16;
    pub const BPF_MAP_TYPE_XSKMAP: Type = 17;
    pub const BPF_MAP_TYPE_SOCKHASH: Type = 18;
    pub const BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED: Type = 19;
    pub const BPF_MAP_TYPE_CGROUP_STORAGE: Type = 19;
    pub const BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: Type = 20;
    pub const BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: Type = 21;
    pub const BPF_MAP_TYPE_QUEUE: Type = 22;
    pub const BPF_MAP_TYPE_STACK: Type = 23;
    pub const BPF_MAP_TYPE_SK_STORAGE: Type = 24;
    pub const BPF_MAP_TYPE_DEVMAP_HASH: Type = 25;
    pub const BPF_MAP_TYPE_STRUCT_OPS: Type = 26;
    pub const BPF_MAP_TYPE_RINGBUF: Type = 27;
    pub const BPF_MAP_TYPE_INODE_STORAGE: Type = 28;
    pub const BPF_MAP_TYPE_TASK_STORAGE: Type = 29;
    pub const BPF_MAP_TYPE_BLOOM_FILTER: Type = 30;
    pub const BPF_MAP_TYPE_USER_RINGBUF: Type = 31;
    pub const BPF_MAP_TYPE_CGRP_STORAGE: Type = 32;
}
pub mod bpf_prog_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_PROG_TYPE_UNSPEC: Type = 0;
    pub const BPF_PROG_TYPE_SOCKET_FILTER: Type = 1;
    pub const BPF_PROG_TYPE_KPROBE: Type = 2;
    pub const BPF_PROG_TYPE_SCHED_CLS: Type = 3;
    pub const BPF_PROG_TYPE_SCHED_ACT: Type = 4;
    pub const BPF_PROG_TYPE_TRACEPOINT: Type = 5;
    pub const BPF_PROG_TYPE_XDP: Type = 6;
    pub const BPF_PROG_TYPE_PERF_EVENT: Type = 7;
    pub const BPF_PROG_TYPE_CGROUP_SKB: Type = 8;
    pub const BPF_PROG_TYPE_CGROUP_SOCK: Type = 9;
    pub const BPF_PROG_TYPE_LWT_IN: Type = 10;
    pub const BPF_PROG_TYPE_LWT_OUT: Type = 11;
    pub const BPF_PROG_TYPE_LWT_XMIT: Type = 12;
    pub const BPF_PROG_TYPE_SOCK_OPS: Type = 13;
    pub const BPF_PROG_TYPE_SK_SKB: Type = 14;
    pub const BPF_PROG_TYPE_CGROUP_DEVICE: Type = 15;
    pub const BPF_PROG_TYPE_SK_MSG: Type = 16;
    pub const BPF_PROG_TYPE_RAW_TRACEPOINT: Type = 17;
    pub const BPF_PROG_TYPE_CGROUP_SOCK_ADDR: Type = 18;
    pub const BPF_PROG_TYPE_LWT_SEG6LOCAL: Type = 19;
    pub const BPF_PROG_TYPE_LIRC_MODE2: Type = 20;
    pub const BPF_PROG_TYPE_SK_REUSEPORT: Type = 21;
    pub const BPF_PROG_TYPE_FLOW_DISSECTOR: Type = 22;
    pub const BPF_PROG_TYPE_CGROUP_SYSCTL: Type = 23;
    pub const BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: Type = 24;
    pub const BPF_PROG_TYPE_CGROUP_SOCKOPT: Type = 25;
    pub const BPF_PROG_TYPE_TRACING: Type = 26;
    pub const BPF_PROG_TYPE_STRUCT_OPS: Type = 27;
    pub const BPF_PROG_TYPE_EXT: Type = 28;
    pub const BPF_PROG_TYPE_LSM: Type = 29;
    pub const BPF_PROG_TYPE_SK_LOOKUP: Type = 30;
    pub const BPF_PROG_TYPE_SYSCALL: Type = 31;
}
pub mod bpf_attach_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_CGROUP_INET_INGRESS: Type = 0;
    pub const BPF_CGROUP_INET_EGRESS: Type = 1;
    pub const BPF_CGROUP_INET_SOCK_CREATE: Type = 2;
    pub const BPF_CGROUP_SOCK_OPS: Type = 3;
    pub const BPF_SK_SKB_STREAM_PARSER: Type = 4;
    pub const BPF_SK_SKB_STREAM_VERDICT: Type = 5;
    pub const BPF_CGROUP_DEVICE: Type = 6;
    pub const BPF_SK_MSG_VERDICT: Type = 7;
    pub const BPF_CGROUP_INET4_BIND: Type = 8;
    pub const BPF_CGROUP_INET6_BIND: Type = 9;
    pub const BPF_CGROUP_INET4_CONNECT: Type = 10;
    pub const BPF_CGROUP_INET6_CONNECT: Type = 11;
    pub const BPF_CGROUP_INET4_POST_BIND: Type = 12;
    pub const BPF_CGROUP_INET6_POST_BIND: Type = 13;
    pub const BPF_CGROUP_UDP4_SENDMSG: Type = 14;
    pub const BPF_CGROUP_UDP6_SENDMSG: Type = 15;
    pub const BPF_LIRC_MODE2: Type = 16;
    pub const BPF_FLOW_DISSECTOR: Type = 17;
    pub const BPF_CGROUP_SYSCTL: Type = 18;
    pub const BPF_CGROUP_UDP4_RECVMSG: Type = 19;
    pub const BPF_CGROUP_UDP6_RECVMSG: Type = 20;
    pub const BPF_CGROUP_GETSOCKOPT: Type = 21;
    pub const BPF_CGROUP_SETSOCKOPT: Type = 22;
    pub const BPF_TRACE_RAW_TP: Type = 23;
    pub const BPF_TRACE_FENTRY: Type = 24;
    pub const BPF_TRACE_FEXIT: Type = 25;
    pub const BPF_MODIFY_RETURN: Type = 26;
    pub const BPF_LSM_MAC: Type = 27;
    pub const BPF_TRACE_ITER: Type = 28;
    pub const BPF_CGROUP_INET4_GETPEERNAME: Type = 29;
    pub const BPF_CGROUP_INET6_GETPEERNAME: Type = 30;
    pub const BPF_CGROUP_INET4_GETSOCKNAME: Type = 31;
    pub const BPF_CGROUP_INET6_GETSOCKNAME: Type = 32;
    pub const BPF_XDP_DEVMAP: Type = 33;
    pub const BPF_CGROUP_INET_SOCK_RELEASE: Type = 34;
    pub const BPF_XDP_CPUMAP: Type = 35;
    pub const BPF_SK_LOOKUP: Type = 36;
    pub const BPF_XDP: Type = 37;
    pub const BPF_SK_SKB_VERDICT: Type = 38;
    pub const BPF_SK_REUSEPORT_SELECT: Type = 39;
    pub const BPF_SK_REUSEPORT_SELECT_OR_MIGRATE: Type = 40;
    pub const BPF_PERF_EVENT: Type = 41;
    pub const BPF_TRACE_KPROBE_MULTI: Type = 42;
    pub const BPF_LSM_CGROUP: Type = 43;
    pub const __MAX_BPF_ATTACH_TYPE: Type = 44;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub batch: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_5,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_6,
    pub test: bpf_attr__bindgen_ty_7,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_8,
    pub info: bpf_attr__bindgen_ty_9,
    pub query: bpf_attr__bindgen_ty_10,
    pub raw_tracepoint: bpf_attr__bindgen_ty_11,
    pub __bindgen_anon_7: bpf_attr__bindgen_ty_12,
    pub task_fd_query: bpf_attr__bindgen_ty_13,
    pub link_create: bpf_attr__bindgen_ty_14,
    pub link_update: bpf_attr__bindgen_ty_15,
    pub link_detach: bpf_attr__bindgen_ty_16,
    pub enable_stats: bpf_attr__bindgen_ty_17,
    pub iter_create: bpf_attr__bindgen_ty_18,
    pub prog_bind_map: bpf_attr__bindgen_ty_19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [::aya_bpf::cty::c_char; 16usize],
    pub map_ifindex: __u32,
    pub btf_fd: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub map_extra: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_3 {
    pub in_batch: __u64,
    pub out_batch: __u64,
    pub keys: __u64,
    pub values: __u64,
    pub count: __u32,
    pub map_fd: __u32,
    pub elem_flags: __u64,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_4 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [::aya_bpf::cty::c_char; 16usize],
    pub prog_ifindex: __u32,
    pub expected_attach_type: __u32,
    pub prog_btf_fd: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub func_info_cnt: __u32,
    pub line_info_rec_size: __u32,
    pub line_info: __u64,
    pub line_info_cnt: __u32,
    pub attach_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_4__bindgen_ty_1,
    pub core_relo_cnt: __u32,
    pub fd_array: __u64,
    pub core_relos: __u64,
    pub core_relo_rec_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    pub attach_prog_fd: __u32,
    pub attach_btf_obj_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_5 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
    pub file_flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_6 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
    pub replace_bpf_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_7 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
    pub ctx_size_in: __u32,
    pub ctx_size_out: __u32,
    pub ctx_in: __u64,
    pub ctx_out: __u64,
    pub flags: __u32,
    pub cpu: __u32,
    pub batch_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_8 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_8__bindgen_ty_1,
    pub next_id: __u32,
    pub open_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    pub btf_id: __u32,
    pub link_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_9 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_10 {
    pub target_fd: __u32,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub prog_cnt: __u32,
    pub prog_attach_flags: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_11 {
    pub name: __u64,
    pub prog_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_12 {
    pub btf: __u64,
    pub btf_log_buf: __u64,
    pub btf_size: __u32,
    pub btf_log_size: __u32,
    pub btf_log_level: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_13 {
    pub pid: __u32,
    pub fd: __u32,
    pub flags: __u32,
    pub buf_len: __u32,
    pub buf: __u64,
    pub prog_id: __u32,
    pub fd_type: __u32,
    pub probe_offset: __u64,
    pub probe_addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14 {
    pub prog_fd: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_1,
    pub attach_type: __u32,
    pub flags: __u32,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_14__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub target_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1,
    pub perf_event: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_2,
    pub kprobe_multi: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_3,
    pub tracing: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1 {
    pub iter_info: __u64,
    pub iter_info_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_2 {
    pub bpf_cookie: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_3 {
    pub flags: __u32,
    pub cnt: __u32,
    pub syms: __u64,
    pub addrs: __u64,
    pub cookies: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_4 {
    pub target_btf_id: __u32,
    pub cookie: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_15 {
    pub link_fd: __u32,
    pub new_prog_fd: __u32,
    pub flags: __u32,
    pub old_prog_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_16 {
    pub link_fd: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_17 {
    pub type_: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_18 {
    pub link_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_19 {
    pub prog_fd: __u32,
    pub map_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_info {
    pub insn_off: __u32,
    pub type_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_line_info {
    pub insn_off: __u32,
    pub file_name_off: __u32,
    pub line_off: __u32,
    pub line_col: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_filter {
    pub code: __u16,
    pub jt: __u8,
    pub jf: __u8,
    pub k: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct btf_id_set8 {
    pub cnt: u32_,
    pub flags: u32_,
    pub pairs: __IncompleteArrayField<btf_id_set8__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_id_set8__bindgen_ty_1 {
    pub id: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_type {
    pub name_off: __u32,
    pub info: __u32,
    pub __bindgen_anon_1: btf_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_type__bindgen_ty_1 {
    pub size: __u32,
    pub type_: __u32,
}
pub mod btf_field_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_SPIN_LOCK: Type = 1;
    pub const BPF_TIMER: Type = 2;
    pub const BPF_KPTR_UNREF: Type = 4;
    pub const BPF_KPTR_REF: Type = 8;
    pub const BPF_KPTR: Type = 12;
    pub const BPF_LIST_HEAD: Type = 16;
    pub const BPF_LIST_NODE: Type = 32;
}
pub type btf_dtor_kfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_field_kptr {
    pub btf: *mut btf,
    pub module: *mut module,
    pub dtor: btf_dtor_kfunc_t,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_field_list_head {
    pub btf: *mut btf,
    pub value_btf_id: u32_,
    pub node_offset: u32_,
    pub value_rec: *mut btf_record,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_field {
    pub offset: u32_,
    pub type_: btf_field_type::Type,
    pub __bindgen_anon_1: btf_field__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_field__bindgen_ty_1 {
    pub kptr: btf_field_kptr,
    pub list_head: btf_field_list_head,
}
#[repr(C)]
pub struct btf_record {
    pub cnt: u32_,
    pub field_mask: u32_,
    pub spin_lock_off: ::aya_bpf::cty::c_int,
    pub timer_off: ::aya_bpf::cty::c_int,
    pub fields: __IncompleteArrayField<btf_field>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_field_offs {
    pub cnt: u32_,
    pub field_off: [u32_; 10usize],
    pub field_sz: [u8_; 10usize],
}
pub type bpf_callback_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: u64_, arg2: u64_, arg3: u64_, arg4: u64_, arg5: u64_) -> u64_,
>;
pub type bpf_iter_init_seq_priv_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf::cty::c_void,
        arg2: *mut bpf_iter_aux_info,
    ) -> ::aya_bpf::cty::c_int,
>;
pub mod bpf_iter_task_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_TASK_ITER_ALL: Type = 0;
    pub const BPF_TASK_ITER_TID: Type = 1;
    pub const BPF_TASK_ITER_TGID: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_aux_info {
    pub map: *mut bpf_map,
    pub cgroup: bpf_iter_aux_info__bindgen_ty_1,
    pub task: bpf_iter_aux_info__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_1 {
    pub start: *mut cgroup,
    pub order: bpf_cgroup_iter_order::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_2 {
    pub type_: bpf_iter_task_type::Type,
    pub pid: u32_,
}
pub type bpf_iter_fini_seq_priv_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_iter_seq_info {
    pub seq_ops: *const seq_operations,
    pub init_seq_private: bpf_iter_init_seq_priv_t,
    pub fini_seq_private: bpf_iter_fini_seq_priv_t,
    pub seq_priv_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_ops {
    pub map_alloc_check:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> ::aya_bpf::cty::c_int>,
    pub map_alloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_attr) -> *mut bpf_map>,
    pub map_release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut file)>,
    pub map_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>,
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_release_uref: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map)>,
    pub map_lookup_elem_sys_only: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub map_lookup_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_lookup_and_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_lookup_and_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_update_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut file,
            arg3: *const bpf_attr,
            arg4: *mut bpf_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_push_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_pop_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_peek_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_lookup_percpu_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub map_fd_get_ptr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut file,
            arg3: ::aya_bpf::cty::c_int,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub map_fd_put_ptr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub map_gen_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_insn) -> ::aya_bpf::cty::c_int,
    >,
    pub map_fd_sys_lookup_elem:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> u32_>,
    pub map_seq_show_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut seq_file,
        ),
    >,
    pub map_check_btf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: *const btf,
            arg3: *const btf_type,
            arg4: *const btf_type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_poke_track: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_prog_aux) -> ::aya_bpf::cty::c_int,
    >,
    pub map_poke_untrack:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_map, arg2: *mut bpf_prog_aux)>,
    pub map_poke_run: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: u32_,
            arg3: *mut bpf_prog,
            arg4: *mut bpf_prog,
        ),
    >,
    pub map_direct_value_addr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: *mut u64_,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_direct_value_meta: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_map,
            arg2: u64_,
            arg3: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: *mut file,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub map_local_storage_charge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_local_storage_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_local_storage_uncharge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_local_storage_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
        ),
    >,
    pub map_owner_storage_ptr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> *mut *mut bpf_local_storage,
    >,
    pub map_redirect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_map, arg2: u64_, arg3: u64_) -> ::aya_bpf::cty::c_int,
    >,
    pub map_meta_equal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const bpf_map, arg2: *const bpf_map) -> bool_,
    >,
    pub map_set_for_each_callback_args: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: *mut bpf_func_state,
            arg3: *mut bpf_func_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_for_each_callback: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_map,
            arg2: bpf_callback_t,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_btf_id: *mut ::aya_bpf::cty::c_int,
    pub iter_seq_info: *const bpf_iter_seq_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map {
    pub ops: *const bpf_map_ops,
    pub inner_map_meta: *mut bpf_map,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub map_type: bpf_map_type::Type,
    pub key_size: u32_,
    pub value_size: u32_,
    pub max_entries: u32_,
    pub map_extra: u64_,
    pub map_flags: u32_,
    pub id: u32_,
    pub record: *mut btf_record,
    pub numa_node: ::aya_bpf::cty::c_int,
    pub btf_key_type_id: u32_,
    pub btf_value_type_id: u32_,
    pub btf_vmlinux_value_type_id: u32_,
    pub btf: *mut btf,
    pub objcg: *mut obj_cgroup,
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub field_offs: *mut btf_field_offs,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub refcnt: atomic64_t,
    pub usercnt: atomic64_t,
    pub work: work_struct,
    pub freeze_mutex: mutex,
    pub writecnt: atomic64_t,
    pub owner: bpf_map__bindgen_ty_1,
    pub bypass_spec_v1: bool_,
    pub frozen: bool_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub __bindgen_padding_0: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub type_: bpf_prog_type::Type,
    pub jited: bool_,
    pub xdp_has_frags: bool_,
}
impl bpf_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_header {
    pub magic: __u16,
    pub version: __u8,
    pub flags: __u8,
    pub hdr_len: __u32,
    pub type_off: __u32,
    pub type_len: __u32,
    pub str_off: __u32,
    pub str_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub types: *mut *mut btf_type,
    pub resolved_ids: *mut u32_,
    pub resolved_sizes: *mut u32_,
    pub strings: *const ::aya_bpf::cty::c_char,
    pub nohdr_data: *mut ::aya_bpf::cty::c_void,
    pub hdr: btf_header,
    pub nr_types: u32_,
    pub types_size: u32_,
    pub data_size: u32_,
    pub refcnt: refcount_t,
    pub id: u32_,
    pub rcu: callback_head,
    pub kfunc_set_tab: *mut btf_kfunc_set_tab,
    pub dtor_kfunc_tab: *mut btf_id_dtor_kfunc_tab,
    pub struct_meta_tab: *mut btf_struct_metas,
    pub base_btf: *mut btf,
    pub start_id: u32_,
    pub start_str_off: u32_,
    pub name: [::aya_bpf::cty::c_char; 56usize],
    pub kernel_btf: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_ksym {
    pub start: ::aya_bpf::cty::c_ulong,
    pub end: ::aya_bpf::cty::c_ulong,
    pub name: [::aya_bpf::cty::c_char; 512usize],
    pub lnode: list_head,
    pub tnode: latch_tree_node,
    pub prog: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    pub refcnt: atomic64_t,
    pub used_map_cnt: u32_,
    pub used_btf_cnt: u32_,
    pub max_ctx_offset: u32_,
    pub max_pkt_offset: u32_,
    pub max_tp_access: u32_,
    pub stack_depth: u32_,
    pub id: u32_,
    pub func_cnt: u32_,
    pub func_idx: u32_,
    pub attach_btf_id: u32_,
    pub ctx_arg_info_size: u32_,
    pub max_rdonly_access: u32_,
    pub max_rdwr_access: u32_,
    pub attach_btf: *mut btf,
    pub ctx_arg_info: *const bpf_ctx_arg_aux,
    pub dst_mutex: mutex,
    pub dst_prog: *mut bpf_prog,
    pub dst_trampoline: *mut bpf_trampoline,
    pub saved_dst_prog_type: bpf_prog_type::Type,
    pub saved_dst_attach_type: bpf_attach_type::Type,
    pub verifier_zext: bool_,
    pub offload_requested: bool_,
    pub attach_btf_trace: bool_,
    pub func_proto_unreliable: bool_,
    pub sleepable: bool_,
    pub tail_call_reachable: bool_,
    pub xdp_has_frags: bool_,
    pub attach_func_proto: *const btf_type,
    pub attach_func_name: *const ::aya_bpf::cty::c_char,
    pub func: *mut *mut bpf_prog,
    pub jit_data: *mut ::aya_bpf::cty::c_void,
    pub poke_tab: *mut bpf_jit_poke_descriptor,
    pub kfunc_tab: *mut bpf_kfunc_desc_tab,
    pub kfunc_btf_tab: *mut bpf_kfunc_btf_tab,
    pub size_poke_tab: u32_,
    pub ksym: bpf_ksym,
    pub ops: *const bpf_prog_ops,
    pub used_maps: *mut *mut bpf_map,
    pub used_maps_mutex: mutex,
    pub used_btfs: *mut btf_mod_pair,
    pub prog: *mut bpf_prog,
    pub user: *mut user_struct,
    pub load_time: u64_,
    pub verified_insns: u32_,
    pub cgroup_atype: ::aya_bpf::cty::c_int,
    pub cgroup_storage: [*mut bpf_map; 2usize],
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub security: *mut ::aya_bpf::cty::c_void,
    pub offload: *mut bpf_prog_offload,
    pub btf: *mut btf,
    pub func_info: *mut bpf_func_info,
    pub func_info_aux: *mut bpf_func_info_aux,
    pub linfo: *mut bpf_line_info,
    pub jited_linfo: *mut *mut ::aya_bpf::cty::c_void,
    pub func_info_cnt: u32_,
    pub nr_linfo: u32_,
    pub linfo_idx: u32_,
    pub num_exentries: u32_,
    pub extable: *mut exception_table_entry,
    pub __bindgen_anon_1: bpf_prog_aux__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_aux__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
}
#[repr(C)]
pub struct bpf_prog {
    pub pages: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub type_: bpf_prog_type::Type,
    pub expected_attach_type: bpf_attach_type::Type,
    pub len: u32_,
    pub jited_len: u32_,
    pub tag: [u8_; 8usize],
    pub stats: *mut bpf_prog_stats,
    pub active: *mut ::aya_bpf::cty::c_int,
    pub bpf_func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_void,
            arg2: *const bpf_insn,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub aux: *mut bpf_prog_aux,
    pub orig_prog: *mut sock_fprog_kern,
    pub __bindgen_anon_1: bpf_prog__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_prog__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 0usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_insns: bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub insns: __IncompleteArrayField<sock_filter>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_insnsi: bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub insnsi: __IncompleteArrayField<bpf_insn>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
impl bpf_prog {
    #[inline]
    pub fn jited(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jited(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jit_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jit_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpl_compatible(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cb_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cb_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_needed(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dst_needed(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinding_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinding_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinded(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinded(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_func(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_func(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kprobe_override(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kprobe_override(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_callchain_buf(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_has_callchain_buf(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enforce_expected_attach_type(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enforce_expected_attach_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn call_get_stack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_stack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn call_get_func_ip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_func_ip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_type_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_type_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        jited: u16_,
        jit_requested: u16_,
        gpl_compatible: u16_,
        cb_access: u16_,
        dst_needed: u16_,
        blinding_requested: u16_,
        blinded: u16_,
        is_func: u16_,
        kprobe_override: u16_,
        has_callchain_buf: u16_,
        enforce_expected_attach_type: u16_,
        call_get_stack: u16_,
        call_get_func_ip: u16_,
        tstamp_type_access: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let jited: u16 = unsafe { ::core::mem::transmute(jited) };
            jited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jit_requested: u16 = unsafe { ::core::mem::transmute(jit_requested) };
            jit_requested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gpl_compatible: u16 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cb_access: u16 = unsafe { ::core::mem::transmute(cb_access) };
            cb_access as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_needed: u16 = unsafe { ::core::mem::transmute(dst_needed) };
            dst_needed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blinding_requested: u16 = unsafe { ::core::mem::transmute(blinding_requested) };
            blinding_requested as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let blinded: u16 = unsafe { ::core::mem::transmute(blinded) };
            blinded as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_func: u16 = unsafe { ::core::mem::transmute(is_func) };
            is_func as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let kprobe_override: u16 = unsafe { ::core::mem::transmute(kprobe_override) };
            kprobe_override as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_callchain_buf: u16 = unsafe { ::core::mem::transmute(has_callchain_buf) };
            has_callchain_buf as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enforce_expected_attach_type: u16 =
                unsafe { ::core::mem::transmute(enforce_expected_attach_type) };
            enforce_expected_attach_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let call_get_stack: u16 = unsafe { ::core::mem::transmute(call_get_stack) };
            call_get_stack as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let call_get_func_ip: u16 = unsafe { ::core::mem::transmute(call_get_func_ip) };
            call_get_func_ip as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tstamp_type_access: u16 = unsafe { ::core::mem::transmute(tstamp_type_access) };
            tstamp_type_access as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod bpf_type_flag {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PTR_MAYBE_NULL: Type = 256;
    pub const MEM_RDONLY: Type = 512;
    pub const MEM_RINGBUF: Type = 1024;
    pub const MEM_USER: Type = 2048;
    pub const MEM_PERCPU: Type = 4096;
    pub const OBJ_RELEASE: Type = 8192;
    pub const PTR_UNTRUSTED: Type = 16384;
    pub const MEM_UNINIT: Type = 32768;
    pub const DYNPTR_TYPE_LOCAL: Type = 65536;
    pub const DYNPTR_TYPE_RINGBUF: Type = 131072;
    pub const MEM_FIXED_SIZE: Type = 262144;
    pub const MEM_ALLOC: Type = 524288;
    pub const PTR_TRUSTED: Type = 1048576;
    pub const MEM_RCU: Type = 2097152;
    pub const __BPF_TYPE_FLAG_MAX: Type = 2097153;
    pub const __BPF_TYPE_LAST_FLAG: Type = 2097152;
}
pub mod bpf_arg_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ARG_DONTCARE: Type = 0;
    pub const ARG_CONST_MAP_PTR: Type = 1;
    pub const ARG_PTR_TO_MAP_KEY: Type = 2;
    pub const ARG_PTR_TO_MAP_VALUE: Type = 3;
    pub const ARG_PTR_TO_MEM: Type = 4;
    pub const ARG_CONST_SIZE: Type = 5;
    pub const ARG_CONST_SIZE_OR_ZERO: Type = 6;
    pub const ARG_PTR_TO_CTX: Type = 7;
    pub const ARG_ANYTHING: Type = 8;
    pub const ARG_PTR_TO_SPIN_LOCK: Type = 9;
    pub const ARG_PTR_TO_SOCK_COMMON: Type = 10;
    pub const ARG_PTR_TO_INT: Type = 11;
    pub const ARG_PTR_TO_LONG: Type = 12;
    pub const ARG_PTR_TO_SOCKET: Type = 13;
    pub const ARG_PTR_TO_BTF_ID: Type = 14;
    pub const ARG_PTR_TO_RINGBUF_MEM: Type = 15;
    pub const ARG_CONST_ALLOC_SIZE_OR_ZERO: Type = 16;
    pub const ARG_PTR_TO_BTF_ID_SOCK_COMMON: Type = 17;
    pub const ARG_PTR_TO_PERCPU_BTF_ID: Type = 18;
    pub const ARG_PTR_TO_FUNC: Type = 19;
    pub const ARG_PTR_TO_STACK: Type = 20;
    pub const ARG_PTR_TO_CONST_STR: Type = 21;
    pub const ARG_PTR_TO_TIMER: Type = 22;
    pub const ARG_PTR_TO_KPTR: Type = 23;
    pub const ARG_PTR_TO_DYNPTR: Type = 24;
    pub const __BPF_ARG_TYPE_MAX: Type = 25;
    pub const ARG_PTR_TO_MAP_VALUE_OR_NULL: Type = 259;
    pub const ARG_PTR_TO_MEM_OR_NULL: Type = 260;
    pub const ARG_PTR_TO_CTX_OR_NULL: Type = 263;
    pub const ARG_PTR_TO_SOCKET_OR_NULL: Type = 269;
    pub const ARG_PTR_TO_STACK_OR_NULL: Type = 276;
    pub const ARG_PTR_TO_BTF_ID_OR_NULL: Type = 270;
    pub const ARG_PTR_TO_UNINIT_MEM: Type = 32772;
    pub const ARG_PTR_TO_FIXED_SIZE_MEM: Type = 262148;
    pub const __BPF_ARG_TYPE_LIMIT: Type = 4194303;
}
pub mod bpf_return_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RET_INTEGER: Type = 0;
    pub const RET_VOID: Type = 1;
    pub const RET_PTR_TO_MAP_VALUE: Type = 2;
    pub const RET_PTR_TO_SOCKET: Type = 3;
    pub const RET_PTR_TO_TCP_SOCK: Type = 4;
    pub const RET_PTR_TO_SOCK_COMMON: Type = 5;
    pub const RET_PTR_TO_MEM: Type = 6;
    pub const RET_PTR_TO_MEM_OR_BTF_ID: Type = 7;
    pub const RET_PTR_TO_BTF_ID: Type = 8;
    pub const __BPF_RET_TYPE_MAX: Type = 9;
    pub const RET_PTR_TO_MAP_VALUE_OR_NULL: Type = 258;
    pub const RET_PTR_TO_SOCKET_OR_NULL: Type = 259;
    pub const RET_PTR_TO_TCP_SOCK_OR_NULL: Type = 260;
    pub const RET_PTR_TO_SOCK_COMMON_OR_NULL: Type = 261;
    pub const RET_PTR_TO_RINGBUF_MEM_OR_NULL: Type = 1286;
    pub const RET_PTR_TO_DYNPTR_MEM_OR_NULL: Type = 262;
    pub const RET_PTR_TO_BTF_ID_OR_NULL: Type = 264;
    pub const RET_PTR_TO_BTF_ID_TRUSTED: Type = 1048584;
    pub const __BPF_RET_TYPE_LIMIT: Type = 4194303;
}
pub mod bpf_reg_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NOT_INIT: Type = 0;
    pub const SCALAR_VALUE: Type = 1;
    pub const PTR_TO_CTX: Type = 2;
    pub const CONST_PTR_TO_MAP: Type = 3;
    pub const PTR_TO_MAP_VALUE: Type = 4;
    pub const PTR_TO_MAP_KEY: Type = 5;
    pub const PTR_TO_STACK: Type = 6;
    pub const PTR_TO_PACKET_META: Type = 7;
    pub const PTR_TO_PACKET: Type = 8;
    pub const PTR_TO_PACKET_END: Type = 9;
    pub const PTR_TO_FLOW_KEYS: Type = 10;
    pub const PTR_TO_SOCKET: Type = 11;
    pub const PTR_TO_SOCK_COMMON: Type = 12;
    pub const PTR_TO_TCP_SOCK: Type = 13;
    pub const PTR_TO_TP_BUFFER: Type = 14;
    pub const PTR_TO_XDP_SOCK: Type = 15;
    pub const PTR_TO_BTF_ID: Type = 16;
    pub const PTR_TO_MEM: Type = 17;
    pub const PTR_TO_BUF: Type = 18;
    pub const PTR_TO_FUNC: Type = 19;
    pub const CONST_PTR_TO_DYNPTR: Type = 20;
    pub const __BPF_REG_TYPE_MAX: Type = 21;
    pub const PTR_TO_MAP_VALUE_OR_NULL: Type = 260;
    pub const PTR_TO_SOCKET_OR_NULL: Type = 267;
    pub const PTR_TO_SOCK_COMMON_OR_NULL: Type = 268;
    pub const PTR_TO_TCP_SOCK_OR_NULL: Type = 269;
    pub const PTR_TO_BTF_ID_OR_NULL: Type = 272;
    pub const __BPF_REG_TYPE_LIMIT: Type = 4194303;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_ops {
    pub test_run: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_prog,
            arg2: *const bpf_attr,
            arg3: *mut bpf_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_offload {
    pub prog: *mut bpf_prog,
    pub netdev: *mut net_device,
    pub offdev: *mut bpf_offload_dev,
    pub dev_priv: *mut ::aya_bpf::cty::c_void,
    pub offloads: list_head,
    pub dev_state: bool_,
    pub opt_failed: bool_,
    pub jited_image: *mut ::aya_bpf::cty::c_void,
    pub jited_len: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_func_model {
    pub ret_size: u8_,
    pub nr_args: u8_,
    pub arg_size: [u8_; 12usize],
    pub arg_flags: [u8_; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_image {
    pub image: *mut ::aya_bpf::cty::c_void,
    pub ksym: bpf_ksym,
    pub pcref: percpu_ref,
    pub ip_after_call: *mut ::aya_bpf::cty::c_void,
    pub ip_epilogue: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: bpf_tramp_image__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tramp_image__bindgen_ty_1 {
    pub rcu: callback_head,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline {
    pub hlist: hlist_node,
    pub fops: *mut ftrace_ops,
    pub mutex: mutex,
    pub refcnt: refcount_t,
    pub flags: u32_,
    pub key: u64_,
    pub func: bpf_trampoline__bindgen_ty_1,
    pub extension_prog: *mut bpf_prog,
    pub progs_hlist: [hlist_head; 3usize],
    pub progs_cnt: [::aya_bpf::cty::c_int; 3usize],
    pub cur_image: *mut bpf_tramp_image,
    pub selector: u64_,
    pub mod_: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_trampoline__bindgen_ty_1 {
    pub model: btf_func_model,
    pub addr: *mut ::aya_bpf::cty::c_void,
    pub ftrace_managed: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_info_aux {
    pub linkage: u16_,
    pub unreliable: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor {
    pub tailcall_target: *mut ::aya_bpf::cty::c_void,
    pub tailcall_bypass: *mut ::aya_bpf::cty::c_void,
    pub bypass_addr: *mut ::aya_bpf::cty::c_void,
    pub aux: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: bpf_jit_poke_descriptor__bindgen_ty_1,
    pub tailcall_target_stable: bool_,
    pub adj_off: u8_,
    pub reason: u16_,
    pub insn_idx: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_jit_poke_descriptor__bindgen_ty_1 {
    pub tail_call: bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub map: *mut bpf_map,
    pub key: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_ctx_arg_aux {
    pub offset: u32_,
    pub reg_type: bpf_reg_type::Type,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_mod_pair {
    pub btf: *mut btf,
    pub module: *mut module,
}
pub type __kernel_mqd_t = ::aya_bpf::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::aya_bpf::cty::c_int; 2usize],
}
pub type mqd_t = __kernel_mqd_t;
pub mod audit_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const AUDIT_STATE_DISABLED: Type = 0;
    pub const AUDIT_STATE_BUILD: Type = 1;
    pub const AUDIT_STATE_RECORD: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_cap_data {
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
    pub __bindgen_anon_1: audit_cap_data__bindgen_ty_1,
    pub ambient: kernel_cap_t,
    pub rootid: kuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union audit_cap_data__bindgen_ty_1 {
    pub fE: ::aya_bpf::cty::c_uint,
    pub effective: kernel_cap_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_names {
    pub list: list_head,
    pub name: *mut filename,
    pub name_len: ::aya_bpf::cty::c_int,
    pub hidden: bool_,
    pub ino: ::aya_bpf::cty::c_ulong,
    pub dev: dev_t,
    pub mode: umode_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub rdev: dev_t,
    pub osid: u32_,
    pub fcap: audit_cap_data,
    pub fcap_ver: ::aya_bpf::cty::c_uint,
    pub type_: ::aya_bpf::cty::c_uchar,
    pub should_free: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mq_attr {
    pub mq_flags: __kernel_long_t,
    pub mq_maxmsg: __kernel_long_t,
    pub mq_msgsize: __kernel_long_t,
    pub mq_curmsgs: __kernel_long_t,
    pub __reserved: [__kernel_long_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_ntp_val {
    pub oldval: ::aya_bpf::cty::c_longlong,
    pub newval: ::aya_bpf::cty::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_ntp_data {
    pub vals: [audit_ntp_val; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_proctitle {
    pub len: ::aya_bpf::cty::c_int,
    pub value: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context {
    pub dummy: ::aya_bpf::cty::c_int,
    pub context: audit_context__bindgen_ty_1::Type,
    pub state: audit_state::Type,
    pub current_state: audit_state::Type,
    pub serial: ::aya_bpf::cty::c_uint,
    pub major: ::aya_bpf::cty::c_int,
    pub uring_op: ::aya_bpf::cty::c_int,
    pub ctime: timespec64,
    pub argv: [::aya_bpf::cty::c_ulong; 4usize],
    pub return_code: ::aya_bpf::cty::c_long,
    pub prio: u64_,
    pub return_valid: ::aya_bpf::cty::c_int,
    pub preallocated_names: [audit_names; 5usize],
    pub name_count: ::aya_bpf::cty::c_int,
    pub names_list: list_head,
    pub filterkey: *mut ::aya_bpf::cty::c_char,
    pub pwd: path,
    pub aux: *mut audit_aux_data,
    pub aux_pids: *mut audit_aux_data,
    pub sockaddr: *mut __kernel_sockaddr_storage,
    pub sockaddr_len: usize,
    pub ppid: pid_t,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub suid: kuid_t,
    pub fsuid: kuid_t,
    pub gid: kgid_t,
    pub egid: kgid_t,
    pub sgid: kgid_t,
    pub fsgid: kgid_t,
    pub personality: ::aya_bpf::cty::c_ulong,
    pub arch: ::aya_bpf::cty::c_int,
    pub target_pid: pid_t,
    pub target_auid: kuid_t,
    pub target_uid: kuid_t,
    pub target_sessionid: ::aya_bpf::cty::c_uint,
    pub target_sid: u32_,
    pub target_comm: [::aya_bpf::cty::c_char; 16usize],
    pub trees: *mut audit_tree_refs,
    pub first_trees: *mut audit_tree_refs,
    pub killed_trees: list_head,
    pub tree_count: ::aya_bpf::cty::c_int,
    pub type_: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_1: audit_context__bindgen_ty_2,
    pub fds: [::aya_bpf::cty::c_int; 2usize],
    pub proctitle: audit_proctitle,
}
pub mod audit_context__bindgen_ty_1 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const AUDIT_CTX_UNUSED: Type = 0;
    pub const AUDIT_CTX_SYSCALL: Type = 1;
    pub const AUDIT_CTX_URING: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union audit_context__bindgen_ty_2 {
    pub socketcall: audit_context__bindgen_ty_2__bindgen_ty_1,
    pub ipc: audit_context__bindgen_ty_2__bindgen_ty_2,
    pub mq_getsetattr: audit_context__bindgen_ty_2__bindgen_ty_3,
    pub mq_notify: audit_context__bindgen_ty_2__bindgen_ty_4,
    pub mq_sendrecv: audit_context__bindgen_ty_2__bindgen_ty_5,
    pub mq_open: audit_context__bindgen_ty_2__bindgen_ty_6,
    pub capset: audit_context__bindgen_ty_2__bindgen_ty_7,
    pub mmap: audit_context__bindgen_ty_2__bindgen_ty_8,
    pub openat2: open_how,
    pub execve: audit_context__bindgen_ty_2__bindgen_ty_9,
    pub module: audit_context__bindgen_ty_2__bindgen_ty_10,
    pub time: audit_context__bindgen_ty_2__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_1 {
    pub nargs: ::aya_bpf::cty::c_int,
    pub args: [::aya_bpf::cty::c_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_2 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub mode: umode_t,
    pub osid: u32_,
    pub has_perm: ::aya_bpf::cty::c_int,
    pub perm_uid: uid_t,
    pub perm_gid: gid_t,
    pub perm_mode: umode_t,
    pub qbytes: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_3 {
    pub mqdes: mqd_t,
    pub mqstat: mq_attr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_4 {
    pub mqdes: mqd_t,
    pub sigev_signo: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_5 {
    pub mqdes: mqd_t,
    pub msg_len: usize,
    pub msg_prio: ::aya_bpf::cty::c_uint,
    pub abs_timeout: timespec64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_6 {
    pub oflag: ::aya_bpf::cty::c_int,
    pub mode: umode_t,
    pub attr: mq_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_7 {
    pub pid: pid_t,
    pub cap: audit_cap_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_8 {
    pub fd: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_9 {
    pub argc: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_10 {
    pub name: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context__bindgen_ty_2__bindgen_ty_11 {
    pub ntp_data: audit_ntp_data,
    pub tk_injoffset: timespec64,
}
pub type fsnotify_connp_t = *mut fsnotify_mark_connector;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    pub lock: spinlock_t,
    pub type_: ::aya_bpf::cty::c_ushort,
    pub flags: ::aya_bpf::cty::c_ushort,
    pub fsid: __kernel_fsid_t,
    pub __bindgen_anon_1: fsnotify_mark_connector__bindgen_ty_1,
    pub list: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fsnotify_mark_connector__bindgen_ty_1 {
    pub obj: *mut fsnotify_connp_t,
    pub destroy_next: *mut fsnotify_mark_connector,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark {
    pub mask: __u32,
    pub refcnt: refcount_t,
    pub group: *mut fsnotify_group,
    pub g_list: list_head,
    pub lock: spinlock_t,
    pub obj_list: hlist_node,
    pub connector: *mut fsnotify_mark_connector,
    pub ignore_mask: __u32,
    pub flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_ops {
    pub handle_event: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fsnotify_group,
            arg2: u32_,
            arg3: *const ::aya_bpf::cty::c_void,
            arg4: ::aya_bpf::cty::c_int,
            arg5: *mut inode,
            arg6: *const qstr,
            arg7: u32_,
            arg8: *mut fsnotify_iter_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub handle_inode_event: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fsnotify_mark,
            arg2: u32_,
            arg3: *mut inode,
            arg4: *mut inode,
            arg5: *const qstr,
            arg6: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free_group_priv: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fsnotify_group)>,
    pub freeing_mark: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fsnotify_mark, arg2: *mut fsnotify_group),
    >,
    pub free_event: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fsnotify_group, arg2: *mut fsnotify_event),
    >,
    pub free_mark: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fsnotify_mark)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inotify_group_private_data {
    pub idr_lock: spinlock_t,
    pub idr: idr,
    pub ucounts: *mut ucounts,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fanotify_group_private_data {
    pub merge_hash: *mut hlist_head,
    pub access_list: list_head,
    pub access_waitq: wait_queue_head_t,
    pub flags: ::aya_bpf::cty::c_int,
    pub f_flags: ::aya_bpf::cty::c_int,
    pub ucounts: *mut ucounts,
    pub error_events_pool: mempool_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_group {
    pub ops: *const fsnotify_ops,
    pub refcnt: refcount_t,
    pub notification_lock: spinlock_t,
    pub notification_list: list_head,
    pub notification_waitq: wait_queue_head_t,
    pub q_len: ::aya_bpf::cty::c_uint,
    pub max_events: ::aya_bpf::cty::c_uint,
    pub priority: ::aya_bpf::cty::c_uint,
    pub shutdown: bool_,
    pub flags: ::aya_bpf::cty::c_int,
    pub owner_flags: ::aya_bpf::cty::c_uint,
    pub mark_mutex: mutex,
    pub user_waits: atomic_t,
    pub marks_list: list_head,
    pub fsn_fa: *mut fasync_struct,
    pub overflow_event: *mut fsnotify_event,
    pub memcg: *mut mem_cgroup,
    pub __bindgen_anon_1: fsnotify_group__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fsnotify_group__bindgen_ty_1 {
    pub private: *mut ::aya_bpf::cty::c_void,
    pub inotify_data: inotify_group_private_data,
    pub fanotify_data: fanotify_group_private_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_iter_info {
    pub marks: [*mut fsnotify_mark; 5usize],
    pub current_group: *mut fsnotify_group,
    pub report_mask: ::aya_bpf::cty::c_uint,
    pub srcu_idx: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_event {
    pub list: list_head,
}
pub type __kernel_sa_family_t = ::aya_bpf::cty::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::aya_bpf::cty::c_char; 126usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_icounter_struct {
    pub cts: ::aya_bpf::cty::c_int,
    pub dsr: ::aya_bpf::cty::c_int,
    pub rng: ::aya_bpf::cty::c_int,
    pub dcd: ::aya_bpf::cty::c_int,
    pub rx: ::aya_bpf::cty::c_int,
    pub tx: ::aya_bpf::cty::c_int,
    pub frame: ::aya_bpf::cty::c_int,
    pub overrun: ::aya_bpf::cty::c_int,
    pub parity: ::aya_bpf::cty::c_int,
    pub brk: ::aya_bpf::cty::c_int,
    pub buf_overrun: ::aya_bpf::cty::c_int,
    pub reserved: [::aya_bpf::cty::c_int; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_struct {
    pub type_: ::aya_bpf::cty::c_int,
    pub line: ::aya_bpf::cty::c_int,
    pub port: ::aya_bpf::cty::c_uint,
    pub irq: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub xmit_fifo_size: ::aya_bpf::cty::c_int,
    pub custom_divisor: ::aya_bpf::cty::c_int,
    pub baud_base: ::aya_bpf::cty::c_int,
    pub close_delay: ::aya_bpf::cty::c_ushort,
    pub io_type: ::aya_bpf::cty::c_char,
    pub reserved_char: [::aya_bpf::cty::c_char; 1usize],
    pub hub6: ::aya_bpf::cty::c_int,
    pub closing_wait: ::aya_bpf::cty::c_ushort,
    pub closing_wait2: ::aya_bpf::cty::c_ushort,
    pub iomem_base: *mut ::aya_bpf::cty::c_uchar,
    pub iomem_reg_shift: ::aya_bpf::cty::c_ushort,
    pub port_high: ::aya_bpf::cty::c_uint,
    pub iomap_base: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rchan_buf {
    pub start: *mut ::aya_bpf::cty::c_void,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub offset: usize,
    pub subbufs_produced: usize,
    pub subbufs_consumed: usize,
    pub chan: *mut rchan,
    pub read_wait: wait_queue_head_t,
    pub wakeup_work: irq_work,
    pub dentry: *mut dentry,
    pub kref: kref,
    pub page_array: *mut *mut page,
    pub page_count: ::aya_bpf::cty::c_uint,
    pub finalized: ::aya_bpf::cty::c_uint,
    pub padding: *mut usize,
    pub prev_padding: usize,
    pub bytes_consumed: usize,
    pub early_bytes: usize,
    pub cpu: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub __bindgen_padding_0: u32,
}
impl rchan_buf {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rchan {
    pub version: u32_,
    pub subbuf_size: usize,
    pub n_subbufs: usize,
    pub alloc_size: usize,
    pub cb: *const rchan_callbacks,
    pub kref: kref,
    pub private_data: *mut ::aya_bpf::cty::c_void,
    pub last_toobig: usize,
    pub buf: *mut *mut rchan_buf,
    pub is_global: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub parent: *mut dentry,
    pub has_base_filename: ::aya_bpf::cty::c_int,
    pub base_filename: [::aya_bpf::cty::c_char; 255usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rchan_callbacks {
    pub subbuf_start: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rchan_buf,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create_buf_file: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: *mut dentry,
            arg3: umode_t,
            arg4: *mut rchan_buf,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> *mut dentry,
    >,
    pub remove_buf_file:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::aya_bpf::cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_hash {
    pub size_bits: ::aya_bpf::cty::c_ulong,
    pub buckets: *mut hlist_head,
    pub count: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_filter {
    pub prog: *mut prog_entry,
    pub filter_string: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct array_buffer {
    pub tr: *mut trace_array,
    pub buffer: *mut trace_buffer,
    pub data: *mut trace_array_cpu,
    pub time_start: u64_,
    pub cpu: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_array {
    pub list: list_head,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub array_buffer: array_buffer,
    pub max_buffer: array_buffer,
    pub allocated_snapshot: bool_,
    pub max_latency: ::aya_bpf::cty::c_ulong,
    pub d_max_latency: *mut dentry,
    pub fsnotify_work: work_struct,
    pub fsnotify_irqwork: irq_work,
    pub filtered_pids: *mut trace_pid_list,
    pub filtered_no_pids: *mut trace_pid_list,
    pub max_lock: arch_spinlock_t,
    pub buffer_disabled: ::aya_bpf::cty::c_int,
    pub sys_refcount_enter: ::aya_bpf::cty::c_int,
    pub sys_refcount_exit: ::aya_bpf::cty::c_int,
    pub enter_syscall_files: [*mut trace_event_file; 451usize],
    pub exit_syscall_files: [*mut trace_event_file; 451usize],
    pub stop_count: ::aya_bpf::cty::c_int,
    pub clock_id: ::aya_bpf::cty::c_int,
    pub nr_topts: ::aya_bpf::cty::c_int,
    pub clear_trace: bool_,
    pub buffer_percent: ::aya_bpf::cty::c_int,
    pub n_err_log_entries: ::aya_bpf::cty::c_uint,
    pub current_trace: *mut tracer,
    pub trace_flags: ::aya_bpf::cty::c_uint,
    pub trace_flags_index: [::aya_bpf::cty::c_uchar; 32usize],
    pub flags: ::aya_bpf::cty::c_uint,
    pub start_lock: raw_spinlock_t,
    pub err_log: list_head,
    pub dir: *mut dentry,
    pub options: *mut dentry,
    pub percpu_dir: *mut dentry,
    pub event_dir: *mut dentry,
    pub topts: *mut trace_options,
    pub systems: list_head,
    pub events: list_head,
    pub trace_marker_file: *mut trace_event_file,
    pub tracing_cpumask: cpumask_var_t,
    pub ref_: ::aya_bpf::cty::c_int,
    pub trace_ref: ::aya_bpf::cty::c_int,
    pub ops: *mut ftrace_ops,
    pub function_pids: *mut trace_pid_list,
    pub function_no_pids: *mut trace_pid_list,
    pub func_probes: list_head,
    pub mod_trace: list_head,
    pub mod_notrace: list_head,
    pub function_enabled: ::aya_bpf::cty::c_int,
    pub no_filter_buffering_ref: ::aya_bpf::cty::c_int,
    pub hist_vars: list_head,
    pub cond_snapshot: *mut cond_snapshot,
    pub last_func_repeats: *mut trace_func_repeats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer {
    pub name: *const ::aya_bpf::cty::c_char,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf::cty::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_array)>,
    pub update_thresh: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_array) -> ::aya_bpf::cty::c_int,
    >,
    pub open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub pipe_open: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub pipe_close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut trace_iterator)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_iterator,
            arg2: *mut file,
            arg3: *mut ::aya_bpf::cty::c_char,
            arg4: usize,
            arg5: *mut loff_t,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_iterator,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: *mut pipe_inode_info,
            arg5: usize,
            arg6: ::aya_bpf::cty::c_uint,
        ) -> isize,
    >,
    pub print_header: ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file)>,
    pub print_line: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut trace_iterator) -> print_line_t::Type,
    >,
    pub set_flag: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_array,
            arg2: u32_,
            arg3: u32_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flag_changed: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut trace_array,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub next: *mut tracer,
    pub flags: *mut tracer_flags,
    pub enabled: ::aya_bpf::cty::c_int,
    pub print_max: bool_,
    pub allow_instances: bool_,
    pub use_max_tr: bool_,
    pub noboot: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_subsystem_dir {
    pub list: list_head,
    pub subsystem: *mut event_subsystem,
    pub tr: *mut trace_array,
    pub entry: *mut dentry,
    pub ref_count: ::aya_bpf::cty::c_int,
    pub nr_events: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lower_chunk {
    pub next: *mut lower_chunk,
    pub data: [::aya_bpf::cty::c_ulong; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union upper_chunk {
    pub next: *mut upper_chunk,
    pub data: [*mut lower_chunk; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_pid_list {
    pub lock: raw_spinlock_t,
    pub refill_irqwork: irq_work,
    pub upper: [*mut upper_chunk; 256usize],
    pub upper_list: *mut upper_chunk,
    pub lower_list: *mut lower_chunk,
    pub free_upper_chunks: ::aya_bpf::cty::c_int,
    pub free_lower_chunks: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_array_cpu {
    pub disabled: atomic_t,
    pub buffer_page: *mut ::aya_bpf::cty::c_void,
    pub entries: ::aya_bpf::cty::c_ulong,
    pub saved_latency: ::aya_bpf::cty::c_ulong,
    pub critical_start: ::aya_bpf::cty::c_ulong,
    pub critical_end: ::aya_bpf::cty::c_ulong,
    pub critical_sequence: ::aya_bpf::cty::c_ulong,
    pub nice: ::aya_bpf::cty::c_ulong,
    pub policy: ::aya_bpf::cty::c_ulong,
    pub rt_priority: ::aya_bpf::cty::c_ulong,
    pub skipped_entries: ::aya_bpf::cty::c_ulong,
    pub preempt_timestamp: u64_,
    pub pid: pid_t,
    pub uid: kuid_t,
    pub comm: [::aya_bpf::cty::c_char; 16usize],
    pub ftrace_ignore_pid: ::aya_bpf::cty::c_int,
    pub ignore_pid: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_options {
    pub tracer: *mut tracer,
    pub topts: *mut trace_option_dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_option_dentry {
    pub opt: *mut tracer_opt,
    pub flags: *mut tracer_flags,
    pub tr: *mut trace_array,
    pub entry: *mut dentry,
}
pub type cond_update_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut trace_array, arg2: *mut ::aya_bpf::cty::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cond_snapshot {
    pub cond_data: *mut ::aya_bpf::cty::c_void,
    pub update: cond_update_fn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_func_repeats {
    pub ip: ::aya_bpf::cty::c_ulong,
    pub parent_ip: ::aya_bpf::cty::c_ulong,
    pub count: ::aya_bpf::cty::c_ulong,
    pub ts_last_call: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer_opt {
    pub name: *const ::aya_bpf::cty::c_char,
    pub bit: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracer_flags {
    pub val: u32_,
    pub opts: *mut tracer_opt,
    pub trace: *mut tracer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_subsystem {
    pub list: list_head,
    pub name: *const ::aya_bpf::cty::c_char,
    pub filter: *mut event_filter,
    pub ref_count: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_event_field {
    pub link: list_head,
    pub name: *const ::aya_bpf::cty::c_char,
    pub type_: *const ::aya_bpf::cty::c_char,
    pub filter_type: ::aya_bpf::cty::c_int,
    pub offset: ::aya_bpf::cty::c_int,
    pub size: ::aya_bpf::cty::c_int,
    pub is_signed: ::aya_bpf::cty::c_int,
    pub len: ::aya_bpf::cty::c_int,
}
pub type __be64 = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_cgroup_storage_key {
    pub cgroup_inode_id: __u64,
    pub attach_type: __u32,
}
pub mod uprobe_filter_ctx {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const UPROBE_FILTER_REGISTER: Type = 0;
    pub const UPROBE_FILTER_UNREGISTER: Type = 1;
    pub const UPROBE_FILTER_MMAP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: *mut pt_regs,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ret_handler: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut pt_regs,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut uprobe_consumer,
            arg2: uprobe_filter_ctx::Type,
            arg3: *mut mm_struct,
        ) -> bool_,
    >,
    pub next: *mut uprobe_consumer,
}
pub type __addrpair = __u64;
pub type __portpair = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct possible_net_t {
    pub net: *mut net,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
#[repr(C)]
pub struct sock_common {
    pub __bindgen_anon_1: sock_common__bindgen_ty_1,
    pub __bindgen_anon_2: sock_common__bindgen_ty_2,
    pub __bindgen_anon_3: sock_common__bindgen_ty_3,
    pub skc_family: ::aya_bpf::cty::c_ushort,
    pub skc_state: ::aya_bpf::cty::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub skc_bound_dev_if: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_4: sock_common__bindgen_ty_4,
    pub skc_prot: *mut proto,
    pub skc_net: possible_net_t,
    pub skc_v6_daddr: in6_addr,
    pub skc_v6_rcv_saddr: in6_addr,
    pub skc_cookie: atomic64_t,
    pub __bindgen_anon_5: sock_common__bindgen_ty_5,
    pub skc_dontcopy_begin: __IncompleteArrayField<::aya_bpf::cty::c_int>,
    pub __bindgen_anon_6: sock_common__bindgen_ty_6,
    pub skc_tx_queue_mapping: ::aya_bpf::cty::c_ushort,
    pub skc_rx_queue_mapping: ::aya_bpf::cty::c_ushort,
    pub __bindgen_anon_7: sock_common__bindgen_ty_7,
    pub skc_refcnt: refcount_t,
    pub skc_dontcopy_end: __IncompleteArrayField<::aya_bpf::cty::c_int>,
    pub __bindgen_anon_8: sock_common__bindgen_ty_8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_1 {
    pub skc_addrpair: __addrpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_common__bindgen_ty_1__bindgen_ty_1 {
    pub skc_daddr: __be32,
    pub skc_rcv_saddr: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_2 {
    pub skc_hash: ::aya_bpf::cty::c_uint,
    pub skc_u16hashes: [__u16; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_3 {
    pub skc_portpair: __portpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_common__bindgen_ty_3__bindgen_ty_1 {
    pub skc_dport: __be16,
    pub skc_num: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_4 {
    pub skc_bind_node: hlist_node,
    pub skc_portaddr_node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_5 {
    pub skc_flags: ::aya_bpf::cty::c_ulong,
    pub skc_listener: *mut sock,
    pub skc_tw_dr: *mut inet_timewait_death_row,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_6 {
    pub skc_node: hlist_node,
    pub skc_nulls_node: hlist_nulls_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_7 {
    pub skc_incoming_cpu: ::aya_bpf::cty::c_int,
    pub skc_rcv_wnd: u32_,
    pub skc_tw_rcv_nxt: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_8 {
    pub skc_rxhash: u32_,
    pub skc_window_clamp: u32_,
    pub skc_tw_snd_nxt: u32_,
}
impl sock_common {
    #[inline]
    pub fn skc_reuse(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuse(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_reuseport(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuseport(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_ipv6only(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_ipv6only(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_net_refcnt(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_net_refcnt(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        skc_reuse: ::aya_bpf::cty::c_uchar,
        skc_reuseport: ::aya_bpf::cty::c_uchar,
        skc_ipv6only: ::aya_bpf::cty::c_uchar,
        skc_net_refcnt: ::aya_bpf::cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let skc_reuse: u8 = unsafe { ::core::mem::transmute(skc_reuse) };
            skc_reuse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skc_reuseport: u8 = unsafe { ::core::mem::transmute(skc_reuseport) };
            skc_reuseport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skc_ipv6only: u8 = unsafe { ::core::mem::transmute(skc_ipv6only) };
            skc_ipv6only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let skc_net_refcnt: u8 = unsafe { ::core::mem::transmute(skc_net_refcnt) };
            skc_net_refcnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_lock_t {
    pub slock: spinlock_t,
    pub owned: ::aya_bpf::cty::c_int,
    pub wq: wait_queue_head_t,
}
pub type netdev_features_t = u64_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_cgroup_data {
    pub cgroup: *mut cgroup,
    pub classid: u32_,
    pub prioidx: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netns_tracker {}
#[repr(C)]
pub struct sock {
    pub __sk_common: sock_common,
    pub sk_rx_dst: *mut dst_entry,
    pub sk_rx_dst_ifindex: ::aya_bpf::cty::c_int,
    pub sk_rx_dst_cookie: u32_,
    pub sk_lock: socket_lock_t,
    pub sk_drops: atomic_t,
    pub sk_rcvlowat: ::aya_bpf::cty::c_int,
    pub sk_error_queue: sk_buff_head,
    pub sk_receive_queue: sk_buff_head,
    pub sk_backlog: sock__bindgen_ty_1,
    pub sk_forward_alloc: ::aya_bpf::cty::c_int,
    pub sk_reserved_mem: u32_,
    pub sk_ll_usec: ::aya_bpf::cty::c_uint,
    pub sk_napi_id: ::aya_bpf::cty::c_uint,
    pub sk_rcvbuf: ::aya_bpf::cty::c_int,
    pub sk_filter: *mut sk_filter,
    pub __bindgen_anon_1: sock__bindgen_ty_2,
    pub sk_policy: [*mut xfrm_policy; 2usize],
    pub sk_dst_cache: *mut dst_entry,
    pub sk_omem_alloc: atomic_t,
    pub sk_sndbuf: ::aya_bpf::cty::c_int,
    pub sk_wmem_queued: ::aya_bpf::cty::c_int,
    pub sk_wmem_alloc: refcount_t,
    pub sk_tsq_flags: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_2: sock__bindgen_ty_3,
    pub sk_write_queue: sk_buff_head,
    pub sk_peek_off: __s32,
    pub sk_write_pending: ::aya_bpf::cty::c_int,
    pub sk_dst_pending_confirm: __u32,
    pub sk_pacing_status: u32_,
    pub sk_sndtimeo: ::aya_bpf::cty::c_long,
    pub sk_timer: timer_list,
    pub sk_priority: __u32,
    pub sk_mark: __u32,
    pub sk_pacing_rate: ::aya_bpf::cty::c_ulong,
    pub sk_max_pacing_rate: ::aya_bpf::cty::c_ulong,
    pub sk_frag: page_frag,
    pub sk_route_caps: netdev_features_t,
    pub sk_gso_type: ::aya_bpf::cty::c_int,
    pub sk_gso_max_size: ::aya_bpf::cty::c_uint,
    pub sk_allocation: gfp_t,
    pub sk_txhash: __u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub sk_pacing_shift: u8_,
    pub sk_type: u16_,
    pub sk_protocol: u16_,
    pub sk_gso_max_segs: u16_,
    pub sk_lingertime: ::aya_bpf::cty::c_ulong,
    pub sk_prot_creator: *mut proto,
    pub sk_callback_lock: rwlock_t,
    pub sk_err: ::aya_bpf::cty::c_int,
    pub sk_err_soft: ::aya_bpf::cty::c_int,
    pub sk_ack_backlog: u32_,
    pub sk_max_ack_backlog: u32_,
    pub sk_uid: kuid_t,
    pub sk_txrehash: u8_,
    pub sk_prefer_busy_poll: u8_,
    pub sk_busy_poll_budget: u16_,
    pub sk_peer_lock: spinlock_t,
    pub sk_bind_phc: ::aya_bpf::cty::c_int,
    pub sk_peer_pid: *mut pid,
    pub sk_peer_cred: *const cred,
    pub sk_rcvtimeo: ::aya_bpf::cty::c_long,
    pub sk_stamp: ktime_t,
    pub sk_tskey: atomic_t,
    pub sk_zckey: atomic_t,
    pub sk_tsflags: u32_,
    pub sk_shutdown: u8_,
    pub sk_clockid: u8_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub sk_use_task_frag: bool_,
    pub sk_socket: *mut socket,
    pub sk_user_data: *mut ::aya_bpf::cty::c_void,
    pub sk_security: *mut ::aya_bpf::cty::c_void,
    pub sk_cgrp_data: sock_cgroup_data,
    pub sk_memcg: *mut mem_cgroup,
    pub sk_state_change: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_data_ready: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_error_report: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub sk_validate_xmit_skb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut net_device,
            arg3: *mut sk_buff,
        ) -> *mut sk_buff,
    >,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub sk_reuseport_cb: *mut sock_reuseport,
    pub sk_bpf_storage: *mut bpf_local_storage,
    pub sk_rcu: callback_head,
    pub ns_tracker: netns_tracker,
    pub sk_bind2_node: hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock__bindgen_ty_1 {
    pub rmem_alloc: atomic_t,
    pub len: ::aya_bpf::cty::c_int,
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_2 {
    pub sk_wq: *mut socket_wq,
    pub sk_wq_raw: *mut socket_wq,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_3 {
    pub sk_send_head: *mut sk_buff,
    pub tcp_rtx_queue: rb_root,
}
impl sock {
    #[inline]
    pub fn sk_gso_disabled(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_gso_disabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_kern_sock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_kern_sock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_tx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_tx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_rx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_rx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_userlocks(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sk_userlocks(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sk_gso_disabled: u8_,
        sk_kern_sock: u8_,
        sk_no_check_tx: u8_,
        sk_no_check_rx: u8_,
        sk_userlocks: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_gso_disabled: u8 = unsafe { ::core::mem::transmute(sk_gso_disabled) };
            sk_gso_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_kern_sock: u8 = unsafe { ::core::mem::transmute(sk_kern_sock) };
            sk_kern_sock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sk_no_check_tx: u8 = unsafe { ::core::mem::transmute(sk_no_check_tx) };
            sk_no_check_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sk_no_check_rx: u8 = unsafe { ::core::mem::transmute(sk_no_check_rx) };
            sk_no_check_rx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sk_userlocks: u8 = unsafe { ::core::mem::transmute(sk_userlocks) };
            sk_userlocks as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sk_txtime_deadline_mode(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_deadline_mode(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_report_errors(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_report_errors(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sk_txtime_deadline_mode: u8_,
        sk_txtime_report_errors: u8_,
        sk_txtime_unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_txtime_deadline_mode: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_deadline_mode) };
            sk_txtime_deadline_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_txtime_report_errors: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_report_errors) };
            sk_txtime_report_errors as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let sk_txtime_unused: u8 = unsafe { ::core::mem::transmute(sk_txtime_unused) };
            sk_txtime_unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockptr_t {
    pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockptr_t__bindgen_ty_1 {
    pub kernel: *mut ::aya_bpf::cty::c_void,
    pub user: *mut ::aya_bpf::cty::c_void,
}
impl sockptr_t {
    #[inline]
    pub fn is_kernel(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_kernel(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
            is_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_map_dev_ops {
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_offloaded_map,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_offloaded_map {
    pub map: bpf_map,
    pub netdev: *mut net_device,
    pub dev_ops: *const bpf_map_dev_ops,
    pub dev_priv: *mut ::aya_bpf::cty::c_void,
    pub offloads: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl bpf_offloaded_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_stats {
    pub __bindgen_anon_1: net_device_stats__bindgen_ty_1,
    pub __bindgen_anon_2: net_device_stats__bindgen_ty_2,
    pub __bindgen_anon_3: net_device_stats__bindgen_ty_3,
    pub __bindgen_anon_4: net_device_stats__bindgen_ty_4,
    pub __bindgen_anon_5: net_device_stats__bindgen_ty_5,
    pub __bindgen_anon_6: net_device_stats__bindgen_ty_6,
    pub __bindgen_anon_7: net_device_stats__bindgen_ty_7,
    pub __bindgen_anon_8: net_device_stats__bindgen_ty_8,
    pub __bindgen_anon_9: net_device_stats__bindgen_ty_9,
    pub __bindgen_anon_10: net_device_stats__bindgen_ty_10,
    pub __bindgen_anon_11: net_device_stats__bindgen_ty_11,
    pub __bindgen_anon_12: net_device_stats__bindgen_ty_12,
    pub __bindgen_anon_13: net_device_stats__bindgen_ty_13,
    pub __bindgen_anon_14: net_device_stats__bindgen_ty_14,
    pub __bindgen_anon_15: net_device_stats__bindgen_ty_15,
    pub __bindgen_anon_16: net_device_stats__bindgen_ty_16,
    pub __bindgen_anon_17: net_device_stats__bindgen_ty_17,
    pub __bindgen_anon_18: net_device_stats__bindgen_ty_18,
    pub __bindgen_anon_19: net_device_stats__bindgen_ty_19,
    pub __bindgen_anon_20: net_device_stats__bindgen_ty_20,
    pub __bindgen_anon_21: net_device_stats__bindgen_ty_21,
    pub __bindgen_anon_22: net_device_stats__bindgen_ty_22,
    pub __bindgen_anon_23: net_device_stats__bindgen_ty_23,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_1 {
    pub rx_packets: ::aya_bpf::cty::c_ulong,
    pub __rx_packets: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_2 {
    pub tx_packets: ::aya_bpf::cty::c_ulong,
    pub __tx_packets: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_3 {
    pub rx_bytes: ::aya_bpf::cty::c_ulong,
    pub __rx_bytes: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_4 {
    pub tx_bytes: ::aya_bpf::cty::c_ulong,
    pub __tx_bytes: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_5 {
    pub rx_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_6 {
    pub tx_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_7 {
    pub rx_dropped: ::aya_bpf::cty::c_ulong,
    pub __rx_dropped: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_8 {
    pub tx_dropped: ::aya_bpf::cty::c_ulong,
    pub __tx_dropped: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_9 {
    pub multicast: ::aya_bpf::cty::c_ulong,
    pub __multicast: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_10 {
    pub collisions: ::aya_bpf::cty::c_ulong,
    pub __collisions: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_11 {
    pub rx_length_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_length_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_12 {
    pub rx_over_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_over_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_13 {
    pub rx_crc_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_crc_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_14 {
    pub rx_frame_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_frame_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_15 {
    pub rx_fifo_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_fifo_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_16 {
    pub rx_missed_errors: ::aya_bpf::cty::c_ulong,
    pub __rx_missed_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_17 {
    pub tx_aborted_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_aborted_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_18 {
    pub tx_carrier_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_carrier_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_19 {
    pub tx_fifo_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_fifo_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_20 {
    pub tx_heartbeat_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_heartbeat_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_21 {
    pub tx_window_errors: ::aya_bpf::cty::c_ulong,
    pub __tx_window_errors: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_22 {
    pub rx_compressed: ::aya_bpf::cty::c_ulong,
    pub __rx_compressed: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_stats__bindgen_ty_23 {
    pub tx_compressed: ::aya_bpf::cty::c_ulong,
    pub __tx_compressed: atomic_long_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_hw_addr_list {
    pub list: list_head,
    pub count: ::aya_bpf::cty::c_int,
    pub tree: rb_root,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tipc_bearer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpls_dev {
    _unused: [u8; 0],
}
pub mod rx_handler_result {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RX_HANDLER_CONSUMED: Type = 0;
    pub const RX_HANDLER_ANOTHER: Type = 1;
    pub const RX_HANDLER_EXACT: Type = 2;
    pub const RX_HANDLER_PASS: Type = 3;
}
pub use self::rx_handler_result::Type as rx_handler_result_t;
pub type rx_handler_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut *mut sk_buff) -> rx_handler_result_t>;
pub mod netdev_ml_priv_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ML_PRIV_NONE: Type = 0;
    pub const ML_PRIV_CAN: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_dstats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct garp_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrp_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_tc_txq {
    pub count: u16_,
    pub offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_xdp_entity {
    pub prog: *mut bpf_prog,
    pub link: *mut bpf_xdp_link,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device {
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub name_node: *mut netdev_name_node,
    pub ifalias: *mut dev_ifalias,
    pub mem_end: ::aya_bpf::cty::c_ulong,
    pub mem_start: ::aya_bpf::cty::c_ulong,
    pub base_addr: ::aya_bpf::cty::c_ulong,
    pub state: ::aya_bpf::cty::c_ulong,
    pub dev_list: list_head,
    pub napi_list: list_head,
    pub unreg_list: list_head,
    pub close_list: list_head,
    pub ptype_all: list_head,
    pub ptype_specific: list_head,
    pub adj_list: net_device__bindgen_ty_1,
    pub flags: ::aya_bpf::cty::c_uint,
    pub priv_flags: ::aya_bpf::cty::c_ulonglong,
    pub netdev_ops: *const net_device_ops,
    pub ifindex: ::aya_bpf::cty::c_int,
    pub gflags: ::aya_bpf::cty::c_ushort,
    pub hard_header_len: ::aya_bpf::cty::c_ushort,
    pub mtu: ::aya_bpf::cty::c_uint,
    pub needed_headroom: ::aya_bpf::cty::c_ushort,
    pub needed_tailroom: ::aya_bpf::cty::c_ushort,
    pub features: netdev_features_t,
    pub hw_features: netdev_features_t,
    pub wanted_features: netdev_features_t,
    pub vlan_features: netdev_features_t,
    pub hw_enc_features: netdev_features_t,
    pub mpls_features: netdev_features_t,
    pub gso_partial_features: netdev_features_t,
    pub min_mtu: ::aya_bpf::cty::c_uint,
    pub max_mtu: ::aya_bpf::cty::c_uint,
    pub type_: ::aya_bpf::cty::c_ushort,
    pub min_header_len: ::aya_bpf::cty::c_uchar,
    pub name_assign_type: ::aya_bpf::cty::c_uchar,
    pub group: ::aya_bpf::cty::c_int,
    pub stats: net_device_stats,
    pub core_stats: *mut net_device_core_stats,
    pub carrier_up_count: atomic_t,
    pub carrier_down_count: atomic_t,
    pub wireless_handlers: *const iw_handler_def,
    pub wireless_data: *mut iw_public_data,
    pub ethtool_ops: *const ethtool_ops,
    pub l3mdev_ops: *const l3mdev_ops,
    pub ndisc_ops: *const ndisc_ops,
    pub xfrmdev_ops: *const xfrmdev_ops,
    pub tlsdev_ops: *const tlsdev_ops,
    pub header_ops: *const header_ops,
    pub operstate: ::aya_bpf::cty::c_uchar,
    pub link_mode: ::aya_bpf::cty::c_uchar,
    pub if_port: ::aya_bpf::cty::c_uchar,
    pub dma: ::aya_bpf::cty::c_uchar,
    pub perm_addr: [::aya_bpf::cty::c_uchar; 32usize],
    pub addr_assign_type: ::aya_bpf::cty::c_uchar,
    pub addr_len: ::aya_bpf::cty::c_uchar,
    pub upper_level: ::aya_bpf::cty::c_uchar,
    pub lower_level: ::aya_bpf::cty::c_uchar,
    pub neigh_priv_len: ::aya_bpf::cty::c_ushort,
    pub dev_id: ::aya_bpf::cty::c_ushort,
    pub dev_port: ::aya_bpf::cty::c_ushort,
    pub padded: ::aya_bpf::cty::c_ushort,
    pub addr_list_lock: spinlock_t,
    pub irq: ::aya_bpf::cty::c_int,
    pub uc: netdev_hw_addr_list,
    pub mc: netdev_hw_addr_list,
    pub dev_addrs: netdev_hw_addr_list,
    pub queues_kset: *mut kset,
    pub promiscuity: ::aya_bpf::cty::c_uint,
    pub allmulti: ::aya_bpf::cty::c_uint,
    pub uc_promisc: bool_,
    pub ip_ptr: *mut in_device,
    pub ip6_ptr: *mut inet6_dev,
    pub vlan_info: *mut vlan_info,
    pub dsa_ptr: *mut dsa_port,
    pub tipc_ptr: *mut tipc_bearer,
    pub ax25_ptr: *mut ::aya_bpf::cty::c_void,
    pub ieee80211_ptr: *mut wireless_dev,
    pub ieee802154_ptr: *mut wpan_dev,
    pub mpls_ptr: *mut mpls_dev,
    pub mctp_ptr: *mut mctp_dev,
    pub dev_addr: *const ::aya_bpf::cty::c_uchar,
    pub _rx: *mut netdev_rx_queue,
    pub num_rx_queues: ::aya_bpf::cty::c_uint,
    pub real_num_rx_queues: ::aya_bpf::cty::c_uint,
    pub xdp_prog: *mut bpf_prog,
    pub gro_flush_timeout: ::aya_bpf::cty::c_ulong,
    pub napi_defer_hard_irqs: ::aya_bpf::cty::c_int,
    pub gro_max_size: ::aya_bpf::cty::c_uint,
    pub rx_handler: rx_handler_func_t,
    pub rx_handler_data: *mut ::aya_bpf::cty::c_void,
    pub miniq_ingress: *mut mini_Qdisc,
    pub ingress_queue: *mut netdev_queue,
    pub nf_hooks_ingress: *mut nf_hook_entries,
    pub broadcast: [::aya_bpf::cty::c_uchar; 32usize],
    pub rx_cpu_rmap: *mut cpu_rmap,
    pub index_hlist: hlist_node,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub _tx: *mut netdev_queue,
    pub num_tx_queues: ::aya_bpf::cty::c_uint,
    pub real_num_tx_queues: ::aya_bpf::cty::c_uint,
    pub qdisc: *mut Qdisc,
    pub tx_queue_len: ::aya_bpf::cty::c_uint,
    pub tx_global_lock: spinlock_t,
    pub xdp_bulkq: *mut xdp_dev_bulk_queue,
    pub xps_maps: [*mut xps_dev_maps; 2usize],
    pub miniq_egress: *mut mini_Qdisc,
    pub nf_hooks_egress: *mut nf_hook_entries,
    pub qdisc_hash: [hlist_head; 16usize],
    pub watchdog_timer: timer_list,
    pub watchdog_timeo: ::aya_bpf::cty::c_int,
    pub proto_down_reason: u32_,
    pub todo_list: list_head,
    pub pcpu_refcnt: *mut ::aya_bpf::cty::c_int,
    pub refcnt_tracker: ref_tracker_dir,
    pub link_watch_list: list_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dismantle: bool_,
    pub _bitfield_align_3: [u16; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub needs_free_netdev: bool_,
    pub priv_destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub npinfo: *mut netpoll_info,
    pub nd_net: possible_net_t,
    pub ml_priv: *mut ::aya_bpf::cty::c_void,
    pub ml_priv_type: netdev_ml_priv_type::Type,
    pub __bindgen_anon_1: net_device__bindgen_ty_4,
    pub garp_port: *mut garp_port,
    pub mrp_port: *mut mrp_port,
    pub dm_private: *mut dm_hw_stat_delta,
    pub dev: device,
    pub sysfs_groups: [*const attribute_group; 4usize],
    pub sysfs_rx_queue_group: *const attribute_group,
    pub rtnl_link_ops: *const rtnl_link_ops,
    pub gso_max_size: ::aya_bpf::cty::c_uint,
    pub tso_max_size: ::aya_bpf::cty::c_uint,
    pub gso_max_segs: u16_,
    pub tso_max_segs: u16_,
    pub dcbnl_ops: *const dcbnl_rtnl_ops,
    pub num_tc: s16,
    pub tc_to_txq: [netdev_tc_txq; 16usize],
    pub prio_tc_map: [u8_; 16usize],
    pub fcoe_ddp_xid: ::aya_bpf::cty::c_uint,
    pub priomap: *mut netprio_map,
    pub phydev: *mut phy_device,
    pub sfp_bus: *mut sfp_bus,
    pub qdisc_tx_busylock: *mut lock_class_key,
    pub proto_down: bool_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub net_notifier_list: list_head,
    pub macsec_ops: *const macsec_ops,
    pub udp_tunnel_nic_info: *const udp_tunnel_nic_info,
    pub udp_tunnel_nic: *mut udp_tunnel_nic,
    pub xdp_state: [bpf_xdp_entity; 3usize],
    pub dev_addr_shadow: [u8_; 32usize],
    pub linkwatch_dev_tracker: netdevice_tracker,
    pub watchdog_dev_tracker: netdevice_tracker,
    pub dev_registered_tracker: netdevice_tracker,
    pub offload_xstats_l3: *mut rtnl_hw_stats64,
    pub devlink_port: *mut devlink_port,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device__bindgen_ty_1 {
    pub upper: list_head,
    pub lower: list_head,
}
pub mod net_device__bindgen_ty_2 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NETREG_UNINITIALIZED: Type = 0;
    pub const NETREG_REGISTERED: Type = 1;
    pub const NETREG_UNREGISTERING: Type = 2;
    pub const NETREG_UNREGISTERED: Type = 3;
    pub const NETREG_RELEASED: Type = 4;
    pub const NETREG_DUMMY: Type = 5;
}
pub mod net_device__bindgen_ty_3 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RTNL_LINK_INITIALIZED: Type = 0;
    pub const RTNL_LINK_INITIALIZING: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device__bindgen_ty_4 {
    pub lstats: *mut pcpu_lstats,
    pub tstats: *mut pcpu_sw_netstats,
    pub dstats: *mut pcpu_dstats,
}
impl net_device {
    #[inline]
    pub fn reg_state(&self) -> net_device__bindgen_ty_2::Type {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reg_state(&mut self, val: net_device__bindgen_ty_2::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reg_state: net_device__bindgen_ty_2::Type,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reg_state: u32 = unsafe { ::core::mem::transmute(reg_state) };
            reg_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rtnl_link_state(&self) -> net_device__bindgen_ty_3::Type {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtnl_link_state(&mut self, val: net_device__bindgen_ty_3::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        rtnl_link_state: net_device__bindgen_ty_3::Type,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtnl_link_state: u32 = unsafe { ::core::mem::transmute(rtnl_link_state) };
            rtnl_link_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wol_enabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        wol_enabled: ::aya_bpf::cty::c_uint,
        threaded: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let threaded: u32 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_5() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u64_stats_t {
    pub v: local64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_stats {
    pub cnt: u64_stats_t,
    pub nsecs: u64_stats_t,
    pub misses: u64_stats_t,
    pub syncp: u64_stats_sync,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl bpf_prog_stats {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_fprog_kern {
    pub len: u16_,
    pub filter: *mut sock_filter,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage {
    pub __bindgen_anon_1: bpf_cgroup_storage__bindgen_ty_1,
    pub map: *mut bpf_cgroup_storage_map,
    pub key: bpf_cgroup_storage_key,
    pub list_map: list_head,
    pub list_cg: list_head,
    pub node: rb_node,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cgroup_storage__bindgen_ty_1 {
    pub buf: *mut bpf_storage_buffer,
    pub percpu_buf: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dql {
    pub num_queued: ::aya_bpf::cty::c_uint,
    pub adj_limit: ::aya_bpf::cty::c_uint,
    pub last_obj_cnt: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: u32,
    pub limit: ::aya_bpf::cty::c_uint,
    pub num_completed: ::aya_bpf::cty::c_uint,
    pub prev_ovlimit: ::aya_bpf::cty::c_uint,
    pub prev_num_queued: ::aya_bpf::cty::c_uint,
    pub prev_last_obj_cnt: ::aya_bpf::cty::c_uint,
    pub lowest_slack: ::aya_bpf::cty::c_uint,
    pub slack_start_time: ::aya_bpf::cty::c_ulong,
    pub max_limit: ::aya_bpf::cty::c_uint,
    pub min_limit: ::aya_bpf::cty::c_uint,
    pub slack_hold_time: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub __bindgen_padding_1: u32,
}
impl dql {
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub __bindgen_anon_1: sockaddr__bindgen_ty_1,
}
#[repr(C)]
pub struct sockaddr__bindgen_ty_1 {
    pub sa_data_min: __BindgenUnionField<[::aya_bpf::cty::c_char; 14usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<sockaddr__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u8; 14usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_sa_data: sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub sa_data: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::aya_bpf::cty::c_void,
    pub msg_namelen: ::aya_bpf::cty::c_int,
    pub msg_inq: ::aya_bpf::cty::c_int,
    pub msg_iter: iov_iter,
    pub __bindgen_anon_1: msghdr__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub msg_flags: ::aya_bpf::cty::c_uint,
    pub msg_controllen: __kernel_size_t,
    pub msg_iocb: *mut kiocb,
    pub msg_ubuf: *mut ubuf_info,
    pub sg_from_iter: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sk_buff,
            arg3: *mut iov_iter,
            arg4: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msghdr__bindgen_ty_1 {
    pub msg_control: *mut ::aya_bpf::cty::c_void,
    pub msg_control_user: *mut ::aya_bpf::cty::c_void,
}
impl msghdr {
    #[inline]
    pub fn msg_control_is_user(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_control_is_user(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msg_get_inq(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_get_inq(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_control_is_user: bool_,
        msg_get_inq: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_control_is_user: u8 = unsafe { ::core::mem::transmute(msg_control_is_user) };
            msg_control_is_user as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let msg_get_inq: u8 = unsafe { ::core::mem::transmute(msg_get_inq) };
            msg_get_inq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ubuf_info {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ubuf_info, arg3: bool_),
    >,
    pub refcnt: refcount_t,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: ::aya_bpf::cty::c_int,
    pub flowic_iif: ::aya_bpf::cty::c_int,
    pub flowic_l3mdev: ::aya_bpf::cty::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_tun_key: flowi_tunnel,
    pub flowic_multipath_hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub type_: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prot_inuse {
    pub all: ::aya_bpf::cty::c_int,
    pub val: [::aya_bpf::cty::c_int; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rules_ops {
    pub family: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub rule_size: ::aya_bpf::cty::c_int,
    pub addr_size: ::aya_bpf::cty::c_int,
    pub unresolved_rules: ::aya_bpf::cty::c_int,
    pub nr_goto_rules: ::aya_bpf::cty::c_int,
    pub fib_rules_seq: ::aya_bpf::cty::c_uint,
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut fib_lookup_arg,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub suppress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut fib_lookup_arg,
        ) -> bool_,
    >,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> ::aya_bpf::cty::c_int>,
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut fib_rule_hdr,
            arg3: *mut *mut nlattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fill: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub nlmsg_payload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> usize>,
    pub flush_cache: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rules_ops)>,
    pub nlgroup: ::aya_bpf::cty::c_int,
    pub rules_list: list_head,
    pub owner: *mut module,
    pub fro_net: *mut net,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_notifier_ops {
    pub family: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub fib_seq_read:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net) -> ::aya_bpf::cty::c_uint>,
    pub fib_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut notifier_block,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub owner: *mut module,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hh_cache {
    pub hh_len: ::aya_bpf::cty::c_uint,
    pub hh_lock: seqlock_t,
    pub hh_data: [::aya_bpf::cty::c_ulong; 16usize],
}
#[repr(C)]
pub struct neighbour {
    pub next: *mut neighbour,
    pub tbl: *mut neigh_table,
    pub parms: *mut neigh_parms,
    pub confirmed: ::aya_bpf::cty::c_ulong,
    pub updated: ::aya_bpf::cty::c_ulong,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub arp_queue_len_bytes: ::aya_bpf::cty::c_uint,
    pub arp_queue: sk_buff_head,
    pub timer: timer_list,
    pub used: ::aya_bpf::cty::c_ulong,
    pub probes: atomic_t,
    pub nud_state: u8_,
    pub type_: u8_,
    pub dead: u8_,
    pub protocol: u8_,
    pub flags: u32_,
    pub ha_lock: seqlock_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub ha: [::aya_bpf::cty::c_uchar; 32usize],
    pub hh: hh_cache,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub ops: *const neigh_ops,
    pub gc_list: list_head,
    pub managed_list: list_head,
    pub rcu: callback_head,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub primary_key: __IncompleteArrayField<u8_>,
}
pub mod socket_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const SS_FREE: Type = 0;
    pub const SS_UNCONNECTED: Type = 1;
    pub const SS_CONNECTING: Type = 2;
    pub const SS_CONNECTED: Type = 3;
    pub const SS_DISCONNECTING: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl socket_wq {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state::Type,
    pub type_: ::aya_bpf::cty::c_short,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub wq: socket_wq,
}
impl socket {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut ::aya_bpf::cty::c_char,
    pub data: *mut ::aya_bpf::cty::c_void,
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: ::aya_bpf::cty::c_uint,
        arg4: usize,
    ) -> ::aya_bpf::cty::c_int,
>;
pub type skb_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proto_ops {
    pub family: ::aya_bpf::cty::c_int,
    pub owner: *mut module,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf::cty::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut socket, arg2: *mut socket) -> ::aya_bpf::cty::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut socket,
            arg3: ::aya_bpf::cty::c_int,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut socket,
            arg3: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: bool_,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: sockptr_t,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ::aya_bpf::cty::c_char,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut socket)>,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut msghdr,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut msghdr,
            arg3: usize,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut socket,
            arg3: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_int,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_int,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut socket,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> isize,
    >,
    pub set_peek_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
    pub peek_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket) -> ::aya_bpf::cty::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut read_descriptor_t,
            arg3: sk_read_actor_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_skb: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: skb_read_actor_t) -> ::aya_bpf::cty::c_int,
    >,
    pub sendpage_locked: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_int,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_rcvlowat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_hwtstamps {
    pub __bindgen_anon_1: skb_shared_hwtstamps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_hwtstamps__bindgen_ty_1 {
    pub hwtstamp: ktime_t,
    pub netdev_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_ets {
    pub willing: __u8,
    pub ets_cap: __u8,
    pub cbs: __u8,
    pub tc_tx_bw: [__u8; 8usize],
    pub tc_rx_bw: [__u8; 8usize],
    pub tc_tsa: [__u8; 8usize],
    pub prio_tc: [__u8; 8usize],
    pub tc_reco_bw: [__u8; 8usize],
    pub tc_reco_tsa: [__u8; 8usize],
    pub reco_prio_tc: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_maxrate {
    pub tc_maxrate: [__u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_qcn {
    pub rpg_enable: [__u8; 8usize],
    pub rppp_max_rps: [__u32; 8usize],
    pub rpg_time_reset: [__u32; 8usize],
    pub rpg_byte_reset: [__u32; 8usize],
    pub rpg_threshold: [__u32; 8usize],
    pub rpg_max_rate: [__u32; 8usize],
    pub rpg_ai_rate: [__u32; 8usize],
    pub rpg_hai_rate: [__u32; 8usize],
    pub rpg_gd: [__u32; 8usize],
    pub rpg_min_dec_fac: [__u32; 8usize],
    pub rpg_min_rate: [__u32; 8usize],
    pub cndd_state_machine: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_qcn_stats {
    pub rppp_rp_centiseconds: [__u64; 8usize],
    pub rppp_created_rps: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee_pfc {
    pub pfc_cap: __u8,
    pub pfc_en: __u8,
    pub mbc: __u8,
    pub delay: __u16,
    pub requests: [__u64; 8usize],
    pub indications: [__u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcbnl_buffer {
    pub prio2buffer: [__u8; 8usize],
    pub buffer_size: [__u32; 8usize],
    pub total_size: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cee_pg {
    pub willing: __u8,
    pub error: __u8,
    pub pg_en: __u8,
    pub tcs_supported: __u8,
    pub pg_bw: [__u8; 8usize],
    pub prio_pg: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cee_pfc {
    pub willing: __u8,
    pub error: __u8,
    pub pfc_en: __u8,
    pub tcs_supported: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb_app {
    pub selector: __u8,
    pub priority: __u8,
    pub protocol: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcb_peer_app_info {
    pub willing: __u8,
    pub error: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dcbnl_rtnl_ops {
    pub ieee_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_setets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_getmaxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_maxrate,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_setmaxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_maxrate,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_getqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_setqcn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_getqcnstats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ieee_qcn_stats,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_setpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_setapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_delapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_peer_getets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::aya_bpf::cty::c_int,
    >,
    pub ieee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::aya_bpf::cty::c_int,
    >,
    pub getstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setstate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub getpermhwaddr:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u8_)>,
    pub setpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u8_),
    >,
    pub setpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
            arg4: u8_,
            arg5: u8_,
            arg6: u8_,
        ),
    >,
    pub setpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u8_),
    >,
    pub getpgtccfgtx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgtx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: *mut u8_),
    >,
    pub getpgtccfgrx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: *mut u8_,
            arg6: *mut u8_,
        ),
    >,
    pub getpgbwgcfgrx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: *mut u8_),
    >,
    pub setpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u8_),
    >,
    pub getpfccfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: *mut u8_),
    >,
    pub setall: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub getcap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
        ) -> u8_,
    >,
    pub getnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setnumtcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setpfcstate: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_)>,
    pub getbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: *mut u32_),
    >,
    pub setbcncfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u32_),
    >,
    pub getbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: *mut u8_),
    >,
    pub setbcnrp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u8_),
    >,
    pub setapp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u8_,
            arg3: u16_,
            arg4: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getapp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_, arg3: u16_) -> ::aya_bpf::cty::c_int,
    >,
    pub getfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
        ) -> u8_,
    >,
    pub setfeatcfg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int, arg3: u8_) -> u8_,
    >,
    pub getdcbx: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u8_>,
    pub setdcbx:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u8_) -> u8_>,
    pub peer_getappinfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcb_peer_app_info,
            arg3: *mut u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub peer_getapptable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::aya_bpf::cty::c_int,
    >,
    pub cee_peer_getpg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pg) -> ::aya_bpf::cty::c_int,
    >,
    pub cee_peer_getpfc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pfc) -> ::aya_bpf::cty::c_int,
    >,
    pub dcbnl_getbuffer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcbnl_buffer,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dcbnl_setbuffer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut dcbnl_buffer,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dcbnl_setapptrust: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u8_,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dcbnl_getapptrust: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u8_,
            arg3: *mut ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct netprio_map {
    pub rcu: callback_head,
    pub priomap_len: u32_,
    pub priomap: __IncompleteArrayField<u32_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_mem_info {
    pub type_: u32_,
    pub id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_rxq_info {
    pub dev: *mut net_device,
    pub queue_index: u32_,
    pub reg_state: u32_,
    pub mem: xdp_mem_info,
    pub napi_id: ::aya_bpf::cty::c_uint,
    pub frag_size: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl xdp_rxq_info {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_txq_info {
    pub dev: *mut net_device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_buff {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub data_end: *mut ::aya_bpf::cty::c_void,
    pub data_meta: *mut ::aya_bpf::cty::c_void,
    pub data_hard_start: *mut ::aya_bpf::cty::c_void,
    pub rxq: *mut xdp_rxq_info,
    pub txq: *mut xdp_txq_info,
    pub frame_sz: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_frame {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub len: u16_,
    pub headroom: u16_,
    pub metasize: u32_,
    pub mem: xdp_mem_info,
    pub dev_rx: *mut net_device,
    pub frame_sz: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const ::aya_bpf::cty::c_char,
    pub bad_attr: *const nlattr,
    pub policy: *const nla_policy,
    pub miss_nest: *const nlattr,
    pub miss_type: u16_,
    pub cookie: [u8_; 20usize],
    pub cookie_len: u8_,
    pub _msg_buf: [::aya_bpf::cty::c_char; 80usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nla_policy {
    pub type_: u8_,
    pub validation_type: u8_,
    pub len: u16_,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nla_policy__bindgen_ty_1 {
    pub strict_start_type: u16_,
    pub bitfield32_valid: u32_,
    pub mask: u32_,
    pub reject_message: *const ::aya_bpf::cty::c_char,
    pub nested_policy: *const nla_policy,
    pub range: *mut netlink_range_validation,
    pub range_signed: *mut netlink_range_validation_signed,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1__bindgen_ty_1,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const nlattr,
            arg2: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nla_policy__bindgen_ty_1__bindgen_ty_1 {
    pub min: s16,
    pub max: s16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut netlink_callback,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> ::aya_bpf::cty::c_int,
    >,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub answer_flags: u16_,
    pub min_dump_alloc: u32_,
    pub prev_seq: ::aya_bpf::cty::c_uint,
    pub seq: ::aya_bpf::cty::c_uint,
    pub strict_check: bool_,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [::aya_bpf::cty::c_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndmsg {
    pub ndm_family: __u8,
    pub ndm_pad1: __u8,
    pub ndm_pad2: __u16,
    pub ndm_ifindex: __s32,
    pub ndm_state: __u16,
    pub ndm_flags: __u8,
    pub ndm_type: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: ::aya_bpf::cty::c_uint,
    pub clock_type: ::aya_bpf::cty::c_uint,
    pub loopback: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: ::aya_bpf::cty::c_uint,
    pub clock_type: ::aya_bpf::cty::c_uint,
    pub loopback: ::aya_bpf::cty::c_ushort,
    pub slot_map: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: ::aya_bpf::cty::c_ushort,
    pub parity: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto {
    pub t391: ::aya_bpf::cty::c_uint,
    pub t392: ::aya_bpf::cty::c_uint,
    pub n391: ::aya_bpf::cty::c_uint,
    pub n392: ::aya_bpf::cty::c_uint,
    pub n393: ::aya_bpf::cty::c_uint,
    pub lmi: ::aya_bpf::cty::c_ushort,
    pub dce: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: ::aya_bpf::cty::c_uint,
    pub master: [::aya_bpf::cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cisco_proto {
    pub interval: ::aya_bpf::cty::c_uint,
    pub timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: ::aya_bpf::cty::c_ushort,
    pub modulo: ::aya_bpf::cty::c_uint,
    pub window: ::aya_bpf::cty::c_uint,
    pub t1: ::aya_bpf::cty::c_uint,
    pub t2: ::aya_bpf::cty::c_uint,
    pub n2: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifmap {
    pub mem_start: ::aya_bpf::cty::c_ulong,
    pub mem_end: ::aya_bpf::cty::c_ulong,
    pub base_addr: ::aya_bpf::cty::c_ushort,
    pub irq: ::aya_bpf::cty::c_uchar,
    pub dma: ::aya_bpf::cty::c_uchar,
    pub port: ::aya_bpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: ::aya_bpf::cty::c_uint,
    pub size: ::aya_bpf::cty::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
}
#[repr(C)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [::aya_bpf::cty::c_char; 16usize],
}
#[repr(C)]
pub struct ifreq__bindgen_ty_2 {
    pub ifru_addr: __BindgenUnionField<sockaddr>,
    pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
    pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
    pub ifru_netmask: __BindgenUnionField<sockaddr>,
    pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
    pub ifru_flags: __BindgenUnionField<::aya_bpf::cty::c_short>,
    pub ifru_ivalue: __BindgenUnionField<::aya_bpf::cty::c_int>,
    pub ifru_mtu: __BindgenUnionField<::aya_bpf::cty::c_int>,
    pub ifru_map: __BindgenUnionField<ifmap>,
    pub ifru_slave: __BindgenUnionField<[::aya_bpf::cty::c_char; 16usize]>,
    pub ifru_newname: __BindgenUnionField<[::aya_bpf::cty::c_char; 16usize]>,
    pub ifru_data: __BindgenUnionField<*mut ::aya_bpf::cty::c_void>,
    pub ifru_settings: __BindgenUnionField<if_settings>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
    pub rx_otherhost_dropped: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_hw_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_guid {
    pub vf: __u32,
    pub guid: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_stats {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub broadcast: __u64,
    pub multicast: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifla_vf_info {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
    pub vlan: __u32,
    pub qos: __u32,
    pub spoofchk: __u32,
    pub linkstate: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
    pub rss_query_en: __u32,
    pub trusted: __u32,
    pub vlan_proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tc_stats {
    pub bytes: __u64,
    pub packets: __u32,
    pub drops: __u32,
    pub overlimits: __u32,
    pub bps: __u32,
    pub pps: __u32,
    pub qlen: __u32,
    pub backlog: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tc_sizespec {
    pub cell_log: ::aya_bpf::cty::c_uchar,
    pub size_log: ::aya_bpf::cty::c_uchar,
    pub cell_align: ::aya_bpf::cty::c_short,
    pub overhead: ::aya_bpf::cty::c_int,
    pub linklayer: ::aya_bpf::cty::c_uint,
    pub mpu: ::aya_bpf::cty::c_uint,
    pub mtu: ::aya_bpf::cty::c_uint,
    pub tsize: ::aya_bpf::cty::c_uint,
}
pub mod netdev_tx {
    pub type Type = ::aya_bpf::cty::c_int;
    pub const __NETDEV_TX_MIN: Type = -2147483648;
    pub const NETDEV_TX_OK: Type = 0;
    pub const NETDEV_TX_BUSY: Type = 16;
}
pub use self::netdev_tx::Type as netdev_tx_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_core_stats {
    pub rx_dropped: ::aya_bpf::cty::c_ulong,
    pub tx_dropped: ::aya_bpf::cty::c_ulong,
    pub rx_nohandler: ::aya_bpf::cty::c_ulong,
    pub rx_otherhost_dropped: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: ::aya_bpf::cty::c_ushort,
            arg4: *const ::aya_bpf::cty::c_void,
            arg5: *const ::aya_bpf::cty::c_void,
            arg6: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sk_buff,
            arg2: *mut ::aya_bpf::cty::c_uchar,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const neighbour,
            arg2: *mut hh_cache,
            arg3: __be16,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cache_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut hh_cache,
            arg2: *const net_device,
            arg3: *const ::aya_bpf::cty::c_uchar,
        ),
    >,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> bool_,
    >,
    pub parse_protocol:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sk_buff) -> __be16>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_queue {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub qdisc: *mut Qdisc,
    pub qdisc_sleeping: *mut Qdisc,
    pub kobj: kobject,
    pub numa_node: ::aya_bpf::cty::c_int,
    pub tx_maxrate: ::aya_bpf::cty::c_ulong,
    pub trans_timeout: atomic_long_t,
    pub sb_dev: *mut net_device,
    pub pool: *mut xsk_buff_pool,
    pub _xmit_lock: spinlock_t,
    pub xmit_lock_owner: ::aya_bpf::cty::c_int,
    pub trans_start: ::aya_bpf::cty::c_ulong,
    pub state: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub dql: dql,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_skb_head {
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_stats_basic_sync {
    pub bytes: u64_stats_t,
    pub packets: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_stats_queue {
    pub qlen: __u32,
    pub backlog: __u32,
    pub drops: __u32,
    pub requeues: __u32,
    pub overlimits: __u32,
}
#[repr(C)]
pub struct Qdisc {
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut Qdisc,
            arg3: *mut *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub flags: ::aya_bpf::cty::c_uint,
    pub limit: u32_,
    pub ops: *const Qdisc_ops,
    pub stab: *mut qdisc_size_table,
    pub hash: hlist_node,
    pub handle: u32_,
    pub parent: u32_,
    pub dev_queue: *mut netdev_queue,
    pub rate_est: *mut net_rate_estimator,
    pub cpu_bstats: *mut gnet_stats_basic_sync,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub pad: ::aya_bpf::cty::c_int,
    pub refcnt: refcount_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub gso_skb: sk_buff_head,
    pub q: qdisc_skb_head,
    pub bstats: gnet_stats_basic_sync,
    pub qstats: gnet_stats_queue,
    pub state: ::aya_bpf::cty::c_ulong,
    pub state2: ::aya_bpf::cty::c_ulong,
    pub next_sched: *mut Qdisc,
    pub skb_bad_txq: sk_buff_head,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub busylock: spinlock_t,
    pub seqlock: spinlock_t,
    pub rcu: callback_head,
    pub dev_tracker: netdevice_tracker,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub privdata: __IncompleteArrayField<::aya_bpf::cty::c_long>,
}
impl Qdisc {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_map {
    pub len: ::aya_bpf::cty::c_uint,
    pub rcu: callback_head,
    pub cpus: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rps_dev_flow {
    pub cpu: u16_,
    pub filter: u16_,
    pub last_qtail: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct rps_dev_flow_table {
    pub mask: ::aya_bpf::cty::c_uint,
    pub rcu: callback_head,
    pub flows: __IncompleteArrayField<rps_dev_flow>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_rx_queue {
    pub xdp_rxq: xdp_rxq_info,
    pub rps_map: *mut rps_map,
    pub rps_flow_table: *mut rps_dev_flow_table,
    pub kobj: kobject,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub pool: *mut xsk_buff_pool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl netdev_rx_queue {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_map {
    pub len: ::aya_bpf::cty::c_uint,
    pub alloc_len: ::aya_bpf::cty::c_uint,
    pub rcu: callback_head,
    pub queues: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xps_dev_maps {
    pub rcu: callback_head,
    pub nr_ids: ::aya_bpf::cty::c_uint,
    pub num_tc: s16,
    pub attr_map: __IncompleteArrayField<*mut xps_map>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_fcoe_hbainfo {
    pub manufacturer: [::aya_bpf::cty::c_char; 64usize],
    pub serial_number: [::aya_bpf::cty::c_char; 64usize],
    pub hardware_version: [::aya_bpf::cty::c_char; 64usize],
    pub driver_version: [::aya_bpf::cty::c_char; 64usize],
    pub optionrom_version: [::aya_bpf::cty::c_char; 64usize],
    pub firmware_version: [::aya_bpf::cty::c_char; 64usize],
    pub model: [::aya_bpf::cty::c_char; 256usize],
    pub model_description: [::aya_bpf::cty::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_phys_item_id {
    pub id: [::aya_bpf::cty::c_uchar; 32usize],
    pub id_len: ::aya_bpf::cty::c_uchar,
}
pub mod net_device_path_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEV_PATH_ETHERNET: Type = 0;
    pub const DEV_PATH_VLAN: Type = 1;
    pub const DEV_PATH_BRIDGE: Type = 2;
    pub const DEV_PATH_PPPOE: Type = 3;
    pub const DEV_PATH_DSA: Type = 4;
    pub const DEV_PATH_MTK_WDMA: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_path {
    pub type_: net_device_path_type::Type,
    pub dev: *const net_device,
    pub __bindgen_anon_1: net_device_path__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_path__bindgen_ty_1 {
    pub encap: net_device_path__bindgen_ty_1__bindgen_ty_1,
    pub bridge: net_device_path__bindgen_ty_1__bindgen_ty_2,
    pub dsa: net_device_path__bindgen_ty_1__bindgen_ty_3,
    pub mtk_wdma: net_device_path__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_1 {
    pub id: u16_,
    pub proto: __be16,
    pub h_dest: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_2 {
    pub vlan_mode: net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1::Type,
    pub vlan_id: u16_,
    pub vlan_proto: __be16,
}
pub mod net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEV_PATH_BR_VLAN_KEEP: Type = 0;
    pub const DEV_PATH_BR_VLAN_TAG: Type = 1;
    pub const DEV_PATH_BR_VLAN_UNTAG: Type = 2;
    pub const DEV_PATH_BR_VLAN_UNTAG_HW: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_3 {
    pub port: ::aya_bpf::cty::c_int,
    pub proto: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_4 {
    pub wdma_idx: u8_,
    pub queue: u8_,
    pub wcid: u16_,
    pub bss: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path_ctx {
    pub dev: *const net_device,
    pub daddr: [u8_; 6usize],
    pub num_vlans: ::aya_bpf::cty::c_int,
    pub vlan: [net_device_path_ctx__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_path_ctx__bindgen_ty_1 {
    pub id: u16_,
    pub proto: __be16,
}
pub mod tc_setup_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TC_QUERY_CAPS: Type = 0;
    pub const TC_SETUP_QDISC_MQPRIO: Type = 1;
    pub const TC_SETUP_CLSU32: Type = 2;
    pub const TC_SETUP_CLSFLOWER: Type = 3;
    pub const TC_SETUP_CLSMATCHALL: Type = 4;
    pub const TC_SETUP_CLSBPF: Type = 5;
    pub const TC_SETUP_BLOCK: Type = 6;
    pub const TC_SETUP_QDISC_CBS: Type = 7;
    pub const TC_SETUP_QDISC_RED: Type = 8;
    pub const TC_SETUP_QDISC_PRIO: Type = 9;
    pub const TC_SETUP_QDISC_MQ: Type = 10;
    pub const TC_SETUP_QDISC_ETF: Type = 11;
    pub const TC_SETUP_ROOT_QDISC: Type = 12;
    pub const TC_SETUP_QDISC_GRED: Type = 13;
    pub const TC_SETUP_QDISC_TAPRIO: Type = 14;
    pub const TC_SETUP_FT: Type = 15;
    pub const TC_SETUP_QDISC_ETS: Type = 16;
    pub const TC_SETUP_QDISC_TBF: Type = 17;
    pub const TC_SETUP_QDISC_FIFO: Type = 18;
    pub const TC_SETUP_QDISC_HTB: Type = 19;
    pub const TC_SETUP_ACT: Type = 20;
}
pub mod bpf_netdev_command {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const XDP_SETUP_PROG: Type = 0;
    pub const XDP_SETUP_PROG_HW: Type = 1;
    pub const BPF_OFFLOAD_MAP_ALLOC: Type = 2;
    pub const BPF_OFFLOAD_MAP_FREE: Type = 3;
    pub const XDP_SETUP_XSK_POOL: Type = 4;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf {
    pub command: bpf_netdev_command::Type,
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_bpf__bindgen_ty_1 {
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: netdev_bpf__bindgen_ty_1__bindgen_ty_2,
    pub xsk: netdev_bpf__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    pub flags: u32_,
    pub prog: *mut bpf_prog,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    pub offmap: *mut bpf_offloaded_map,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    pub pool: *mut xsk_buff_pool,
    pub queue_id: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrmdev_ops {
    pub xdo_dev_state_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state) -> ::aya_bpf::cty::c_int,
    >,
    pub xdo_dev_state_delete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_state_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_offload_ok: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut xfrm_state) -> bool_,
    >,
    pub xdo_dev_state_advance_esn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_state_update_curlft:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub xdo_dev_policy_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_policy) -> ::aya_bpf::cty::c_int,
    >,
    pub xdo_dev_policy_delete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_policy)>,
    pub xdo_dev_policy_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_policy)>,
}
#[repr(C)]
#[derive(Debug)]
pub struct dev_ifalias {
    pub rcuhead: callback_head,
    pub ifalias: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device_ops {
    pub ndo_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_uninit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_start_xmit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> netdev_tx_t,
    >,
    pub ndo_features_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_select_queue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sk_buff,
            arg3: *mut net_device,
        ) -> u16_,
    >,
    pub ndo_change_rx_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int),
    >,
    pub ndo_set_rx_mode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_set_mac_address: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_validate_addr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_do_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_eth_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_siocbond: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_siocwandev: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut if_settings,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_siocdevprivate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_config: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ifmap) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_neigh_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut neigh_parms,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_tx_timeout: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub ndo_get_stats64: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut rtnl_link_stats64),
    >,
    pub ndo_has_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf::cty::c_int) -> bool_,
    >,
    pub ndo_get_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf::cty::c_int,
            arg2: *const net_device,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device_stats,
    >,
    pub ndo_vlan_rx_add_vid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: __be16,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_vlan_rx_kill_vid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: __be16,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_poll_controller: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_netpoll_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netpoll_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_netpoll_cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub ndo_set_vf_mac: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_vlan: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
            arg4: u8_,
            arg5: __be16,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_rate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_spoofchk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_trust: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_vf_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ifla_vf_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_vf_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ifla_vf_stats,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut *mut nlattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ifla_vf_guid,
            arg4: *mut ifla_vf_guid,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u64_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_vf_rss_query_en: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: tc_setup_type::Type,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_ddp_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u16_,
            arg3: *mut scatterlist,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_ddp_done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u16_) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_ddp_target: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u16_,
            arg3: *mut scatterlist,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_get_hbainfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_fcoe_hbainfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fcoe_get_wwn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u64_,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_rx_flow_steer: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const sk_buff,
            arg3: u16_,
            arg4: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_add_slave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_del_slave: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_xmit_slave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sk_buff,
            arg3: bool_,
        ) -> *mut net_device,
    >,
    pub ndo_sk_get_lower_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sock) -> *mut net_device,
    >,
    pub ndo_fix_features: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: netdev_features_t) -> netdev_features_t,
    >,
    pub ndo_set_features: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: netdev_features_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_neigh_construct: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neighbour) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_neigh_destroy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut neighbour)>,
    pub ndo_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndmsg,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf::cty::c_uchar,
            arg5: u16_,
            arg6: u16_,
            arg7: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndmsg,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf::cty::c_uchar,
            arg5: u16_,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fdb_del_bulk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ndmsg,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: u16_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut netlink_callback,
            arg3: *mut net_device,
            arg4: *mut net_device,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fdb_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut *mut nlattr,
            arg3: *mut net_device,
            arg4: *const ::aya_bpf::cty::c_uchar,
            arg5: u16_,
            arg6: u32_,
            arg7: u32_,
            arg8: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_bridge_setlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut nlmsghdr,
            arg3: u16_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_bridge_getlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut net_device,
            arg5: u32_,
            arg6: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_bridge_dellink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut nlmsghdr,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_change_carrier: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: bool_) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_phys_port_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_phys_item_id,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_port_parent_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut netdev_phys_item_id,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_phys_port_name: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_dfwd_add_station: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub ndo_dfwd_del_station: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub ndo_set_tx_maxrate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_iflink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_fill_metadata_dst: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_set_rx_headroom: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: ::aya_bpf::cty::c_int),
    >,
    pub ndo_bpf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut netdev_bpf) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_xdp_xmit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut *mut xdp_frame,
            arg4: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_xdp_get_xmit_slave: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut xdp_buff) -> *mut net_device,
    >,
    pub ndo_xsk_wakeup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_tunnel_ctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ip_tunnel_parm,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_peer_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut net_device>,
    pub ndo_fill_forward_path: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device_path_ctx,
            arg2: *mut net_device_path,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ndo_get_tstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const skb_shared_hwtstamps,
            arg3: bool_,
        ) -> ktime_t,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_parms {
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub list: list_head,
    pub neigh_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf::cty::c_int>,
    pub tbl: *mut neigh_table,
    pub sysctl_table: *mut ::aya_bpf::cty::c_void,
    pub dead: ::aya_bpf::cty::c_int,
    pub refcnt: refcount_t,
    pub callback_head: callback_head,
    pub reachable_time: ::aya_bpf::cty::c_int,
    pub qlen: u32_,
    pub data: [::aya_bpf::cty::c_int; 14usize],
    pub data_state: [::aya_bpf::cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_lstats {
    pub packets: u64_stats_t,
    pub bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_sw_netstats {
    pub rx_packets: u64_stats_t,
    pub rx_bytes: u64_stats_t,
    pub tx_packets: u64_stats_t,
    pub tx_bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
}
pub type iw_handler = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut net_device,
        arg2: *mut iw_request_info,
        arg3: *mut iwreq_data,
        arg4: *mut ::aya_bpf::cty::c_char,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_handler_def {
    pub standard: *const iw_handler,
    pub num_standard: __u16,
    pub num_private: __u16,
    pub num_private_args: __u16,
    pub private: *const iw_handler,
    pub private_args: *const iw_priv_args,
    pub get_wireless_stats:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> *mut iw_statistics>,
}
pub mod ethtool_phys_id_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_ID_INACTIVE: Type = 0;
    pub const ETHTOOL_ID_ACTIVE: Type = 1;
    pub const ETHTOOL_ID_ON: Type = 2;
    pub const ETHTOOL_ID_OFF: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ops {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub supported_coalesce_params: u32_,
    pub supported_ring_params: u32_,
    pub get_drvinfo: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_drvinfo),
    >,
    pub get_regs_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_regs,
            arg3: *mut ::aya_bpf::cty::c_void,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_wolinfo),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_wolinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_msglevel: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_msglevel:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_)>,
    pub nway_reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_link_ext_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ext_state_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_link_ext_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_link_ext_stats),
    >,
    pub get_eeprom_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_coalesce,
            arg3: *mut kernel_ethtool_coalesce,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ),
    >,
    pub set_ringparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ringparam,
            arg3: *mut kernel_ethtool_ringparam,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_pause_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pause_stats),
    >,
    pub get_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_pauseparam),
    >,
    pub set_pauseparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_pauseparam,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_test, arg3: *mut u64_),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_, arg3: *mut u8_),
    >,
    pub set_phys_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ethtool_phys_id_state::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub begin: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub get_priv_flags: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub set_priv_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: u32_) -> ::aya_bpf::cty::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
            arg3: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rxnfc,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flash_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_flash,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut u32_) -> ::aya_bpf::cty::c_int,
    >,
    pub get_rxfh_key_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh_indir_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> u32_>,
    pub get_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u32_,
            arg3: *mut u8_,
            arg4: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_rxfh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const u32_,
            arg3: *const u8_,
            arg4: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut u32_,
            arg3: *mut u8_,
            arg4: *mut u8_,
            arg5: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_rxfh_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const u32_,
            arg3: *const u8_,
            arg4: u8_,
            arg5: *mut u32_,
            arg6: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_channels: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_channels),
    >,
    pub set_channels: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_channels,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dump_flag: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dump_data: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_dump,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_ts_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_module_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_modinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eee,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_eee,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_per_queue_coalesce: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: u32_,
            arg3: *mut ethtool_coalesce,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_link_ksettings,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_link_ksettings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_link_ksettings,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_fec_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_fec_stats),
    >,
    pub get_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_fecparam: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_fecparam,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_phy_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_tunable,
            arg3: *const ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_module_eeprom_by_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_module_eeprom,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_eth_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eth_phy_stats),
    >,
    pub get_eth_mac_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eth_mac_stats),
    >,
    pub get_eth_ctrl_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ethtool_eth_ctrl_stats),
    >,
    pub get_rmon_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_rmon_stats,
            arg3: *mut *const ethtool_rmon_hist_range,
        ),
    >,
    pub get_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ethtool_module_power_mode_params,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_module_power_mode: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *const ethtool_module_power_mode_params,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
impl ethtool_ops {
    #[inline]
    pub fn cap_link_lanes_supported(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cap_link_lanes_supported(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cap_link_lanes_supported: u32_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cap_link_lanes_supported: u32 =
                unsafe { ::core::mem::transmute(cap_link_lanes_supported) };
            cap_link_lanes_supported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct l3mdev_ops {
    pub l3mdev_fib_table:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> u32_>,
    pub l3mdev_l3_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut sk_buff, arg3: u16_) -> *mut sk_buff,
    >,
    pub l3mdev_l3_out: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: *mut sk_buff,
            arg4: u16_,
        ) -> *mut sk_buff,
    >,
    pub l3mdev_link_scope_lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *mut flowi6) -> *mut dst_entry,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndisc_ops {
    pub is_useropt:
        ::core::option::Option<unsafe extern "C" fn(arg1: u8_) -> ::aya_bpf::cty::c_int>,
    pub parse_options: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut nd_opt_hdr,
            arg3: *mut ndisc_options,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut neighbour,
            arg3: u32_,
            arg4: u8_,
            arg5: *const ndisc_options,
        ),
    >,
    pub opt_addr_space: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: u8_,
            arg3: *mut neighbour,
            arg4: *mut u8_,
            arg5: *mut *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_addr_option: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const net_device,
            arg2: *mut sk_buff,
            arg3: u8_,
            arg4: *const u8_,
        ),
    >,
    pub prefix_rcv_add_addr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut net_device,
            arg3: *const prefix_info,
            arg4: *mut inet6_dev,
            arg5: *mut in6_addr,
            arg6: ::aya_bpf::cty::c_int,
            arg7: u32_,
            arg8: bool_,
            arg9: bool_,
            arg10: __u32,
            arg11: u32_,
            arg12: bool_,
        ),
    >,
}
pub mod tls_offload_ctx_dir {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const TLS_OFFLOAD_CTX_DIR_RX: Type = 0;
    pub const TLS_OFFLOAD_CTX_DIR_TX: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlsdev_ops {
    pub tls_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: tls_offload_ctx_dir::Type,
            arg4: *mut tls_crypto_info,
            arg5: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub tls_dev_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut tls_context,
            arg3: tls_offload_ctx_dir::Type,
        ),
    >,
    pub tls_dev_resync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut sock,
            arg3: u32_,
            arg4: *mut u8_,
            arg5: tls_offload_ctx_dir::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mini_Qdisc {
    pub filter_list: *mut tcf_proto,
    pub block: *mut tcf_block,
    pub cpu_bstats: *mut gnet_stats_basic_sync,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub rcu_state: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtnl_link_ops {
    pub list: list_head,
    pub kind: *const ::aya_bpf::cty::c_char,
    pub priv_size: usize,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut nlattr,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: ::aya_bpf::cty::c_uchar,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> *mut net_device,
    >,
    pub setup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub netns_refund: bool_,
    pub maxtype: ::aya_bpf::cty::c_uint,
    pub policy: *const nla_policy,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut nlattr,
            arg2: *mut *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub newlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut net_device,
            arg3: *mut *mut nlattr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub changelink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut *mut nlattr,
            arg3: *mut *mut nlattr,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dellink:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut list_head)>,
    pub get_size: ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> usize>,
    pub fill_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *const net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_xstats_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> usize>,
    pub fill_xstats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *const net_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_num_tx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf::cty::c_uint>,
    pub get_num_rx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::aya_bpf::cty::c_uint>,
    pub slave_maxtype: ::aya_bpf::cty::c_uint,
    pub slave_policy: *const nla_policy,
    pub slave_changelink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut net_device,
            arg3: *mut *mut nlattr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_slave_size: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *const net_device) -> usize,
    >,
    pub fill_slave_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const net_device,
            arg3: *const net_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_link_net:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const net_device) -> *mut net>,
    pub get_linkxstats_size: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: ::aya_bpf::cty::c_int) -> usize,
    >,
    pub fill_linkxstats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const net_device,
            arg3: *mut ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_ops {
    pub mdo_dev_open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_dev_stop: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_add_secy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_upd_secy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_del_secy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_add_rxsc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_upd_rxsc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_del_rxsc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_add_rxsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_upd_rxsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_del_rxsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_add_txsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_upd_txsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_del_txsa: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_get_dev_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_get_tx_sc_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_get_tx_sa_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_get_rx_sc_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
    pub mdo_get_rx_sa_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut macsec_context) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_table_info {
    pub n_entries: ::aya_bpf::cty::c_uint,
    pub tunnel_types: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_info {
    pub set_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut udp_tunnel_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unset_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut udp_tunnel_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sync_table: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub shared: *mut udp_tunnel_nic_shared,
    pub flags: ::aya_bpf::cty::c_uint,
    pub tables: [udp_tunnel_nic_table_info; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcmsg {
    pub tcm_family: ::aya_bpf::cty::c_uchar,
    pub tcm__pad1: ::aya_bpf::cty::c_uchar,
    pub tcm__pad2: ::aya_bpf::cty::c_ushort,
    pub tcm_ifindex: ::aya_bpf::cty::c_int,
    pub tcm_handle: __u32,
    pub tcm_parent: __u32,
    pub tcm_info: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_range_validation {
    pub min: u64_,
    pub max: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netlink_range_validation_signed {
    pub min: s64,
    pub max: s64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_table {
    pub family: ::aya_bpf::cty::c_int,
    pub entry_size: ::aya_bpf::cty::c_uint,
    pub key_len: ::aya_bpf::cty::c_uint,
    pub protocol: __be16,
    pub hash: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_void,
            arg2: *const net_device,
            arg3: *mut __u32,
        ) -> __u32,
    >,
    pub key_eq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const neighbour, arg2: *const ::aya_bpf::cty::c_void) -> bool_,
    >,
    pub constructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::aya_bpf::cty::c_int>,
    pub pconstructor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pneigh_entry) -> ::aya_bpf::cty::c_int,
    >,
    pub pdestructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
    pub proxy_redo: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub is_multicast: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_void) -> ::aya_bpf::cty::c_int,
    >,
    pub allow_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const net_device, arg2: *mut netlink_ext_ack) -> bool_,
    >,
    pub id: *mut ::aya_bpf::cty::c_char,
    pub parms: neigh_parms,
    pub parms_list: list_head,
    pub gc_interval: ::aya_bpf::cty::c_int,
    pub gc_thresh1: ::aya_bpf::cty::c_int,
    pub gc_thresh2: ::aya_bpf::cty::c_int,
    pub gc_thresh3: ::aya_bpf::cty::c_int,
    pub last_flush: ::aya_bpf::cty::c_ulong,
    pub gc_work: delayed_work,
    pub managed_work: delayed_work,
    pub proxy_timer: timer_list,
    pub proxy_queue: sk_buff_head,
    pub entries: atomic_t,
    pub gc_entries: atomic_t,
    pub gc_list: list_head,
    pub managed_list: list_head,
    pub lock: rwlock_t,
    pub last_rand: ::aya_bpf::cty::c_ulong,
    pub stats: *mut neigh_statistics,
    pub nht: *mut neigh_hash_table,
    pub phash_buckets: *mut *mut pneigh_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_statistics {
    pub allocs: ::aya_bpf::cty::c_ulong,
    pub destroys: ::aya_bpf::cty::c_ulong,
    pub hash_grows: ::aya_bpf::cty::c_ulong,
    pub res_failed: ::aya_bpf::cty::c_ulong,
    pub lookups: ::aya_bpf::cty::c_ulong,
    pub hits: ::aya_bpf::cty::c_ulong,
    pub rcv_probes_mcast: ::aya_bpf::cty::c_ulong,
    pub rcv_probes_ucast: ::aya_bpf::cty::c_ulong,
    pub periodic_gc_runs: ::aya_bpf::cty::c_ulong,
    pub forced_gc_runs: ::aya_bpf::cty::c_ulong,
    pub unres_discards: ::aya_bpf::cty::c_ulong,
    pub table_fulls: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_ops {
    pub family: ::aya_bpf::cty::c_int,
    pub solicit:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub error_report:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub connected_output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug)]
pub struct pneigh_entry {
    pub next: *mut pneigh_entry,
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub flags: u32_,
    pub protocol: u8_,
    pub key: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct neigh_hash_table {
    pub hash_buckets: *mut *mut neighbour,
    pub hash_shift: ::aya_bpf::cty::c_uint,
    pub hash_rnd: [__u32; 4usize],
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule_hdr {
    pub family: __u8,
    pub dst_len: __u8,
    pub src_len: __u8,
    pub tos: __u8,
    pub table: __u8,
    pub res1: __u8,
    pub res2: __u8,
    pub action: __u8,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule_port_range {
    pub start: __u16,
    pub end: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_kuid_range {
    pub start: kuid_t,
    pub end: kuid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_rule {
    pub list: list_head,
    pub iifindex: ::aya_bpf::cty::c_int,
    pub oifindex: ::aya_bpf::cty::c_int,
    pub mark: u32_,
    pub mark_mask: u32_,
    pub flags: u32_,
    pub table: u32_,
    pub action: u8_,
    pub l3mdev: u8_,
    pub proto: u8_,
    pub ip_proto: u8_,
    pub target: u32_,
    pub tun_id: __be64,
    pub ctarget: *mut fib_rule,
    pub fr_net: *mut net,
    pub refcnt: refcount_t,
    pub pref: u32_,
    pub suppress_ifgroup: ::aya_bpf::cty::c_int,
    pub suppress_prefixlen: ::aya_bpf::cty::c_int,
    pub iifname: [::aya_bpf::cty::c_char; 16usize],
    pub oifname: [::aya_bpf::cty::c_char; 16usize],
    pub uid_range: fib_kuid_range,
    pub sport_range: fib_rule_port_range,
    pub dport_range: fib_rule_port_range,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_lookup_arg {
    pub lookup_ptr: *mut ::aya_bpf::cty::c_void,
    pub lookup_data: *const ::aya_bpf::cty::c_void,
    pub result: *mut ::aya_bpf::cty::c_void,
    pub rule: *mut fib_rule,
    pub table: u32_,
    pub flags: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smc_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto {
    pub close:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_long)>,
    pub pre_connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_int,
            arg4: bool_,
        ) -> *mut sock,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf::cty::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub shutdown:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int)>,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: sockptr_t,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ::aya_bpf::cty::c_char,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub keepalive:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int)>,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut msghdr,
            arg3: usize,
            arg4: ::aya_bpf::cty::c_int,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_int,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub bind_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sockaddr,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub bpf_bypass_getsockopt: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_bpf::cty::c_int, arg2: ::aya_bpf::cty::c_int) -> bool_,
    >,
    pub release_cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub hash:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> ::aya_bpf::cty::c_int>,
    pub unhash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub rehash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub get_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: ::aya_bpf::cty::c_ushort,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub put_port: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub psock_update_sk_prot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sk_psock,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub inuse_idx: ::aya_bpf::cty::c_uint,
    pub forward_alloc_get:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sock) -> ::aya_bpf::cty::c_int>,
    pub stream_memory_free: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: ::aya_bpf::cty::c_int) -> bool_,
    >,
    pub sock_is_readable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock) -> bool_>,
    pub enter_memory_pressure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub leave_memory_pressure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub memory_allocated: *mut atomic_long_t,
    pub per_cpu_fw_alloc: *mut ::aya_bpf::cty::c_int,
    pub sockets_allocated: *mut percpu_counter,
    pub memory_pressure: *mut ::aya_bpf::cty::c_ulong,
    pub sysctl_mem: *mut ::aya_bpf::cty::c_long,
    pub sysctl_wmem: *mut ::aya_bpf::cty::c_int,
    pub sysctl_rmem: *mut ::aya_bpf::cty::c_int,
    pub sysctl_wmem_offset: u32_,
    pub sysctl_rmem_offset: u32_,
    pub max_header: ::aya_bpf::cty::c_int,
    pub no_autobind: bool_,
    pub slab: *mut kmem_cache,
    pub obj_size: ::aya_bpf::cty::c_uint,
    pub slab_flags: slab_flags_t,
    pub useroffset: ::aya_bpf::cty::c_uint,
    pub usersize: ::aya_bpf::cty::c_uint,
    pub orphan_count: *mut ::aya_bpf::cty::c_uint,
    pub rsk_prot: *mut request_sock_ops,
    pub twsk_prot: *mut timewait_sock_ops,
    pub h: proto__bindgen_ty_1,
    pub owner: *mut module,
    pub name: [::aya_bpf::cty::c_char; 32usize],
    pub node: list_head,
    pub diag_destroy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proto__bindgen_ty_1 {
    pub hashinfo: *mut inet_hashinfo,
    pub udp_table: *mut udp_table,
    pub raw_hash: *mut raw_hashinfo,
    pub smc_hash: *mut smc_hashinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_filter {
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub prog: *mut bpf_prog,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_storage_buffer {
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnet_dump {
    pub lock: *mut spinlock_t,
    pub skb: *mut sk_buff,
    pub tail: *mut nlattr,
    pub compat_tc_stats: ::aya_bpf::cty::c_int,
    pub compat_xstats: ::aya_bpf::cty::c_int,
    pub padattr: ::aya_bpf::cty::c_int,
    pub xstats: *mut ::aya_bpf::cty::c_void,
    pub xstats_len: ::aya_bpf::cty::c_int,
    pub tc_stats: tc_stats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_block {
    pub cb_list: list_head,
}
pub type flow_setup_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: tc_setup_type::Type,
        arg2: *mut ::aya_bpf::cty::c_void,
        arg3: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug)]
pub struct qdisc_size_table {
    pub rcu: callback_head,
    pub list: list_head,
    pub szopts: tc_sizespec,
    pub refcnt: ::aya_bpf::cty::c_int,
    pub data: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qdisc_ops {
    pub next: *mut Qdisc_ops,
    pub cl_ops: *const Qdisc_class_ops,
    pub id: [::aya_bpf::cty::c_char; 16usize],
    pub priv_size: ::aya_bpf::cty::c_int,
    pub static_flags: ::aya_bpf::cty::c_uint,
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut Qdisc,
            arg3: *mut *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub peek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: *mut nlattr,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change_tx_queue_len: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub change_real_num_tx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut gnet_dump) -> ::aya_bpf::cty::c_int,
    >,
    pub ingress_block_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>,
    pub egress_block_set:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_)>,
    pub ingress_block_get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>,
    pub egress_block_get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> u32_>,
    pub owner: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Qdisc_class_ops {
    pub flags: ::aya_bpf::cty::c_uint,
    pub select_queue: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut tcmsg) -> *mut netdev_queue,
    >,
    pub graft: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut Qdisc,
            arg4: *mut *mut Qdisc,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub leaf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf::cty::c_ulong) -> *mut Qdisc,
    >,
    pub qlen_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf::cty::c_ulong),
    >,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: u32_) -> ::aya_bpf::cty::c_ulong,
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut ::aya_bpf::cty::c_ulong,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub walk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut qdisc_walker)>,
    pub tcf_block: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut netlink_ext_ack,
        ) -> *mut tcf_block,
    >,
    pub bind_tcf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_ulong,
    >,
    pub unbind_tcf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: ::aya_bpf::cty::c_ulong),
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut sk_buff,
            arg4: *mut tcmsg,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut gnet_dump,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_block {
    pub lock: mutex,
    pub chain_list: list_head,
    pub index: u32_,
    pub classid: u32_,
    pub refcnt: refcount_t,
    pub net: *mut net,
    pub q: *mut Qdisc,
    pub cb_lock: rw_semaphore,
    pub flow_block: flow_block,
    pub owner_list: list_head,
    pub keep_dst: bool_,
    pub offloadcnt: atomic_t,
    pub nooffloaddevcnt: ::aya_bpf::cty::c_uint,
    pub lockeddevcnt: ::aya_bpf::cty::c_uint,
    pub chain0: tcf_block__bindgen_ty_1,
    pub rcu: callback_head,
    pub proto_destroy_ht: [hlist_head; 128usize],
    pub proto_destroy_lock: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_block__bindgen_ty_1 {
    pub chain: *mut tcf_chain,
    pub filter_chain_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_proto {
    pub next: *mut tcf_proto,
    pub root: *mut ::aya_bpf::cty::c_void,
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub protocol: __be16,
    pub prio: u32_,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub ops: *const tcf_proto_ops,
    pub chain: *mut tcf_chain,
    pub lock: spinlock_t,
    pub deleting: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub destroy_ht_node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_result {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcf_result__bindgen_ty_1 {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1__bindgen_ty_1,
    pub goto_tp: *const tcf_proto,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_1 {
    pub class: ::aya_bpf::cty::c_ulong,
    pub classid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_proto_ops {
    pub head: list_head,
    pub kind: [::aya_bpf::cty::c_char; 16usize],
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> ::aya_bpf::cty::c_int>,
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: bool_, arg3: *mut netlink_ext_ack),
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: u32_) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sk_buff,
            arg3: *mut tcf_proto,
            arg4: ::aya_bpf::cty::c_ulong,
            arg5: u32_,
            arg6: *mut *mut nlattr,
            arg7: *mut *mut ::aya_bpf::cty::c_void,
            arg8: u32_,
            arg9: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut bool_,
            arg4: bool_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub delete_empty: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> bool_>,
    pub walk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut tcf_walker, arg3: bool_),
    >,
    pub reoffload: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: bool_,
            arg3: flow_setup_cb_t,
            arg4: *mut ::aya_bpf::cty::c_void,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub hw_add: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub hw_del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub bind_class: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_void,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_ulong,
            arg4: *mut ::aya_bpf::cty::c_void,
            arg5: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub tmplt_create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_chain,
            arg3: *mut *mut nlattr,
            arg4: *mut netlink_ext_ack,
        ) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub tmplt_destroy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: *mut sk_buff,
            arg5: *mut tcmsg,
            arg6: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub terse_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: *mut sk_buff,
            arg5: *mut tcmsg,
            arg6: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub tmplt_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub owner: *mut module,
    pub flags: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_chain {
    pub filter_chain_lock: mutex,
    pub filter_chain: *mut tcf_proto,
    pub list: list_head,
    pub block: *mut tcf_block,
    pub index: u32_,
    pub refcnt: ::aya_bpf::cty::c_uint,
    pub action_refcnt: ::aya_bpf::cty::c_uint,
    pub explicitly_created: bool_,
    pub flushing: bool_,
    pub tmplt_ops: *const tcf_proto_ops,
    pub tmplt_priv: *mut ::aya_bpf::cty::c_void,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fdtable {
    pub max_fds: ::aya_bpf::cty::c_uint,
    pub fd: *mut *mut file,
    pub close_on_exec: *mut ::aya_bpf::cty::c_ulong,
    pub open_fds: *mut ::aya_bpf::cty::c_ulong,
    pub full_fds_bits: *mut ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct files_struct {
    pub count: atomic_t,
    pub resize_in_progress: bool_,
    pub resize_wait: wait_queue_head_t,
    pub fdt: *mut fdtable,
    pub fdtab: fdtable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub file_lock: spinlock_t,
    pub next_fd: ::aya_bpf::cty::c_uint,
    pub close_on_exec_init: [::aya_bpf::cty::c_ulong; 1usize],
    pub open_fds_init: [::aya_bpf::cty::c_ulong; 1usize],
    pub full_fds_bits_init: [::aya_bpf::cty::c_ulong; 1usize],
    pub fd_array: [*mut file; 64usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl files_struct {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
pub mod bpf_func_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_FUNC_unspec: Type = 0;
    pub const BPF_FUNC_map_lookup_elem: Type = 1;
    pub const BPF_FUNC_map_update_elem: Type = 2;
    pub const BPF_FUNC_map_delete_elem: Type = 3;
    pub const BPF_FUNC_probe_read: Type = 4;
    pub const BPF_FUNC_ktime_get_ns: Type = 5;
    pub const BPF_FUNC_trace_printk: Type = 6;
    pub const BPF_FUNC_get_prandom_u32: Type = 7;
    pub const BPF_FUNC_get_smp_processor_id: Type = 8;
    pub const BPF_FUNC_skb_store_bytes: Type = 9;
    pub const BPF_FUNC_l3_csum_replace: Type = 10;
    pub const BPF_FUNC_l4_csum_replace: Type = 11;
    pub const BPF_FUNC_tail_call: Type = 12;
    pub const BPF_FUNC_clone_redirect: Type = 13;
    pub const BPF_FUNC_get_current_pid_tgid: Type = 14;
    pub const BPF_FUNC_get_current_uid_gid: Type = 15;
    pub const BPF_FUNC_get_current_comm: Type = 16;
    pub const BPF_FUNC_get_cgroup_classid: Type = 17;
    pub const BPF_FUNC_skb_vlan_push: Type = 18;
    pub const BPF_FUNC_skb_vlan_pop: Type = 19;
    pub const BPF_FUNC_skb_get_tunnel_key: Type = 20;
    pub const BPF_FUNC_skb_set_tunnel_key: Type = 21;
    pub const BPF_FUNC_perf_event_read: Type = 22;
    pub const BPF_FUNC_redirect: Type = 23;
    pub const BPF_FUNC_get_route_realm: Type = 24;
    pub const BPF_FUNC_perf_event_output: Type = 25;
    pub const BPF_FUNC_skb_load_bytes: Type = 26;
    pub const BPF_FUNC_get_stackid: Type = 27;
    pub const BPF_FUNC_csum_diff: Type = 28;
    pub const BPF_FUNC_skb_get_tunnel_opt: Type = 29;
    pub const BPF_FUNC_skb_set_tunnel_opt: Type = 30;
    pub const BPF_FUNC_skb_change_proto: Type = 31;
    pub const BPF_FUNC_skb_change_type: Type = 32;
    pub const BPF_FUNC_skb_under_cgroup: Type = 33;
    pub const BPF_FUNC_get_hash_recalc: Type = 34;
    pub const BPF_FUNC_get_current_task: Type = 35;
    pub const BPF_FUNC_probe_write_user: Type = 36;
    pub const BPF_FUNC_current_task_under_cgroup: Type = 37;
    pub const BPF_FUNC_skb_change_tail: Type = 38;
    pub const BPF_FUNC_skb_pull_data: Type = 39;
    pub const BPF_FUNC_csum_update: Type = 40;
    pub const BPF_FUNC_set_hash_invalid: Type = 41;
    pub const BPF_FUNC_get_numa_node_id: Type = 42;
    pub const BPF_FUNC_skb_change_head: Type = 43;
    pub const BPF_FUNC_xdp_adjust_head: Type = 44;
    pub const BPF_FUNC_probe_read_str: Type = 45;
    pub const BPF_FUNC_get_socket_cookie: Type = 46;
    pub const BPF_FUNC_get_socket_uid: Type = 47;
    pub const BPF_FUNC_set_hash: Type = 48;
    pub const BPF_FUNC_setsockopt: Type = 49;
    pub const BPF_FUNC_skb_adjust_room: Type = 50;
    pub const BPF_FUNC_redirect_map: Type = 51;
    pub const BPF_FUNC_sk_redirect_map: Type = 52;
    pub const BPF_FUNC_sock_map_update: Type = 53;
    pub const BPF_FUNC_xdp_adjust_meta: Type = 54;
    pub const BPF_FUNC_perf_event_read_value: Type = 55;
    pub const BPF_FUNC_perf_prog_read_value: Type = 56;
    pub const BPF_FUNC_getsockopt: Type = 57;
    pub const BPF_FUNC_override_return: Type = 58;
    pub const BPF_FUNC_sock_ops_cb_flags_set: Type = 59;
    pub const BPF_FUNC_msg_redirect_map: Type = 60;
    pub const BPF_FUNC_msg_apply_bytes: Type = 61;
    pub const BPF_FUNC_msg_cork_bytes: Type = 62;
    pub const BPF_FUNC_msg_pull_data: Type = 63;
    pub const BPF_FUNC_bind: Type = 64;
    pub const BPF_FUNC_xdp_adjust_tail: Type = 65;
    pub const BPF_FUNC_skb_get_xfrm_state: Type = 66;
    pub const BPF_FUNC_get_stack: Type = 67;
    pub const BPF_FUNC_skb_load_bytes_relative: Type = 68;
    pub const BPF_FUNC_fib_lookup: Type = 69;
    pub const BPF_FUNC_sock_hash_update: Type = 70;
    pub const BPF_FUNC_msg_redirect_hash: Type = 71;
    pub const BPF_FUNC_sk_redirect_hash: Type = 72;
    pub const BPF_FUNC_lwt_push_encap: Type = 73;
    pub const BPF_FUNC_lwt_seg6_store_bytes: Type = 74;
    pub const BPF_FUNC_lwt_seg6_adjust_srh: Type = 75;
    pub const BPF_FUNC_lwt_seg6_action: Type = 76;
    pub const BPF_FUNC_rc_repeat: Type = 77;
    pub const BPF_FUNC_rc_keydown: Type = 78;
    pub const BPF_FUNC_skb_cgroup_id: Type = 79;
    pub const BPF_FUNC_get_current_cgroup_id: Type = 80;
    pub const BPF_FUNC_get_local_storage: Type = 81;
    pub const BPF_FUNC_sk_select_reuseport: Type = 82;
    pub const BPF_FUNC_skb_ancestor_cgroup_id: Type = 83;
    pub const BPF_FUNC_sk_lookup_tcp: Type = 84;
    pub const BPF_FUNC_sk_lookup_udp: Type = 85;
    pub const BPF_FUNC_sk_release: Type = 86;
    pub const BPF_FUNC_map_push_elem: Type = 87;
    pub const BPF_FUNC_map_pop_elem: Type = 88;
    pub const BPF_FUNC_map_peek_elem: Type = 89;
    pub const BPF_FUNC_msg_push_data: Type = 90;
    pub const BPF_FUNC_msg_pop_data: Type = 91;
    pub const BPF_FUNC_rc_pointer_rel: Type = 92;
    pub const BPF_FUNC_spin_lock: Type = 93;
    pub const BPF_FUNC_spin_unlock: Type = 94;
    pub const BPF_FUNC_sk_fullsock: Type = 95;
    pub const BPF_FUNC_tcp_sock: Type = 96;
    pub const BPF_FUNC_skb_ecn_set_ce: Type = 97;
    pub const BPF_FUNC_get_listener_sock: Type = 98;
    pub const BPF_FUNC_skc_lookup_tcp: Type = 99;
    pub const BPF_FUNC_tcp_check_syncookie: Type = 100;
    pub const BPF_FUNC_sysctl_get_name: Type = 101;
    pub const BPF_FUNC_sysctl_get_current_value: Type = 102;
    pub const BPF_FUNC_sysctl_get_new_value: Type = 103;
    pub const BPF_FUNC_sysctl_set_new_value: Type = 104;
    pub const BPF_FUNC_strtol: Type = 105;
    pub const BPF_FUNC_strtoul: Type = 106;
    pub const BPF_FUNC_sk_storage_get: Type = 107;
    pub const BPF_FUNC_sk_storage_delete: Type = 108;
    pub const BPF_FUNC_send_signal: Type = 109;
    pub const BPF_FUNC_tcp_gen_syncookie: Type = 110;
    pub const BPF_FUNC_skb_output: Type = 111;
    pub const BPF_FUNC_probe_read_user: Type = 112;
    pub const BPF_FUNC_probe_read_kernel: Type = 113;
    pub const BPF_FUNC_probe_read_user_str: Type = 114;
    pub const BPF_FUNC_probe_read_kernel_str: Type = 115;
    pub const BPF_FUNC_tcp_send_ack: Type = 116;
    pub const BPF_FUNC_send_signal_thread: Type = 117;
    pub const BPF_FUNC_jiffies64: Type = 118;
    pub const BPF_FUNC_read_branch_records: Type = 119;
    pub const BPF_FUNC_get_ns_current_pid_tgid: Type = 120;
    pub const BPF_FUNC_xdp_output: Type = 121;
    pub const BPF_FUNC_get_netns_cookie: Type = 122;
    pub const BPF_FUNC_get_current_ancestor_cgroup_id: Type = 123;
    pub const BPF_FUNC_sk_assign: Type = 124;
    pub const BPF_FUNC_ktime_get_boot_ns: Type = 125;
    pub const BPF_FUNC_seq_printf: Type = 126;
    pub const BPF_FUNC_seq_write: Type = 127;
    pub const BPF_FUNC_sk_cgroup_id: Type = 128;
    pub const BPF_FUNC_sk_ancestor_cgroup_id: Type = 129;
    pub const BPF_FUNC_ringbuf_output: Type = 130;
    pub const BPF_FUNC_ringbuf_reserve: Type = 131;
    pub const BPF_FUNC_ringbuf_submit: Type = 132;
    pub const BPF_FUNC_ringbuf_discard: Type = 133;
    pub const BPF_FUNC_ringbuf_query: Type = 134;
    pub const BPF_FUNC_csum_level: Type = 135;
    pub const BPF_FUNC_skc_to_tcp6_sock: Type = 136;
    pub const BPF_FUNC_skc_to_tcp_sock: Type = 137;
    pub const BPF_FUNC_skc_to_tcp_timewait_sock: Type = 138;
    pub const BPF_FUNC_skc_to_tcp_request_sock: Type = 139;
    pub const BPF_FUNC_skc_to_udp6_sock: Type = 140;
    pub const BPF_FUNC_get_task_stack: Type = 141;
    pub const BPF_FUNC_load_hdr_opt: Type = 142;
    pub const BPF_FUNC_store_hdr_opt: Type = 143;
    pub const BPF_FUNC_reserve_hdr_opt: Type = 144;
    pub const BPF_FUNC_inode_storage_get: Type = 145;
    pub const BPF_FUNC_inode_storage_delete: Type = 146;
    pub const BPF_FUNC_d_path: Type = 147;
    pub const BPF_FUNC_copy_from_user: Type = 148;
    pub const BPF_FUNC_snprintf_btf: Type = 149;
    pub const BPF_FUNC_seq_printf_btf: Type = 150;
    pub const BPF_FUNC_skb_cgroup_classid: Type = 151;
    pub const BPF_FUNC_redirect_neigh: Type = 152;
    pub const BPF_FUNC_per_cpu_ptr: Type = 153;
    pub const BPF_FUNC_this_cpu_ptr: Type = 154;
    pub const BPF_FUNC_redirect_peer: Type = 155;
    pub const BPF_FUNC_task_storage_get: Type = 156;
    pub const BPF_FUNC_task_storage_delete: Type = 157;
    pub const BPF_FUNC_get_current_task_btf: Type = 158;
    pub const BPF_FUNC_bprm_opts_set: Type = 159;
    pub const BPF_FUNC_ktime_get_coarse_ns: Type = 160;
    pub const BPF_FUNC_ima_inode_hash: Type = 161;
    pub const BPF_FUNC_sock_from_file: Type = 162;
    pub const BPF_FUNC_check_mtu: Type = 163;
    pub const BPF_FUNC_for_each_map_elem: Type = 164;
    pub const BPF_FUNC_snprintf: Type = 165;
    pub const BPF_FUNC_sys_bpf: Type = 166;
    pub const BPF_FUNC_btf_find_by_name_kind: Type = 167;
    pub const BPF_FUNC_sys_close: Type = 168;
    pub const BPF_FUNC_timer_init: Type = 169;
    pub const BPF_FUNC_timer_set_callback: Type = 170;
    pub const BPF_FUNC_timer_start: Type = 171;
    pub const BPF_FUNC_timer_cancel: Type = 172;
    pub const BPF_FUNC_get_func_ip: Type = 173;
    pub const BPF_FUNC_get_attach_cookie: Type = 174;
    pub const BPF_FUNC_task_pt_regs: Type = 175;
    pub const BPF_FUNC_get_branch_snapshot: Type = 176;
    pub const BPF_FUNC_trace_vprintk: Type = 177;
    pub const BPF_FUNC_skc_to_unix_sock: Type = 178;
    pub const BPF_FUNC_kallsyms_lookup_name: Type = 179;
    pub const BPF_FUNC_find_vma: Type = 180;
    pub const BPF_FUNC_loop: Type = 181;
    pub const BPF_FUNC_strncmp: Type = 182;
    pub const BPF_FUNC_get_func_arg: Type = 183;
    pub const BPF_FUNC_get_func_ret: Type = 184;
    pub const BPF_FUNC_get_func_arg_cnt: Type = 185;
    pub const BPF_FUNC_get_retval: Type = 186;
    pub const BPF_FUNC_set_retval: Type = 187;
    pub const BPF_FUNC_xdp_get_buff_len: Type = 188;
    pub const BPF_FUNC_xdp_load_bytes: Type = 189;
    pub const BPF_FUNC_xdp_store_bytes: Type = 190;
    pub const BPF_FUNC_copy_from_user_task: Type = 191;
    pub const BPF_FUNC_skb_set_tstamp: Type = 192;
    pub const BPF_FUNC_ima_file_hash: Type = 193;
    pub const BPF_FUNC_kptr_xchg: Type = 194;
    pub const BPF_FUNC_map_lookup_percpu_elem: Type = 195;
    pub const BPF_FUNC_skc_to_mptcp_sock: Type = 196;
    pub const BPF_FUNC_dynptr_from_mem: Type = 197;
    pub const BPF_FUNC_ringbuf_reserve_dynptr: Type = 198;
    pub const BPF_FUNC_ringbuf_submit_dynptr: Type = 199;
    pub const BPF_FUNC_ringbuf_discard_dynptr: Type = 200;
    pub const BPF_FUNC_dynptr_read: Type = 201;
    pub const BPF_FUNC_dynptr_write: Type = 202;
    pub const BPF_FUNC_dynptr_data: Type = 203;
    pub const BPF_FUNC_tcp_raw_gen_syncookie_ipv4: Type = 204;
    pub const BPF_FUNC_tcp_raw_gen_syncookie_ipv6: Type = 205;
    pub const BPF_FUNC_tcp_raw_check_syncookie_ipv4: Type = 206;
    pub const BPF_FUNC_tcp_raw_check_syncookie_ipv6: Type = 207;
    pub const BPF_FUNC_ktime_get_tai_ns: Type = 208;
    pub const BPF_FUNC_user_ringbuf_drain: Type = 209;
    pub const BPF_FUNC_cgrp_storage_get: Type = 210;
    pub const BPF_FUNC_cgrp_storage_delete: Type = 211;
    pub const __BPF_FUNC_MAX_ID: Type = 212;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info {
    pub type_: __u32,
    pub id: __u32,
    pub prog_id: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1 {
    pub raw_tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_1,
    pub tracing: bpf_link_info__bindgen_ty_1__bindgen_ty_2,
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_3,
    pub iter: bpf_link_info__bindgen_ty_1__bindgen_ty_4,
    pub netns: bpf_link_info__bindgen_ty_1__bindgen_ty_5,
    pub xdp: bpf_link_info__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub tp_name: __u64,
    pub tp_name_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub attach_type: __u32,
    pub target_obj_id: __u32,
    pub target_btf_id: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub cgroup_id: __u64,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_name: __u64,
    pub target_name_len: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub map: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub map_id: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    pub task: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    pub cgroup_id: __u64,
    pub order: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    pub tid: __u32,
    pub pid: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub netns_ino: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(arg1: u64_, arg2: u64_, arg3: u64_, arg4: u64_, arg5: u64_) -> u64_,
    >,
    pub gpl_only: bool_,
    pub pkt_access: bool_,
    pub might_sleep: bool_,
    pub ret_type: bpf_return_type::Type,
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2,
    pub ret_btf_id: *mut ::aya_bpf::cty::c_int,
    pub allowed: ::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_prog) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1__bindgen_ty_1,
    pub arg_type: [bpf_arg_type::Type; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    pub arg1_type: bpf_arg_type::Type,
    pub arg2_type: bpf_arg_type::Type,
    pub arg3_type: bpf_arg_type::Type,
    pub arg4_type: bpf_arg_type::Type,
    pub arg5_type: bpf_arg_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_2 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_2__bindgen_ty_1,
    pub arg_btf_id: [*mut u32_; 5usize],
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2__bindgen_ty_2,
    pub arg_size: [usize; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    pub arg1_btf_id: *mut u32_,
    pub arg2_btf_id: *mut u32_,
    pub arg3_btf_id: *mut u32_,
    pub arg4_btf_id: *mut u32_,
    pub arg5_btf_id: *mut u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_2 {
    pub arg1_size: usize,
    pub arg2_size: usize,
    pub arg3_size: usize,
    pub arg4_size: usize,
    pub arg5_size: usize,
}
pub mod bpf_link_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_LINK_TYPE_UNSPEC: Type = 0;
    pub const BPF_LINK_TYPE_RAW_TRACEPOINT: Type = 1;
    pub const BPF_LINK_TYPE_TRACING: Type = 2;
    pub const BPF_LINK_TYPE_CGROUP: Type = 3;
    pub const BPF_LINK_TYPE_ITER: Type = 4;
    pub const BPF_LINK_TYPE_NETNS: Type = 5;
    pub const BPF_LINK_TYPE_XDP: Type = 6;
    pub const BPF_LINK_TYPE_PERF_EVENT: Type = 7;
    pub const BPF_LINK_TYPE_KPROBE_MULTI: Type = 8;
    pub const BPF_LINK_TYPE_STRUCT_OPS: Type = 9;
    pub const MAX_BPF_LINK_TYPE: Type = 10;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link {
    pub refcnt: atomic64_t,
    pub id: u32_,
    pub type_: bpf_link_type::Type,
    pub ops: *const bpf_link_ops,
    pub prog: *mut bpf_prog,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_link_ops {
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>,
    pub dealloc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link)>,
    pub detach:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_link) -> ::aya_bpf::cty::c_int>,
    pub update_prog: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_link,
            arg2: *mut bpf_prog,
            arg3: *mut bpf_prog,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const bpf_link, arg2: *mut seq_file)>,
    pub fill_link_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const bpf_link,
            arg2: *mut bpf_link_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
pub type bpfptr_t = sockptr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_struct_meta {
    pub btf_id: u32_,
    pub record: *mut btf_record,
    pub field_offs: *mut btf_field_offs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_log {
    pub level: u32_,
    pub kbuf: [::aya_bpf::cty::c_char; 1024usize],
    pub ubuf: *mut ::aya_bpf::cty::c_char,
    pub len_used: u32_,
    pub len_total: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_subprog_info {
    pub start: u32_,
    pub linfo_idx: u32_,
    pub stack_depth: u16_,
    pub has_tail_call: bool_,
    pub tail_call_reachable: bool_,
    pub has_ld_abs: bool_,
    pub is_async_cb: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_id_pair {
    pub old: u32_,
    pub cur: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_env {
    pub insn_idx: u32_,
    pub prev_insn_idx: u32_,
    pub prog: *mut bpf_prog,
    pub ops: *const bpf_verifier_ops,
    pub head: *mut bpf_verifier_stack_elem,
    pub stack_size: ::aya_bpf::cty::c_int,
    pub strict_alignment: bool_,
    pub test_state_freq: bool_,
    pub cur_state: *mut bpf_verifier_state,
    pub explored_states: *mut *mut bpf_verifier_state_list,
    pub free_list: *mut bpf_verifier_state_list,
    pub used_maps: [*mut bpf_map; 64usize],
    pub used_btfs: [btf_mod_pair; 64usize],
    pub used_map_cnt: u32_,
    pub used_btf_cnt: u32_,
    pub id_gen: u32_,
    pub explore_alu_limits: bool_,
    pub allow_ptr_leaks: bool_,
    pub allow_uninit_stack: bool_,
    pub bpf_capable: bool_,
    pub bypass_spec_v1: bool_,
    pub bypass_spec_v4: bool_,
    pub seen_direct_write: bool_,
    pub rcu_tag_supported: bool_,
    pub insn_aux_data: *mut bpf_insn_aux_data,
    pub prev_linfo: *const bpf_line_info,
    pub log: bpf_verifier_log,
    pub subprog_info: [bpf_subprog_info; 257usize],
    pub idmap_scratch: [bpf_id_pair; 600usize],
    pub cfg: bpf_verifier_env__bindgen_ty_1,
    pub pass_cnt: u32_,
    pub subprog_cnt: u32_,
    pub prev_insn_processed: u32_,
    pub insn_processed: u32_,
    pub prev_jmps_processed: u32_,
    pub jmps_processed: u32_,
    pub verification_time: u64_,
    pub max_states_per_insn: u32_,
    pub total_states: u32_,
    pub peak_states: u32_,
    pub longest_mark_read_walk: u32_,
    pub fd_array: bpfptr_t,
    pub scratched_regs: u32_,
    pub scratched_stack_slots: u64_,
    pub prev_log_len: u32_,
    pub prev_insn_print_len: u32_,
    pub type_str_buf: [::aya_bpf::cty::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_env__bindgen_ty_1 {
    pub insn_state: *mut ::aya_bpf::cty::c_int,
    pub insn_stack: *mut ::aya_bpf::cty::c_int,
    pub cur_stack: ::aya_bpf::cty::c_int,
}
pub mod bpf_dynptr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_DYNPTR_TYPE_INVALID: Type = 0;
    pub const BPF_DYNPTR_TYPE_LOCAL: Type = 1;
    pub const BPF_DYNPTR_TYPE_RINGBUF: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tnum {
    pub value: u64_,
    pub mask: u64_,
}
pub mod bpf_reg_liveness {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const REG_LIVE_NONE: Type = 0;
    pub const REG_LIVE_READ32: Type = 1;
    pub const REG_LIVE_READ64: Type = 2;
    pub const REG_LIVE_READ: Type = 3;
    pub const REG_LIVE_WRITTEN: Type = 4;
    pub const REG_LIVE_DONE: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_reg_state {
    pub type_: bpf_reg_type::Type,
    pub off: s32,
    pub __bindgen_anon_1: bpf_reg_state__bindgen_ty_1,
    pub id: u32_,
    pub ref_obj_id: u32_,
    pub var_off: tnum,
    pub smin_value: s64,
    pub smax_value: s64,
    pub umin_value: u64_,
    pub umax_value: u64_,
    pub s32_min_value: s32,
    pub s32_max_value: s32,
    pub u32_min_value: u32_,
    pub u32_max_value: u32_,
    pub parent: *mut bpf_reg_state,
    pub frameno: u32_,
    pub subreg_def: s32,
    pub live: bpf_reg_liveness::Type,
    pub precise: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_reg_state__bindgen_ty_1 {
    pub range: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_1: bpf_reg_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_reg_state__bindgen_ty_1__bindgen_ty_2,
    pub mem_size: u32_,
    pub dynptr: bpf_reg_state__bindgen_ty_1__bindgen_ty_3,
    pub raw: bpf_reg_state__bindgen_ty_1__bindgen_ty_4,
    pub subprogno: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_1 {
    pub map_ptr: *mut bpf_map,
    pub map_uid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_2 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_3 {
    pub type_: bpf_dynptr_type::Type,
    pub first_slot: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reg_state__bindgen_ty_1__bindgen_ty_4 {
    pub raw1: ::aya_bpf::cty::c_ulong,
    pub raw2: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_state {
    pub regs: [bpf_reg_state; 11usize],
    pub callsite: ::aya_bpf::cty::c_int,
    pub frameno: u32_,
    pub subprogno: u32_,
    pub async_entry_cnt: u32_,
    pub in_callback_fn: bool_,
    pub callback_ret_range: tnum,
    pub in_async_callback_fn: bool_,
    pub acquired_refs: ::aya_bpf::cty::c_int,
    pub refs: *mut bpf_reference_state,
    pub allocated_stack: ::aya_bpf::cty::c_int,
    pub stack: *mut bpf_stack_state,
}
pub mod bpf_access_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BPF_READ: Type = 1;
    pub const BPF_WRITE: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux {
    pub reg_type: bpf_reg_type::Type,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1,
    pub log: *mut bpf_verifier_log,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_access_aux__bindgen_ty_1 {
    pub ctx_field_size: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_ops {
    pub get_func_proto: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: bpf_func_id::Type,
            arg2: *const bpf_prog,
        ) -> *const bpf_func_proto,
    >,
    pub is_valid_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf::cty::c_int,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bpf_access_type::Type,
            arg4: *const bpf_prog,
            arg5: *mut bpf_insn_access_aux,
        ) -> bool_,
    >,
    pub gen_prologue: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_insn,
            arg2: bool_,
            arg3: *const bpf_prog,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub gen_ld_abs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const bpf_insn, arg2: *mut bpf_insn) -> ::aya_bpf::cty::c_int,
    >,
    pub convert_ctx_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: bpf_access_type::Type,
            arg2: *const bpf_insn,
            arg3: *mut bpf_insn,
            arg4: *mut bpf_prog,
            arg5: *mut u32_,
        ) -> u32_,
    >,
    pub btf_struct_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_log,
            arg2: *const bpf_reg_state,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
            arg5: bpf_access_type::Type,
            arg6: *mut u32_,
            arg7: *mut bpf_type_flag::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stack_state {
    pub spilled_ptr: bpf_reg_state,
    pub slot_type: [u8_; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_reference_state {
    pub id: ::aya_bpf::cty::c_int,
    pub insn_idx: ::aya_bpf::cty::c_int,
    pub callback_ref: ::aya_bpf::cty::c_int,
    pub release_on_unlock: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_idx_pair {
    pub prev_idx: u32_,
    pub idx: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_state {
    pub frame: [*mut bpf_func_state; 8usize],
    pub parent: *mut bpf_verifier_state,
    pub branches: u32_,
    pub insn_idx: u32_,
    pub curframe: u32_,
    pub active_lock: bpf_verifier_state__bindgen_ty_1,
    pub speculative: bool_,
    pub active_rcu_lock: bool_,
    pub first_insn_idx: u32_,
    pub last_insn_idx: u32_,
    pub jmp_history: *mut bpf_idx_pair,
    pub jmp_history_cnt: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_state__bindgen_ty_1 {
    pub ptr: *mut ::aya_bpf::cty::c_void,
    pub id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_state_list {
    pub state: bpf_verifier_state,
    pub next: *mut bpf_verifier_state_list,
    pub miss_cnt: ::aya_bpf::cty::c_int,
    pub hit_cnt: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_loop_inline_state {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub callback_subprogno: u32_,
}
impl bpf_loop_inline_state {
    #[inline]
    pub fn initialized(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_for_inline(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fit_for_inline(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: ::aya_bpf::cty::c_uint,
        fit_for_inline: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u32 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fit_for_inline: u32 = unsafe { ::core::mem::transmute(fit_for_inline) };
            fit_for_inline as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_aux_data {
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1,
    pub obj_new_size: u64_,
    pub kptr_struct_meta: *mut btf_struct_meta,
    pub map_key_state: u64_,
    pub ctx_field_size: ::aya_bpf::cty::c_int,
    pub seen: u32_,
    pub sanitize_stack_spill: bool_,
    pub zext_dst: bool_,
    pub storage_get_func_atomic: bool_,
    pub alu_state: u8_,
    pub orig_idx: ::aya_bpf::cty::c_uint,
    pub prune_point: bool_,
    pub jmp_point: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_aux_data__bindgen_ty_1 {
    pub ptr_type: bpf_reg_type::Type,
    pub map_ptr_state: ::aya_bpf::cty::c_ulong,
    pub call_imm: s32,
    pub alu_limit: u32_,
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_1,
    pub btf_var: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2,
    pub loop_inline_state: bpf_loop_inline_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_1 {
    pub map_index: u32_,
    pub map_off: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2 {
    pub reg_type: bpf_reg_type::Type,
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub mem_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn_aux_data__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage {
    pub cache: [*mut bpf_local_storage_data; 16usize],
    pub list: hlist_head,
    pub owner: *mut ::aya_bpf::cty::c_void,
    pub rcu: callback_head,
    pub lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map {
    pub map: bpf_map,
    pub buckets: *mut bpf_local_storage_map_bucket,
    pub bucket_log: u32_,
    pub elem_size: u16_,
    pub cache_idx: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map_bucket {
    pub list: hlist_head,
    pub lock: raw_spinlock_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct bpf_local_storage_data {
    pub smap: *mut bpf_local_storage_map,
    pub data: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    pub root: *mut anon_vma,
    pub rwsem: rw_semaphore,
    pub refcount: atomic_t,
    pub num_children: ::aya_bpf::cty::c_ulong,
    pub num_active_vmas: ::aya_bpf::cty::c_ulong,
    pub parent: *mut anon_vma,
    pub rb_root: rb_root_cached,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    pub mq_list: *mut request,
    pub cached_rq: *mut request,
    pub nr_ios: ::aya_bpf::cty::c_ushort,
    pub rq_count: ::aya_bpf::cty::c_ushort,
    pub multiple_queues: bool_,
    pub has_elevator: bool_,
    pub nowait: bool_,
    pub cb_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capture_control {
    pub cc: *mut compact_control,
    pub page: *mut page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity {
    pub profile: *const blk_integrity_profile,
    pub flags: ::aya_bpf::cty::c_uchar,
    pub tuple_size: ::aya_bpf::cty::c_uchar,
    pub interval_exp: ::aya_bpf::cty::c_uchar,
    pub tag_size: ::aya_bpf::cty::c_uchar,
}
pub mod blk_bounce {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BLK_BOUNCE_NONE: Type = 0;
    pub const BLK_BOUNCE_HIGH: Type = 1;
}
pub mod blk_zoned_model {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BLK_ZONED_NONE: Type = 0;
    pub const BLK_ZONED_HA: Type = 1;
    pub const BLK_ZONED_HM: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queue_limits {
    pub bounce: blk_bounce::Type,
    pub seg_boundary_mask: ::aya_bpf::cty::c_ulong,
    pub virt_boundary_mask: ::aya_bpf::cty::c_ulong,
    pub max_hw_sectors: ::aya_bpf::cty::c_uint,
    pub max_dev_sectors: ::aya_bpf::cty::c_uint,
    pub chunk_sectors: ::aya_bpf::cty::c_uint,
    pub max_sectors: ::aya_bpf::cty::c_uint,
    pub max_segment_size: ::aya_bpf::cty::c_uint,
    pub physical_block_size: ::aya_bpf::cty::c_uint,
    pub logical_block_size: ::aya_bpf::cty::c_uint,
    pub alignment_offset: ::aya_bpf::cty::c_uint,
    pub io_min: ::aya_bpf::cty::c_uint,
    pub io_opt: ::aya_bpf::cty::c_uint,
    pub max_discard_sectors: ::aya_bpf::cty::c_uint,
    pub max_hw_discard_sectors: ::aya_bpf::cty::c_uint,
    pub max_secure_erase_sectors: ::aya_bpf::cty::c_uint,
    pub max_write_zeroes_sectors: ::aya_bpf::cty::c_uint,
    pub max_zone_append_sectors: ::aya_bpf::cty::c_uint,
    pub discard_granularity: ::aya_bpf::cty::c_uint,
    pub discard_alignment: ::aya_bpf::cty::c_uint,
    pub zone_write_granularity: ::aya_bpf::cty::c_uint,
    pub max_segments: ::aya_bpf::cty::c_ushort,
    pub max_integrity_segments: ::aya_bpf::cty::c_ushort,
    pub max_discard_segments: ::aya_bpf::cty::c_ushort,
    pub misaligned: ::aya_bpf::cty::c_uchar,
    pub discard_misaligned: ::aya_bpf::cty::c_uchar,
    pub raid_partial_stripes_expensive: ::aya_bpf::cty::c_uchar,
    pub zoned: blk_zoned_model::Type,
    pub dma_alignment: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_queue {
    pub last_merge: *mut request,
    pub elevator: *mut elevator_queue,
    pub q_usage_counter: percpu_ref,
    pub stats: *mut blk_queue_stats,
    pub rq_qos: *mut rq_qos,
    pub mq_ops: *const blk_mq_ops,
    pub queue_ctx: *mut blk_mq_ctx,
    pub queue_depth: ::aya_bpf::cty::c_uint,
    pub hctx_table: xarray,
    pub nr_hw_queues: ::aya_bpf::cty::c_uint,
    pub queuedata: *mut ::aya_bpf::cty::c_void,
    pub queue_flags: ::aya_bpf::cty::c_ulong,
    pub pm_only: atomic_t,
    pub id: ::aya_bpf::cty::c_int,
    pub queue_lock: spinlock_t,
    pub disk: *mut gendisk,
    pub refs: refcount_t,
    pub mq_kobj: *mut kobject,
    pub integrity: blk_integrity,
    pub dev: *mut device,
    pub rpm_status: rpm_status::Type,
    pub nr_requests: ::aya_bpf::cty::c_ulong,
    pub dma_pad_mask: ::aya_bpf::cty::c_uint,
    pub crypto_profile: *mut blk_crypto_profile,
    pub crypto_kobject: *mut kobject,
    pub rq_timeout: ::aya_bpf::cty::c_uint,
    pub poll_nsec: ::aya_bpf::cty::c_int,
    pub poll_cb: *mut blk_stat_callback,
    pub poll_stat: *mut blk_rq_stat,
    pub timeout: timer_list,
    pub timeout_work: work_struct,
    pub nr_active_requests_shared_tags: atomic_t,
    pub sched_shared_tags: *mut blk_mq_tags,
    pub icq_list: list_head,
    pub blkcg_pols: [::aya_bpf::cty::c_ulong; 1usize],
    pub root_blkg: *mut blkcg_gq,
    pub blkg_list: list_head,
    pub limits: queue_limits,
    pub required_elevator_features: ::aya_bpf::cty::c_uint,
    pub node: ::aya_bpf::cty::c_int,
    pub blk_trace: *mut blk_trace,
    pub fq: *mut blk_flush_queue,
    pub requeue_list: list_head,
    pub requeue_lock: spinlock_t,
    pub requeue_work: delayed_work,
    pub sysfs_lock: mutex,
    pub sysfs_dir_lock: mutex,
    pub unused_hctx_list: list_head,
    pub unused_hctx_lock: spinlock_t,
    pub mq_freeze_depth: ::aya_bpf::cty::c_int,
    pub td: *mut throtl_data,
    pub callback_head: callback_head,
    pub mq_freeze_wq: wait_queue_head_t,
    pub mq_freeze_lock: mutex,
    pub quiesce_depth: ::aya_bpf::cty::c_int,
    pub tag_set: *mut blk_mq_tag_set,
    pub tag_set_list: list_head,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub rqos_debugfs_dir: *mut dentry,
    pub debugfs_mutex: mutex,
    pub mq_sysfs_init_done: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_comp_batch {
    pub req_list: *mut request,
    pub need_ts: bool_,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_comp_batch)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gendisk {
    pub major: ::aya_bpf::cty::c_int,
    pub first_minor: ::aya_bpf::cty::c_int,
    pub minors: ::aya_bpf::cty::c_int,
    pub disk_name: [::aya_bpf::cty::c_char; 32usize],
    pub events: ::aya_bpf::cty::c_ushort,
    pub event_flags: ::aya_bpf::cty::c_ushort,
    pub part_tbl: xarray,
    pub part0: *mut block_device,
    pub fops: *const block_device_operations,
    pub queue: *mut request_queue,
    pub private_data: *mut ::aya_bpf::cty::c_void,
    pub bio_split: bio_set,
    pub flags: ::aya_bpf::cty::c_int,
    pub state: ::aya_bpf::cty::c_ulong,
    pub open_mutex: mutex,
    pub open_partitions: ::aya_bpf::cty::c_uint,
    pub bdi: *mut backing_dev_info,
    pub queue_kobj: kobject,
    pub slave_dir: *mut kobject,
    pub slave_bdevs: list_head,
    pub random: *mut timer_rand_state,
    pub sync_io: atomic_t,
    pub ev: *mut disk_events,
    pub integrity_kobj: kobject,
    pub nr_zones: ::aya_bpf::cty::c_uint,
    pub max_open_zones: ::aya_bpf::cty::c_uint,
    pub max_active_zones: ::aya_bpf::cty::c_uint,
    pub conv_zones_bitmap: *mut ::aya_bpf::cty::c_ulong,
    pub seq_zones_wlock: *mut ::aya_bpf::cty::c_ulong,
    pub cdi: *mut cdrom_device_info,
    pub node_id: ::aya_bpf::cty::c_int,
    pub bb: *mut badblocks,
    pub lockdep_map: lockdep_map,
    pub diskseq: u64_,
    pub ia_ranges: *mut blk_independent_access_ranges,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct partition_meta_info {
    pub uuid: [::aya_bpf::cty::c_char; 37usize],
    pub volname: [u8_; 64usize],
}
pub mod req_op {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const REQ_OP_READ: Type = 0;
    pub const REQ_OP_WRITE: Type = 1;
    pub const REQ_OP_FLUSH: Type = 2;
    pub const REQ_OP_DISCARD: Type = 3;
    pub const REQ_OP_SECURE_ERASE: Type = 5;
    pub const REQ_OP_WRITE_ZEROES: Type = 9;
    pub const REQ_OP_ZONE_OPEN: Type = 10;
    pub const REQ_OP_ZONE_CLOSE: Type = 11;
    pub const REQ_OP_ZONE_FINISH: Type = 12;
    pub const REQ_OP_ZONE_APPEND: Type = 13;
    pub const REQ_OP_ZONE_RESET: Type = 15;
    pub const REQ_OP_ZONE_RESET_ALL: Type = 17;
    pub const REQ_OP_DRV_IN: Type = 34;
    pub const REQ_OP_DRV_OUT: Type = 35;
    pub const REQ_OP_LAST: Type = 36;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64_,
    pub min: u64_,
    pub max: u64_,
    pub nr_samples: u32_,
    pub batch: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_zone {
    pub start: __u64,
    pub len: __u64,
    pub wp: __u64,
    pub type_: __u8,
    pub cond: __u8,
    pub non_seq: __u8,
    pub reset: __u8,
    pub resv: [__u8; 4usize],
    pub capacity: __u64,
    pub reserved: [__u8; 24usize],
}
pub type integrity_processing_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_integrity_iter) -> blk_status_t>;
pub type integrity_prepare_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>;
pub type integrity_complete_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: ::aya_bpf::cty::c_uint)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_profile {
    pub generate_fn: integrity_processing_fn,
    pub verify_fn: integrity_processing_fn,
    pub prepare_fn: integrity_prepare_fn,
    pub complete_fn: integrity_complete_fn,
    pub name: *const ::aya_bpf::cty::c_char,
}
pub type report_zones_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut blk_zone,
        arg2: ::aya_bpf::cty::c_uint,
        arg3: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
pub mod blk_unique_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BLK_UID_T10: Type = 1;
    pub const BLK_UID_EUI64: Type = 2;
    pub const BLK_UID_NAA: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device_operations {
    pub submit_bio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>,
    pub poll_bio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bio,
            arg2: *mut io_comp_batch,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: fmode_t) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk, arg2: fmode_t)>,
    pub rw_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: sector_t,
            arg3: *mut page,
            arg4: req_op::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: fmode_t,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub unlock_native_capacity: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub getgeo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: *mut hd_geometry,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_read_only: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: bool_) -> ::aya_bpf::cty::c_int,
    >,
    pub free_disk: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gendisk)>,
    pub swap_slot_free_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: ::aya_bpf::cty::c_ulong),
    >,
    pub report_zones: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            arg2: sector_t,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: report_zones_cb,
            arg5: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gendisk, arg2: *mut umode_t) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub get_unique_id: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gendisk,
            arg2: *mut u8_,
            arg3: blk_unique_id::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub owner: *mut module,
    pub pr_ops: *const pr_ops,
    pub alternative_gpt_sector: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gendisk, arg2: *mut sector_t) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_independent_access_range {
    pub kobj: kobject,
    pub sector: sector_t,
    pub nr_sectors: sector_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct blk_independent_access_ranges {
    pub kobj: kobject,
    pub sysfs_registered: bool_,
    pub nr_ia_ranges: ::aya_bpf::cty::c_uint,
    pub ia_range: __IncompleteArrayField<blk_independent_access_range>,
}
pub mod blk_eh_timer_return {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BLK_EH_DONE: Type = 0;
    pub const BLK_EH_RESET_TIMER: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_ops {
    pub queue_rq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *const blk_mq_queue_data,
        ) -> blk_status_t,
    >,
    pub commit_rqs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub queue_rqs: ::core::option::Option<unsafe extern "C" fn(arg1: *mut *mut request)>,
    pub get_budget: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue) -> ::aya_bpf::cty::c_int,
    >,
    pub put_budget: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: ::aya_bpf::cty::c_int),
    >,
    pub set_rq_budget_token: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request, arg2: ::aya_bpf::cty::c_int),
    >,
    pub get_rq_budget_token:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request) -> ::aya_bpf::cty::c_int>,
    pub timeout: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request) -> blk_eh_timer_return::Type,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut io_comp_batch,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub complete: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub init_request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_tag_set,
            arg2: *mut request,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub exit_request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_tag_set,
            arg2: *mut request,
            arg3: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub cleanup_rq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub busy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_queue) -> bool_>,
    pub map_queues: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_tag_set)>,
    pub show_rq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut request)>,
}
pub mod pr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PR_WRITE_EXCLUSIVE: Type = 1;
    pub const PR_EXCLUSIVE_ACCESS: Type = 2;
    pub const PR_WRITE_EXCLUSIVE_REG_ONLY: Type = 3;
    pub const PR_EXCLUSIVE_ACCESS_REG_ONLY: Type = 4;
    pub const PR_WRITE_EXCLUSIVE_ALL_REGS: Type = 5;
    pub const PR_EXCLUSIVE_ACCESS_ALL_REGS: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pr_ops {
    pub pr_register: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: u64_,
            arg4: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pr_reserve: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: pr_type::Type,
            arg4: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pr_release: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: pr_type::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pr_preempt: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut block_device,
            arg2: u64_,
            arg3: u64_,
            arg4: pr_type::Type,
            arg5: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pr_clear: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut block_device, arg2: u64_) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pagevec {
    pub nr: ::aya_bpf::cty::c_uchar,
    pub percpu_pvec_drained: bool_,
    pub pages: [*mut page; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compact_control {
    pub freepages: list_head,
    pub migratepages: list_head,
    pub nr_freepages: ::aya_bpf::cty::c_uint,
    pub nr_migratepages: ::aya_bpf::cty::c_uint,
    pub free_pfn: ::aya_bpf::cty::c_ulong,
    pub migrate_pfn: ::aya_bpf::cty::c_ulong,
    pub fast_start_pfn: ::aya_bpf::cty::c_ulong,
    pub zone: *mut zone,
    pub total_migrate_scanned: ::aya_bpf::cty::c_ulong,
    pub total_free_scanned: ::aya_bpf::cty::c_ulong,
    pub fast_search_fail: ::aya_bpf::cty::c_ushort,
    pub search_order: ::aya_bpf::cty::c_short,
    pub gfp_mask: gfp_t,
    pub order: ::aya_bpf::cty::c_int,
    pub migratetype: ::aya_bpf::cty::c_int,
    pub alloc_flags: ::aya_bpf::cty::c_uint,
    pub highest_zoneidx: ::aya_bpf::cty::c_int,
    pub mode: migrate_mode::Type,
    pub ignore_skip_hint: bool_,
    pub no_set_skip_hint: bool_,
    pub ignore_block_suitable: bool_,
    pub direct_compaction: bool_,
    pub proactive_compaction: bool_,
    pub whole_zone: bool_,
    pub contended: bool_,
    pub rescan: bool_,
    pub alloc_contig: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_lock_t {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reciprocal_value {
    pub m: u32_,
    pub sh1: u8_,
    pub sh2: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache_order_objects {
    pub x: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    pub cpu_slab: *mut kmem_cache_cpu,
    pub flags: slab_flags_t,
    pub min_partial: ::aya_bpf::cty::c_ulong,
    pub size: ::aya_bpf::cty::c_uint,
    pub object_size: ::aya_bpf::cty::c_uint,
    pub reciprocal_size: reciprocal_value,
    pub offset: ::aya_bpf::cty::c_uint,
    pub cpu_partial: ::aya_bpf::cty::c_uint,
    pub cpu_partial_slabs: ::aya_bpf::cty::c_uint,
    pub oo: kmem_cache_order_objects,
    pub min: kmem_cache_order_objects,
    pub allocflags: gfp_t,
    pub refcount: ::aya_bpf::cty::c_int,
    pub ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub inuse: ::aya_bpf::cty::c_uint,
    pub align: ::aya_bpf::cty::c_uint,
    pub red_left_pad: ::aya_bpf::cty::c_uint,
    pub name: *const ::aya_bpf::cty::c_char,
    pub list: list_head,
    pub kobj: kobject,
    pub random: ::aya_bpf::cty::c_ulong,
    pub remote_node_defrag_ratio: ::aya_bpf::cty::c_uint,
    pub random_seq: *mut ::aya_bpf::cty::c_uint,
    pub useroffset: ::aya_bpf::cty::c_uint,
    pub usersize: ::aya_bpf::cty::c_uint,
    pub node: [*mut kmem_cache_node; 1024usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slab {
    pub __page_flags: ::aya_bpf::cty::c_ulong,
    pub slab_cache: *mut kmem_cache,
    pub __bindgen_anon_1: slab__bindgen_ty_1,
    pub __unused: ::aya_bpf::cty::c_uint,
    pub __page_refcount: atomic_t,
    pub memcg_data: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slab__bindgen_ty_1 {
    pub __bindgen_anon_1: slab__bindgen_ty_1__bindgen_ty_1,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slab__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub freelist: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_2: slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub slab_list: list_head,
    pub __bindgen_anon_1: slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut slab,
    pub slabs: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub counters: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_1: slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl slab__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn inuse(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inuse(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn objects(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_objects(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inuse: ::aya_bpf::cty::c_uint,
        objects: ::aya_bpf::cty::c_uint,
        frozen: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let inuse: u32 = unsafe { ::core::mem::transmute(inuse) };
            inuse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let objects: u32 = unsafe { ::core::mem::transmute(objects) };
            objects as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache_cpu {
    pub freelist: *mut *mut ::aya_bpf::cty::c_void,
    pub tid: ::aya_bpf::cty::c_ulong,
    pub slab: *mut slab,
    pub partial: *mut slab,
    pub lock: local_lock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache_node {
    pub list_lock: spinlock_t,
    pub nr_partial: ::aya_bpf::cty::c_ulong,
    pub partial: list_head,
    pub nr_slabs: atomic_long_t,
    pub total_objects: atomic_long_t,
    pub full: list_head,
}
pub type __kernel_rwf_t = ::aya_bpf::cty::c_int;
pub mod hash_algo {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const HASH_ALGO_MD4: Type = 0;
    pub const HASH_ALGO_MD5: Type = 1;
    pub const HASH_ALGO_SHA1: Type = 2;
    pub const HASH_ALGO_RIPE_MD_160: Type = 3;
    pub const HASH_ALGO_SHA256: Type = 4;
    pub const HASH_ALGO_SHA384: Type = 5;
    pub const HASH_ALGO_SHA512: Type = 6;
    pub const HASH_ALGO_SHA224: Type = 7;
    pub const HASH_ALGO_RIPE_MD_128: Type = 8;
    pub const HASH_ALGO_RIPE_MD_256: Type = 9;
    pub const HASH_ALGO_RIPE_MD_320: Type = 10;
    pub const HASH_ALGO_WP_256: Type = 11;
    pub const HASH_ALGO_WP_384: Type = 12;
    pub const HASH_ALGO_WP_512: Type = 13;
    pub const HASH_ALGO_TGR_128: Type = 14;
    pub const HASH_ALGO_TGR_160: Type = 15;
    pub const HASH_ALGO_TGR_192: Type = 16;
    pub const HASH_ALGO_SM3_256: Type = 17;
    pub const HASH_ALGO_STREEBOG_256: Type = 18;
    pub const HASH_ALGO_STREEBOG_512: Type = 19;
    pub const HASH_ALGO__LAST: Type = 20;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    pub fi_flags: ::aya_bpf::cty::c_uint,
    pub fi_extents_mapped: ::aya_bpf::cty::c_uint,
    pub fi_extents_max: ::aya_bpf::cty::c_uint,
    pub fi_extents_start: *mut fiemap_extent,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fileattr {
    pub flags: u32_,
    pub fsx_xflags: u32_,
    pub fsx_extsize: u32_,
    pub fsx_nextents: u32_,
    pub fsx_projid: u32_,
    pub fsx_cowextsize: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl fileattr {
    #[inline]
    pub fn flags_valid(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flags_valid(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fsx_valid(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fsx_valid(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags_valid: bool_,
        fsx_valid: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flags_valid: u8 = unsafe { ::core::mem::transmute(flags_valid) };
            flags_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fsx_valid: u8 = unsafe { ::core::mem::transmute(fsx_valid) };
            fsx_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent {
    pub fe_logical: __u64,
    pub fe_physical: __u64,
    pub fe_length: __u64,
    pub fe_reserved64: [__u64; 2usize],
    pub fe_flags: __u32,
    pub fe_reserved: [__u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v1 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub master_key_descriptor: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v2 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub __reserved: [__u8; 4usize],
    pub master_key_identifier: [__u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_policy {
    pub version: u8_,
    pub v1: fscrypt_policy_v1,
    pub v2: fscrypt_policy_v2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_pin {
    pub wait: wait_queue_head_t,
    pub done: ::aya_bpf::cty::c_int,
    pub s_list: hlist_node,
    pub m_list: hlist_node,
    pub kill: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_pin)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_namespace {
    pub ns: ns_common,
    pub root: *mut mount,
    pub list: list_head,
    pub ns_lock: spinlock_t,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub seq: u64_,
    pub poll: wait_queue_head_t,
    pub event: u64_,
    pub mounts: ::aya_bpf::cty::c_uint,
    pub pending_mounts: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mount {
    pub mnt_hash: hlist_node,
    pub mnt_parent: *mut mount,
    pub mnt_mountpoint: *mut dentry,
    pub mnt: vfsmount,
    pub __bindgen_anon_1: mount__bindgen_ty_1,
    pub mnt_pcp: *mut mnt_pcp,
    pub mnt_mounts: list_head,
    pub mnt_child: list_head,
    pub mnt_instance: list_head,
    pub mnt_devname: *const ::aya_bpf::cty::c_char,
    pub mnt_list: list_head,
    pub mnt_expire: list_head,
    pub mnt_share: list_head,
    pub mnt_slave_list: list_head,
    pub mnt_slave: list_head,
    pub mnt_master: *mut mount,
    pub mnt_ns: *mut mnt_namespace,
    pub mnt_mp: *mut mountpoint,
    pub __bindgen_anon_2: mount__bindgen_ty_2,
    pub mnt_umounting: list_head,
    pub mnt_fsnotify_marks: *mut fsnotify_mark_connector,
    pub mnt_fsnotify_mask: __u32,
    pub mnt_id: ::aya_bpf::cty::c_int,
    pub mnt_group_id: ::aya_bpf::cty::c_int,
    pub mnt_expiry_mark: ::aya_bpf::cty::c_int,
    pub mnt_pins: hlist_head,
    pub mnt_stuck_children: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mount__bindgen_ty_1 {
    pub mnt_rcu: callback_head,
    pub mnt_llist: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mount__bindgen_ty_2 {
    pub mnt_mp_list: hlist_node,
    pub mnt_umount: hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_pcp {
    pub mnt_count: ::aya_bpf::cty::c_int,
    pub mnt_writers: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mountpoint {
    pub m_hash: hlist_node,
    pub m_dentry: *mut dentry,
    pub m_list: hlist_head,
    pub m_count: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfn_t {
    pub val: u64_,
}
pub mod dax_access_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DAX_ACCESS: Type = 0;
    pub const DAX_RECOVERY_WRITE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iomap {
    pub addr: u64_,
    pub offset: loff_t,
    pub length: u64_,
    pub type_: u16_,
    pub flags: u16_,
    pub bdev: *mut block_device,
    pub dax_dev: *mut dax_device,
    pub inline_data: *mut ::aya_bpf::cty::c_void,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub page_ops: *const iomap_page_ops,
    pub validity_cookie: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iomap_page_ops {
    pub page_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: loff_t,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub page_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: loff_t,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut page,
        ),
    >,
    pub iomap_valid:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, arg2: *const iomap) -> bool_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct merkle_tree_params {
    pub hash_alg: *mut fsverity_hash_alg,
    pub hashstate: *const u8_,
    pub digest_size: ::aya_bpf::cty::c_uint,
    pub block_size: ::aya_bpf::cty::c_uint,
    pub hashes_per_block: ::aya_bpf::cty::c_uint,
    pub log_blocksize: ::aya_bpf::cty::c_uint,
    pub log_arity: ::aya_bpf::cty::c_uint,
    pub num_levels: ::aya_bpf::cty::c_uint,
    pub tree_size: u64_,
    pub level0_blocks: ::aya_bpf::cty::c_ulong,
    pub level_start: [u64_; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_info {
    pub tree_params: merkle_tree_params,
    pub root_hash: [u8_; 64usize],
    pub file_digest: [u8_; 64usize],
    pub inode: *const inode,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_hash_alg {
    pub tfm: *mut crypto_ahash,
    pub name: *const ::aya_bpf::cty::c_char,
    pub digest_size: ::aya_bpf::cty::c_uint,
    pub block_size: ::aya_bpf::cty::c_uint,
    pub req_pool: mempool_t,
    pub algo_id: hash_algo::Type,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_tfm {
    pub crt_flags: u32_,
    pub node: ::aya_bpf::cty::c_int,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>,
    pub __crt_alg: *mut crypto_alg,
    pub __crt_ctx: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_ahash {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf::cty::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf::cty::c_int,
    >,
    pub final_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf::cty::c_int,
    >,
    pub finup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf::cty::c_int,
    >,
    pub digest: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ahash_request) -> ::aya_bpf::cty::c_int,
    >,
    pub export: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ahash_request,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub import: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ahash_request,
            arg2: *const ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setkey: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_ahash,
            arg2: *const u8_,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reqsize: ::aya_bpf::cty::c_uint,
    pub base: crypto_tfm,
}
pub type crypto_completion_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut crypto_async_request, arg2: ::aya_bpf::cty::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_async_request {
    pub list: list_head,
    pub complete: crypto_completion_t,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub tfm: *mut crypto_tfm,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_alg {
    pub cia_min_keysize: ::aya_bpf::cty::c_uint,
    pub cia_max_keysize: ::aya_bpf::cty::c_uint,
    pub cia_setkey: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cia_encrypt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
    >,
    pub cia_decrypt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm, arg2: *mut u8_, arg3: *const u8_),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compress_alg {
    pub coa_compress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut u8_,
            arg5: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub coa_decompress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: *const u8_,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut u8_,
            arg5: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_alg {
    pub cra_list: list_head,
    pub cra_users: list_head,
    pub cra_flags: u32_,
    pub cra_blocksize: ::aya_bpf::cty::c_uint,
    pub cra_ctxsize: ::aya_bpf::cty::c_uint,
    pub cra_alignmask: ::aya_bpf::cty::c_uint,
    pub cra_priority: ::aya_bpf::cty::c_int,
    pub cra_refcnt: refcount_t,
    pub cra_name: [::aya_bpf::cty::c_char; 128usize],
    pub cra_driver_name: [::aya_bpf::cty::c_char; 128usize],
    pub cra_type: *const crypto_type,
    pub cra_u: crypto_alg__bindgen_ty_1,
    pub cra_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf::cty::c_int,
    >,
    pub cra_exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_tfm)>,
    pub cra_destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_alg)>,
    pub cra_module: *mut module,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_alg__bindgen_ty_1 {
    pub cipher: cipher_alg,
    pub compress: compress_alg,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_type {
    pub ctxsize: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_alg,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub extsize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_alg) -> ::aya_bpf::cty::c_uint,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_tfm,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub init_tfm: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut crypto_tfm) -> ::aya_bpf::cty::c_int,
    >,
    pub show:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut crypto_alg)>,
    pub report: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut crypto_alg) -> ::aya_bpf::cty::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crypto_instance)>,
    pub type_: ::aya_bpf::cty::c_uint,
    pub maskclear: ::aya_bpf::cty::c_uint,
    pub maskset: ::aya_bpf::cty::c_uint,
    pub tfmsize: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct ahash_request {
    pub base: crypto_async_request,
    pub nbytes: ::aya_bpf::cty::c_uint,
    pub src: *mut scatterlist,
    pub result: *mut u8_,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub __ctx: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coredump_params {
    pub siginfo: *const kernel_siginfo_t,
    pub file: *mut file,
    pub limit: ::aya_bpf::cty::c_ulong,
    pub mm_flags: ::aya_bpf::cty::c_ulong,
    pub cpu: ::aya_bpf::cty::c_int,
    pub written: loff_t,
    pub pos: loff_t,
    pub to_skip: loff_t,
    pub vma_count: ::aya_bpf::cty::c_int,
    pub vma_data_size: usize,
    pub vma_meta: *mut core_vma_metadata,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_vma_metadata {
    pub start: ::aya_bpf::cty::c_ulong,
    pub end: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub dump_size: ::aya_bpf::cty::c_ulong,
    pub pgoff: ::aya_bpf::cty::c_ulong,
    pub file: *mut file,
}
pub type nlink_t = u32_;
pub type proc_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut ::aya_bpf::cty::c_char,
        arg3: usize,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
pub struct proc_dir_entry {
    pub in_use: atomic_t,
    pub refcnt: refcount_t,
    pub pde_openers: list_head,
    pub pde_unload_lock: spinlock_t,
    pub pde_unload_completion: *mut completion,
    pub proc_iops: *const inode_operations,
    pub __bindgen_anon_1: proc_dir_entry__bindgen_ty_1,
    pub proc_dops: *const dentry_operations,
    pub __bindgen_anon_2: proc_dir_entry__bindgen_ty_2,
    pub write: proc_write_t,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub state_size: ::aya_bpf::cty::c_uint,
    pub low_ino: ::aya_bpf::cty::c_uint,
    pub nlink: nlink_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub parent: *mut proc_dir_entry,
    pub subdir: rb_root,
    pub subdir_node: rb_node,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub mode: umode_t,
    pub flags: u8_,
    pub namelen: u8_,
    pub inline_name: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proc_dir_entry__bindgen_ty_1 {
    pub proc_ops: *const proc_ops,
    pub proc_dir_ops: *const file_operations,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proc_dir_entry__bindgen_ty_2 {
    pub seq_ops: *const seq_operations,
    pub single_show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct simple_xattrs {
    pub rb_root: rb_root,
    pub lock: rwlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_root {
    pub kn: *mut kernfs_node,
    pub flags: ::aya_bpf::cty::c_uint,
    pub ino_idr: idr,
    pub last_id_lowbits: u32_,
    pub id_highbits: u32_,
    pub syscall_ops: *mut kernfs_syscall_ops,
    pub supers: list_head,
    pub deactivate_waitq: wait_queue_head_t,
    pub kernfs_rwsem: rw_semaphore,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    pub ia_uid: kuid_t,
    pub ia_gid: kgid_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub xattrs: simple_xattrs,
    pub nr_user_xattrs: atomic_t,
    pub user_xattr_size: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut kernfs_root) -> ::aya_bpf::cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_node,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: umode_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kernfs_node) -> ::aya_bpf::cty::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kernfs_node,
            arg2: *mut kernfs_node,
            arg3: *const ::aya_bpf::cty::c_char,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut seq_file,
            arg2: *mut kernfs_node,
            arg3: *mut kernfs_root,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unicode_map {
    pub version: ::aya_bpf::cty::c_uint,
    pub ntab: [*const utf8data; 2usize],
    pub tables: *const utf8data_table,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utf8data {
    pub maxage: ::aya_bpf::cty::c_uint,
    pub offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utf8data_table {
    pub utf8agetab: *const ::aya_bpf::cty::c_uint,
    pub utf8agetab_size: ::aya_bpf::cty::c_int,
    pub utf8nfdicfdata: *const utf8data,
    pub utf8nfdicfdata_size: ::aya_bpf::cty::c_int,
    pub utf8nfdidata: *const utf8data,
    pub utf8nfdidata_size: ::aya_bpf::cty::c_int,
    pub utf8data: *const ::aya_bpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Debug)]
pub struct bucket_table {
    pub size: ::aya_bpf::cty::c_uint,
    pub nest: ::aya_bpf::cty::c_uint,
    pub hash_rnd: u32_,
    pub walkers: list_head,
    pub rcu: callback_head,
    pub future_tbl: *mut bucket_table,
    pub dep_map: lockdep_map,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub buckets: __IncompleteArrayField<*mut rhash_lock_head>,
}
impl bucket_table {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sem_undo_list {
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub list_proc: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_ids {
    pub in_use: ::aya_bpf::cty::c_int,
    pub seq: ::aya_bpf::cty::c_ushort,
    pub rwsem: rw_semaphore,
    pub ipcs_idr: idr,
    pub max_idx: ::aya_bpf::cty::c_int,
    pub last_idx: ::aya_bpf::cty::c_int,
    pub next_id: ::aya_bpf::cty::c_int,
    pub key_ht: rhashtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_namespace {
    pub ids: [ipc_ids; 3usize],
    pub sem_ctls: [::aya_bpf::cty::c_int; 4usize],
    pub used_sems: ::aya_bpf::cty::c_int,
    pub msg_ctlmax: ::aya_bpf::cty::c_uint,
    pub msg_ctlmnb: ::aya_bpf::cty::c_uint,
    pub msg_ctlmni: ::aya_bpf::cty::c_uint,
    pub percpu_msg_bytes: percpu_counter,
    pub percpu_msg_hdrs: percpu_counter,
    pub shm_ctlmax: usize,
    pub shm_ctlall: usize,
    pub shm_tot: ::aya_bpf::cty::c_ulong,
    pub shm_ctlmni: ::aya_bpf::cty::c_int,
    pub shm_rmid_forced: ::aya_bpf::cty::c_int,
    pub ipcns_nb: notifier_block,
    pub mq_mnt: *mut vfsmount,
    pub mq_queues_count: ::aya_bpf::cty::c_uint,
    pub mq_queues_max: ::aya_bpf::cty::c_uint,
    pub mq_msg_max: ::aya_bpf::cty::c_uint,
    pub mq_msgsize_max: ::aya_bpf::cty::c_uint,
    pub mq_msg_default: ::aya_bpf::cty::c_uint,
    pub mq_msgsize_default: ::aya_bpf::cty::c_uint,
    pub mq_set: ctl_table_set,
    pub mq_sysctls: *mut ctl_table_header,
    pub ipc_set: ctl_table_set,
    pub ipc_sysctls: *mut ctl_table_header,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub mnt_llist: llist_node,
    pub ns: ns_common,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_lock_head {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_pkey_query {
    pub supported_ops: __u32,
    pub key_size: __u32,
    pub max_data_size: __u16,
    pub max_sig_size: __u16,
    pub max_enc_size: __u16,
    pub max_dec_size: __u16,
}
pub mod kernel_pkey_operation {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const kernel_pkey_encrypt: Type = 0;
    pub const kernel_pkey_decrypt: Type = 1;
    pub const kernel_pkey_sign: Type = 2;
    pub const kernel_pkey_verify: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_pkey_params {
    pub key: *mut key,
    pub encoding: *const ::aya_bpf::cty::c_char,
    pub hash_algo: *const ::aya_bpf::cty::c_char,
    pub info: *mut ::aya_bpf::cty::c_char,
    pub in_len: __u32,
    pub __bindgen_anon_1: kernel_pkey_params__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_pkey_params__bindgen_ty_1 {
    pub out_len: __u32,
    pub in2_len: __u32,
}
impl kernel_pkey_params {
    #[inline]
    pub fn op(&self) -> kernel_pkey_operation::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_op(&mut self, val: kernel_pkey_operation::Type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(op: kernel_pkey_operation::Type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let op: u32 = unsafe { ::core::mem::transmute(op) };
            op as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_list {
    pub rcu: callback_head,
    pub watchers: hlist_head,
    pub release_watch: ::core::option::Option<unsafe extern "C" fn(arg1: *mut watch)>,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_user {
    pub node: rb_node,
    pub cons_lock: mutex,
    pub lock: spinlock_t,
    pub usage: refcount_t,
    pub nkeys: atomic_t,
    pub nikeys: atomic_t,
    pub uid: kuid_t,
    pub qnkeys: ::aya_bpf::cty::c_int,
    pub qnbytes: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_queue {
    pub rcu: callback_head,
    pub filter: *mut watch_filter,
    pub pipe: *mut pipe_inode_info,
    pub watches: hlist_head,
    pub notes: *mut *mut page,
    pub notes_bitmap: *mut ::aya_bpf::cty::c_ulong,
    pub usage: kref,
    pub lock: spinlock_t,
    pub nr_notes: ::aya_bpf::cty::c_uint,
    pub nr_pages: ::aya_bpf::cty::c_uint,
    pub defunct: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_preparsed_payload {
    pub orig_description: *const ::aya_bpf::cty::c_char,
    pub description: *mut ::aya_bpf::cty::c_char,
    pub payload: key_payload,
    pub data: *const ::aya_bpf::cty::c_void,
    pub datalen: usize,
    pub quotalen: usize,
    pub expiry: time64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_match_data {
    pub cmp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const key, arg2: *const key_match_data) -> bool_,
    >,
    pub raw_data: *const ::aya_bpf::cty::c_void,
    pub preparsed: *mut ::aya_bpf::cty::c_void,
    pub lookup_type: ::aya_bpf::cty::c_uint,
}
pub mod watch_notification_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const WATCH_TYPE_META: Type = 0;
    pub const WATCH_TYPE_KEY_NOTIFY: Type = 1;
    pub const WATCH_TYPE__NR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watch_type_filter {
    pub type_: watch_notification_type::Type,
    pub subtype_filter: [__u32; 1usize],
    pub info_filter: __u32,
    pub info_mask: __u32,
}
#[repr(C)]
pub struct watch_filter {
    pub __bindgen_anon_1: watch_filter__bindgen_ty_1,
    pub nr_filters: u32_,
    pub filters: __IncompleteArrayField<watch_type_filter>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union watch_filter__bindgen_ty_1 {
    pub rcu: callback_head,
    pub type_filter: [::aya_bpf::cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch {
    pub __bindgen_anon_1: watch__bindgen_ty_1,
    pub queue: *mut watch_queue,
    pub queue_node: hlist_node,
    pub watch_list: *mut watch_list,
    pub list_node: hlist_node,
    pub cred: *const cred,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub id: u64_,
    pub usage: kref,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union watch__bindgen_ty_1 {
    pub rcu: callback_head,
    pub info_id: u32_,
}
#[repr(C)]
pub struct request_sock {
    pub __req_common: sock_common,
    pub dl_next: *mut request_sock,
    pub mss: u16_,
    pub num_retrans: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ts_recent: u32_,
    pub rsk_timer: timer_list,
    pub rsk_ops: *const request_sock_ops,
    pub sk: *mut sock,
    pub saved_syn: *mut saved_syn,
    pub secid: u32_,
    pub peer_secid: u32_,
    pub timeout: u32_,
}
impl request_sock {
    #[inline]
    pub fn syncookie(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syncookie(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_timeout(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_num_timeout(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(syncookie: u8_, num_timeout: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let syncookie: u8 = unsafe { ::core::mem::transmute(syncookie) };
            syncookie as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let num_timeout: u8 = unsafe { ::core::mem::transmute(num_timeout) };
            num_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __le32 = __u32;
pub type __le64 = __u64;
pub type __le16 = __u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_sock_ops {
    pub family: ::aya_bpf::cty::c_int,
    pub obj_size: ::aya_bpf::cty::c_uint,
    pub slab: *mut kmem_cache,
    pub slab_name: *mut ::aya_bpf::cty::c_char,
    pub rtx_syn_ack: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *mut request_sock) -> ::aya_bpf::cty::c_int,
    >,
    pub send_ack: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff, arg3: *mut request_sock),
    >,
    pub send_reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const sock, arg2: *mut sk_buff)>,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request_sock)>,
    pub syn_ack_timeout: ::core::option::Option<unsafe extern "C" fn(arg1: *const request_sock)>,
}
#[repr(C)]
#[derive(Debug)]
pub struct saved_syn {
    pub mac_hdrlen: u32_,
    pub network_hdrlen: u32_,
    pub tcp_hdrlen: u32_,
    pub data: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6_mib_device {
    pub mibs: [atomic_long_t; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct icmpv6msg_mib_device {
    pub mibs: [atomic_long_t; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_table {
    pub hash: *mut udp_hslot,
    pub hash2: *mut udp_hslot,
    pub mask: ::aya_bpf::cty::c_uint,
    pub log: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_ra_chain {
    pub next: *mut ip_ra_chain,
    pub sk: *mut sock,
    pub __bindgen_anon_1: ip_ra_chain__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_ra_chain__bindgen_ty_1 {
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_sk: *mut sock,
}
#[repr(C)]
#[derive(Debug)]
pub struct fib_table {
    pub tb_hlist: hlist_node,
    pub tb_id: u32_,
    pub tb_num_default: ::aya_bpf::cty::c_int,
    pub rcu: callback_head,
    pub tb_data: *mut ::aya_bpf::cty::c_ulong,
    pub __data: __IncompleteArrayField<::aya_bpf::cty::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_peer_base {
    pub rb_root: rb_root,
    pub lock: seqlock_t,
    pub total: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_stable_secret {
    pub initialized: bool_,
    pub secret: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_devconf {
    pub forwarding: __s32,
    pub hop_limit: __s32,
    pub mtu6: __s32,
    pub accept_ra: __s32,
    pub accept_redirects: __s32,
    pub autoconf: __s32,
    pub dad_transmits: __s32,
    pub rtr_solicits: __s32,
    pub rtr_solicit_interval: __s32,
    pub rtr_solicit_max_interval: __s32,
    pub rtr_solicit_delay: __s32,
    pub force_mld_version: __s32,
    pub mldv1_unsolicited_report_interval: __s32,
    pub mldv2_unsolicited_report_interval: __s32,
    pub use_tempaddr: __s32,
    pub temp_valid_lft: __s32,
    pub temp_prefered_lft: __s32,
    pub regen_max_retry: __s32,
    pub max_desync_factor: __s32,
    pub max_addresses: __s32,
    pub accept_ra_defrtr: __s32,
    pub ra_defrtr_metric: __u32,
    pub accept_ra_min_hop_limit: __s32,
    pub accept_ra_pinfo: __s32,
    pub ignore_routes_with_linkdown: __s32,
    pub accept_ra_rtr_pref: __s32,
    pub rtr_probe_interval: __s32,
    pub accept_ra_rt_info_min_plen: __s32,
    pub accept_ra_rt_info_max_plen: __s32,
    pub proxy_ndp: __s32,
    pub accept_source_route: __s32,
    pub accept_ra_from_local: __s32,
    pub mc_forwarding: atomic_t,
    pub disable_ipv6: __s32,
    pub drop_unicast_in_l2_multicast: __s32,
    pub accept_dad: __s32,
    pub force_tllao: __s32,
    pub ndisc_notify: __s32,
    pub suppress_frag_ndisc: __s32,
    pub accept_ra_mtu: __s32,
    pub drop_unsolicited_na: __s32,
    pub accept_untracked_na: __s32,
    pub stable_secret: ipv6_stable_secret,
    pub use_oif_addrs_only: __s32,
    pub keep_addr_on_down: __s32,
    pub seg6_enabled: __s32,
    pub seg6_require_hmac: __s32,
    pub enhanced_dad: __u32,
    pub addr_gen_mode: __u32,
    pub disable_policy: __s32,
    pub ndisc_tclass: __s32,
    pub rpl_seg_enabled: __s32,
    pub ioam6_id: __u32,
    pub ioam6_id_wide: __u32,
    pub ioam6_enabled: __u8,
    pub ndisc_evict_nocarrier: __u8,
    pub sysctl_header: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_devstat {
    pub proc_dir_entry: *mut proc_dir_entry,
    pub ipv6: *mut ipstats_mib,
    pub icmpv6dev: *mut icmpv6_mib_device,
    pub icmpv6msgdev: *mut icmpv6msg_mib_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet6_dev {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub addr_list: list_head,
    pub mc_list: *mut ifmcaddr6,
    pub mc_tomb: *mut ifmcaddr6,
    pub mc_qrv: ::aya_bpf::cty::c_uchar,
    pub mc_gq_running: ::aya_bpf::cty::c_uchar,
    pub mc_ifc_count: ::aya_bpf::cty::c_uchar,
    pub mc_dad_count: ::aya_bpf::cty::c_uchar,
    pub mc_v1_seen: ::aya_bpf::cty::c_ulong,
    pub mc_qi: ::aya_bpf::cty::c_ulong,
    pub mc_qri: ::aya_bpf::cty::c_ulong,
    pub mc_maxdelay: ::aya_bpf::cty::c_ulong,
    pub mc_gq_work: delayed_work,
    pub mc_ifc_work: delayed_work,
    pub mc_dad_work: delayed_work,
    pub mc_query_work: delayed_work,
    pub mc_report_work: delayed_work,
    pub mc_query_queue: sk_buff_head,
    pub mc_report_queue: sk_buff_head,
    pub mc_query_lock: spinlock_t,
    pub mc_report_lock: spinlock_t,
    pub mc_lock: mutex,
    pub ac_list: *mut ifacaddr6,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub if_flags: __u32,
    pub dead: ::aya_bpf::cty::c_int,
    pub desync_factor: u32_,
    pub tempaddr_list: list_head,
    pub token: in6_addr,
    pub nd_parms: *mut neigh_parms,
    pub cnf: ipv6_devconf,
    pub stats: ipv6_devstat,
    pub rs_timer: timer_list,
    pub rs_interval: __s32,
    pub rs_probes: __u8,
    pub tstamp: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
    pub ra_mtu: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct lwtunnel_state {
    pub type_: __u16,
    pub flags: __u16,
    pub headroom: __u16,
    pub refcnt: atomic_t,
    pub orig_output: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub orig_input:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::aya_bpf::cty::c_int>,
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timewait_sock_ops {
    pub twsk_slab: *mut kmem_cache,
    pub twsk_slab_name: *mut ::aya_bpf::cty::c_char,
    pub twsk_obj_size: ::aya_bpf::cty::c_uint,
    pub twsk_unique: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sock,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub twsk_destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_sf_list {
    pub sf_next: *mut ip6_sf_list,
    pub sf_addr: in6_addr,
    pub sf_count: [::aya_bpf::cty::c_ulong; 2usize],
    pub sf_gsresp: ::aya_bpf::cty::c_uchar,
    pub sf_oldin: ::aya_bpf::cty::c_uchar,
    pub sf_crcount: ::aya_bpf::cty::c_uchar,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifmcaddr6 {
    pub mca_addr: in6_addr,
    pub idev: *mut inet6_dev,
    pub next: *mut ifmcaddr6,
    pub mca_sources: *mut ip6_sf_list,
    pub mca_tomb: *mut ip6_sf_list,
    pub mca_sfmode: ::aya_bpf::cty::c_uint,
    pub mca_crcount: ::aya_bpf::cty::c_uchar,
    pub mca_sfcount: [::aya_bpf::cty::c_ulong; 2usize],
    pub mca_work: delayed_work,
    pub mca_flags: ::aya_bpf::cty::c_uint,
    pub mca_users: ::aya_bpf::cty::c_int,
    pub mca_refcnt: refcount_t,
    pub mca_cstamp: ::aya_bpf::cty::c_ulong,
    pub mca_tstamp: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifacaddr6 {
    pub aca_addr: in6_addr,
    pub aca_rt: *mut fib6_info,
    pub aca_next: *mut ifacaddr6,
    pub aca_addr_lst: hlist_node,
    pub aca_users: ::aya_bpf::cty::c_int,
    pub aca_refcnt: refcount_t,
    pub aca_cstamp: ::aya_bpf::cty::c_ulong,
    pub aca_tstamp: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nd_opt_hdr {
    pub nd_opt_type: __u8,
    pub nd_opt_len: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndisc_options {
    pub nd_opt_array: [*mut nd_opt_hdr; 15usize],
    pub nd_opts_ri: *mut nd_opt_hdr,
    pub nd_opts_ri_end: *mut nd_opt_hdr,
    pub nd_useropts: *mut nd_opt_hdr,
    pub nd_useropts_end: *mut nd_opt_hdr,
    pub nd_802154_opt_array: [*mut nd_opt_hdr; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prefix_info {
    pub type_: __u8,
    pub length: __u8,
    pub prefix_len: __u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub valid: __be32,
    pub prefered: __be32,
    pub reserved2: __be32,
    pub prefix: in6_addr,
}
impl prefix_info {
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn autoconf(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autoconf(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onlink(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onlink(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u8,
        autoconf: __u8,
        onlink: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoconf: u8 = unsafe { ::core::mem::transmute(autoconf) };
            autoconf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let onlink: u8 = unsafe { ::core::mem::transmute(onlink) };
            onlink as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udp_hslot {
    pub head: hlist_head,
    pub count: ::aya_bpf::cty::c_int,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [::aya_bpf::cty::c_uchar; 6usize],
    pub h_source: [::aya_bpf::cty::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [::aya_bpf::cty::c_char; 32usize],
    pub version: [::aya_bpf::cty::c_char; 32usize],
    pub fw_version: [::aya_bpf::cty::c_char; 32usize],
    pub bus_info: [::aya_bpf::cty::c_char; 32usize],
    pub erom_version: [::aya_bpf::cty::c_char; 32usize],
    pub reserved2: [::aya_bpf::cty::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
pub mod ethtool_link_ext_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_STATE_AUTONEG: Type = 0;
    pub const ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE: Type = 1;
    pub const ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH: Type = 2;
    pub const ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY: Type = 3;
    pub const ETHTOOL_LINK_EXT_STATE_NO_CABLE: Type = 4;
    pub const ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE: Type = 5;
    pub const ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE: Type = 6;
    pub const ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE: Type = 7;
    pub const ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED: Type = 8;
    pub const ETHTOOL_LINK_EXT_STATE_OVERHEAT: Type = 9;
    pub const ETHTOOL_LINK_EXT_STATE_MODULE: Type = 10;
}
pub mod ethtool_link_ext_substate_autoneg {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE: Type = 4;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE: Type = 5;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD: Type = 6;
}
pub mod ethtool_link_ext_substate_link_training {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT: Type = 4;
}
pub mod ethtool_link_ext_substate_link_logical_mismatch {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED: Type = 4;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED: Type = 5;
}
pub mod ethtool_link_ext_substate_bad_signal_integrity {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE: Type = 2;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST: Type = 3;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS: Type = 4;
}
pub mod ethtool_link_ext_substate_cable_issue {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE: Type = 1;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE: Type = 2;
}
pub mod ethtool_link_ext_substate_module {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY: Type = 1;
}
pub mod ethtool_module_power_mode_policy {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH: Type = 1;
    pub const ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO: Type = 2;
}
pub mod ethtool_module_power_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_MODULE_POWER_MODE_LOW: Type = 1;
    pub const ETHTOOL_MODULE_POWER_MODE_HIGH: Type = 2;
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [::aya_bpf::cty::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [::aya_bpf::cty::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub master_slave_cfg: __u8,
    pub master_slave_state: __u8,
    pub rate_matching: __u8,
    pub reserved: [__u32; 7usize],
    pub link_mode_masks: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_ethtool_ringparam {
    pub rx_buf_len: u32_,
    pub tcp_data_split: u8_,
    pub tx_push: u8_,
    pub cqe_size: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_link_ext_state_info {
    pub link_ext_state: ethtool_link_ext_state::Type,
    pub __bindgen_anon_1: ethtool_link_ext_state_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_link_ext_state_info__bindgen_ty_1 {
    pub autoneg: ethtool_link_ext_substate_autoneg::Type,
    pub link_training: ethtool_link_ext_substate_link_training::Type,
    pub link_logical_mismatch: ethtool_link_ext_substate_link_logical_mismatch::Type,
    pub bad_signal_integrity: ethtool_link_ext_substate_bad_signal_integrity::Type,
    pub cable_issue: ethtool_link_ext_substate_cable_issue::Type,
    pub module: ethtool_link_ext_substate_module::Type,
    pub __link_ext_substate: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_link_ext_stats {
    pub link_down_events: u64_,
}
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_link_ksettings {
    pub base: ethtool_link_settings,
    pub link_modes: ethtool_link_ksettings__bindgen_ty_1,
    pub lanes: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_link_ksettings__bindgen_ty_1 {
    pub supported: [::aya_bpf::cty::c_ulong; 2usize],
    pub advertising: [::aya_bpf::cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf::cty::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_ethtool_coalesce {
    pub use_cqe_mode_tx: u8_,
    pub use_cqe_mode_rx: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eth_mac_stats {
    pub FramesTransmittedOK: u64_,
    pub SingleCollisionFrames: u64_,
    pub MultipleCollisionFrames: u64_,
    pub FramesReceivedOK: u64_,
    pub FrameCheckSequenceErrors: u64_,
    pub AlignmentErrors: u64_,
    pub OctetsTransmittedOK: u64_,
    pub FramesWithDeferredXmissions: u64_,
    pub LateCollisions: u64_,
    pub FramesAbortedDueToXSColls: u64_,
    pub FramesLostDueToIntMACXmitError: u64_,
    pub CarrierSenseErrors: u64_,
    pub OctetsReceivedOK: u64_,
    pub FramesLostDueToIntMACRcvError: u64_,
    pub MulticastFramesXmittedOK: u64_,
    pub BroadcastFramesXmittedOK: u64_,
    pub FramesWithExcessiveDeferral: u64_,
    pub MulticastFramesReceivedOK: u64_,
    pub BroadcastFramesReceivedOK: u64_,
    pub InRangeLengthErrors: u64_,
    pub OutOfRangeLengthField: u64_,
    pub FrameTooLongErrors: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eth_phy_stats {
    pub SymbolErrorDuringCarrier: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eth_ctrl_stats {
    pub MACControlFramesTransmitted: u64_,
    pub MACControlFramesReceived: u64_,
    pub UnsupportedOpcodesReceived: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_pause_stats {
    pub tx_pause_frames: u64_,
    pub rx_pause_frames: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_fec_stat {
    pub total: u64_,
    pub lanes: [u64_; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_fec_stats {
    pub corrected_blocks: ethtool_fec_stat,
    pub uncorrectable_blocks: ethtool_fec_stat,
    pub corrected_bits: ethtool_fec_stat,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_rmon_hist_range {
    pub low: u16_,
    pub high: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_rmon_stats {
    pub undersize_pkts: u64_,
    pub oversize_pkts: u64_,
    pub fragments: u64_,
    pub jabbers: u64_,
    pub hist: [u64_; 10usize],
    pub hist_tx: [u64_; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_module_eeprom {
    pub offset: u32_,
    pub length: u32_,
    pub page: u8_,
    pub bank: u8_,
    pub i2c_address: u8_,
    pub data: *mut u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_module_power_mode_params {
    pub policy: ethtool_module_power_mode_policy::Type,
    pub mode: ethtool_module_power_mode::Type,
}
pub mod ib_poll_context {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_POLL_SOFTIRQ: Type = 0;
    pub const IB_POLL_WORKQUEUE: Type = 1;
    pub const IB_POLL_UNBOUND_WORKQUEUE: Type = 2;
    pub const IB_POLL_LAST_POOL_TYPE: Type = 2;
    pub const IB_POLL_DIRECT: Type = 3;
}
#[repr(C)]
pub struct crypto_instance {
    pub alg: crypto_alg,
    pub tmpl: *mut crypto_template,
    pub __bindgen_anon_1: crypto_instance__bindgen_ty_1,
    pub __ctx: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_instance__bindgen_ty_1 {
    pub list: hlist_node,
    pub spawns: *mut crypto_spawn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_spawn {
    pub list: list_head,
    pub alg: *mut crypto_alg,
    pub __bindgen_anon_1: crypto_spawn__bindgen_ty_1,
    pub frontend: *const crypto_type,
    pub mask: u32_,
    pub dead: bool_,
    pub registered: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union crypto_spawn__bindgen_ty_1 {
    pub inst: *mut crypto_instance,
    pub next: *mut crypto_spawn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_template {
    pub list: list_head,
    pub instances: hlist_head,
    pub module: *mut module,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crypto_template,
            arg2: *mut *mut rtattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub name: [::aya_bpf::cty::c_char; 128usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_aead {
    pub authsize: ::aya_bpf::cty::c_uint,
    pub reqsize: ::aya_bpf::cty::c_uint,
    pub base: crypto_tfm,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_shash {
    pub descsize: ::aya_bpf::cty::c_uint,
    pub base: crypto_tfm,
}
#[repr(C)]
#[derive(Debug)]
pub struct crypto_skcipher {
    pub reqsize: ::aya_bpf::cty::c_uint,
    pub base: crypto_tfm,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_iostat {
    pub bytes: [u64_; 3usize],
    pub ios: [u64_; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_iostat_set {
    pub sync: u64_stats_sync,
    pub blkg: *mut blkcg_gq,
    pub lnode: llist_node,
    pub lqueued: ::aya_bpf::cty::c_int,
    pub cur: blkg_iostat,
    pub last: blkg_iostat,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg_gq {
    pub q: *mut request_queue,
    pub q_node: list_head,
    pub blkcg_node: hlist_node,
    pub blkcg: *mut blkcg,
    pub parent: *mut blkcg_gq,
    pub refcnt: percpu_ref,
    pub online: bool_,
    pub iostat_cpu: *mut blkg_iostat_set,
    pub iostat: blkg_iostat_set,
    pub pd: [*mut blkg_policy_data; 6usize],
    pub async_bio_lock: spinlock_t,
    pub async_bios: bio_list,
    pub __bindgen_anon_1: blkcg_gq__bindgen_ty_1,
    pub use_delay: atomic_t,
    pub delay_nsec: atomic64_t,
    pub delay_start: atomic64_t,
    pub last_delay: u64_,
    pub last_use: ::aya_bpf::cty::c_int,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union blkcg_gq__bindgen_ty_1 {
    pub async_bio_work: work_struct,
    pub free_work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_crypt_ctx {
    pub bc_key: *const blk_crypto_key,
    pub bc_dun: [u64_; 4usize],
}
pub type blk_mq_req_flags_t = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap_word {
    pub word: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub cleared: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap {
    pub depth: ::aya_bpf::cty::c_uint,
    pub shift: ::aya_bpf::cty::c_uint,
    pub map_nr: ::aya_bpf::cty::c_uint,
    pub round_robin: bool_,
    pub map: *mut sbitmap_word,
    pub alloc_hint: *mut ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sbq_wait_state {
    pub wait: wait_queue_head_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbitmap_queue {
    pub sb: sbitmap,
    pub wake_batch: ::aya_bpf::cty::c_uint,
    pub wake_index: atomic_t,
    pub ws: *mut sbq_wait_state,
    pub ws_active: atomic_t,
    pub min_shallow_depth: ::aya_bpf::cty::c_uint,
    pub completion_cnt: atomic_t,
    pub wakeup_cnt: atomic_t,
}
pub type req_flags_t = __u32;
pub mod mq_rq_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MQ_RQ_IDLE: Type = 0;
    pub const MQ_RQ_IN_FLIGHT: Type = 1;
    pub const MQ_RQ_COMPLETE: Type = 2;
}
pub mod rq_end_io_ret {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RQ_END_IO_NONE: Type = 0;
    pub const RQ_END_IO_FREE: Type = 1;
}
pub type rq_end_io_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut request, arg2: blk_status_t) -> rq_end_io_ret::Type,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request {
    pub q: *mut request_queue,
    pub mq_ctx: *mut blk_mq_ctx,
    pub mq_hctx: *mut blk_mq_hw_ctx,
    pub cmd_flags: blk_opf_t,
    pub rq_flags: req_flags_t,
    pub tag: ::aya_bpf::cty::c_int,
    pub internal_tag: ::aya_bpf::cty::c_int,
    pub timeout: ::aya_bpf::cty::c_uint,
    pub __data_len: ::aya_bpf::cty::c_uint,
    pub __sector: sector_t,
    pub bio: *mut bio,
    pub biotail: *mut bio,
    pub __bindgen_anon_1: request__bindgen_ty_1,
    pub part: *mut block_device,
    pub alloc_time_ns: u64_,
    pub start_time_ns: u64_,
    pub io_start_time_ns: u64_,
    pub wbt_flags: ::aya_bpf::cty::c_ushort,
    pub stats_sectors: ::aya_bpf::cty::c_ushort,
    pub nr_phys_segments: ::aya_bpf::cty::c_ushort,
    pub nr_integrity_segments: ::aya_bpf::cty::c_ushort,
    pub crypt_ctx: *mut bio_crypt_ctx,
    pub crypt_keyslot: *mut blk_crypto_keyslot,
    pub ioprio: ::aya_bpf::cty::c_ushort,
    pub state: mq_rq_state::Type,
    pub ref_: atomic_t,
    pub deadline: ::aya_bpf::cty::c_ulong,
    pub __bindgen_anon_2: request__bindgen_ty_2,
    pub __bindgen_anon_3: request__bindgen_ty_3,
    pub __bindgen_anon_4: request__bindgen_ty_4,
    pub __bindgen_anon_5: request__bindgen_ty_5,
    pub end_io: rq_end_io_fn,
    pub end_io_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_1 {
    pub queuelist: list_head,
    pub rq_next: *mut request,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_2 {
    pub hash: hlist_node,
    pub ipi_list: llist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_3 {
    pub rb_node: rb_node,
    pub special_vec: bio_vec,
    pub completion_data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_4 {
    pub elv: request__bindgen_ty_4__bindgen_ty_1,
    pub flush: request__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_4__bindgen_ty_1 {
    pub icq: *mut io_cq,
    pub priv_: [*mut ::aya_bpf::cty::c_void; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request__bindgen_ty_4__bindgen_ty_2 {
    pub seq: ::aya_bpf::cty::c_uint,
    pub list: list_head,
    pub saved_end_io: rq_end_io_fn,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union request__bindgen_ty_5 {
    pub csd: __call_single_data,
    pub fifo_time: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elevator_queue {
    pub type_: *mut elevator_type,
    pub elevator_data: *mut ::aya_bpf::cty::c_void,
    pub kobj: kobject,
    pub sysfs_lock: mutex,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub hash: [hlist_head; 64usize],
}
pub mod rq_qos_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RQ_QOS_WBT: Type = 0;
    pub const RQ_QOS_LATENCY: Type = 1;
    pub const RQ_QOS_COST: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_qos {
    pub ops: *mut rq_qos_ops,
    pub q: *mut request_queue,
    pub id: rq_qos_id::Type,
    pub next: *mut rq_qos,
    pub debugfs_dir: *mut dentry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_ctx {
    pub __bindgen_anon_1: blk_mq_ctx__bindgen_ty_1,
    pub cpu: ::aya_bpf::cty::c_uint,
    pub index_hw: [::aya_bpf::cty::c_ushort; 3usize],
    pub hctxs: [*mut blk_mq_hw_ctx; 3usize],
    pub queue: *mut request_queue,
    pub ctxs: *mut blk_mq_ctxs,
    pub kobj: kobject,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub rq_lists: [list_head; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl blk_mq_ctx__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl blk_mq_ctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_stat_callback {
    pub list: list_head,
    pub timer: timer_list,
    pub cpu_stat: *mut blk_rq_stat,
    pub bucket_fn:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const request) -> ::aya_bpf::cty::c_int>,
    pub buckets: ::aya_bpf::cty::c_uint,
    pub stat: *mut blk_rq_stat,
    pub timer_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_stat_callback)>,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tags {
    pub nr_tags: ::aya_bpf::cty::c_uint,
    pub nr_reserved_tags: ::aya_bpf::cty::c_uint,
    pub active_queues: atomic_t,
    pub bitmap_tags: sbitmap_queue,
    pub breserved_tags: sbitmap_queue,
    pub rqs: *mut *mut request,
    pub static_rqs: *mut *mut request,
    pub page_list: list_head,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_trace {
    pub trace_state: ::aya_bpf::cty::c_int,
    pub rchan: *mut rchan,
    pub sequence: *mut ::aya_bpf::cty::c_ulong,
    pub msg_data: *mut ::aya_bpf::cty::c_uchar,
    pub act_mask: u16_,
    pub start_lba: u64_,
    pub end_lba: u64_,
    pub pid: u32_,
    pub dev: u32_,
    pub dir: *mut dentry,
    pub running_list: list_head,
    pub dropped: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_flush_queue {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rq_status: blk_status_t,
    pub flush_pending_since: ::aya_bpf::cty::c_ulong,
    pub flush_queue: [list_head; 2usize],
    pub flush_data_in_flight: list_head,
    pub flush_rq: *mut request,
    pub mq_flush_lock: spinlock_t,
}
impl blk_flush_queue {
    #[inline]
    pub fn flush_pending_idx(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_pending_idx(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush_running_idx(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush_running_idx(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flush_pending_idx: ::aya_bpf::cty::c_uint,
        flush_running_idx: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flush_pending_idx: u32 = unsafe { ::core::mem::transmute(flush_pending_idx) };
            flush_pending_idx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let flush_running_idx: u32 = unsafe { ::core::mem::transmute(flush_running_idx) };
            flush_running_idx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_queue_map {
    pub mq_map: *mut ::aya_bpf::cty::c_uint,
    pub nr_queues: ::aya_bpf::cty::c_uint,
    pub queue_offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_tag_set {
    pub map: [blk_mq_queue_map; 3usize],
    pub nr_maps: ::aya_bpf::cty::c_uint,
    pub ops: *const blk_mq_ops,
    pub nr_hw_queues: ::aya_bpf::cty::c_uint,
    pub queue_depth: ::aya_bpf::cty::c_uint,
    pub reserved_tags: ::aya_bpf::cty::c_uint,
    pub cmd_size: ::aya_bpf::cty::c_uint,
    pub numa_node: ::aya_bpf::cty::c_int,
    pub timeout: ::aya_bpf::cty::c_uint,
    pub flags: ::aya_bpf::cty::c_uint,
    pub driver_data: *mut ::aya_bpf::cty::c_void,
    pub tags: *mut *mut blk_mq_tags,
    pub shared_tags: *mut blk_mq_tags,
    pub tag_list_lock: mutex,
    pub tag_list: list_head,
    pub srcu: *mut srcu_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx {
    pub __bindgen_anon_1: blk_mq_hw_ctx__bindgen_ty_1,
    pub run_work: delayed_work,
    pub cpumask: cpumask_var_t,
    pub next_cpu: ::aya_bpf::cty::c_int,
    pub next_cpu_batch: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub sched_data: *mut ::aya_bpf::cty::c_void,
    pub queue: *mut request_queue,
    pub fq: *mut blk_flush_queue,
    pub driver_data: *mut ::aya_bpf::cty::c_void,
    pub ctx_map: sbitmap,
    pub dispatch_from: *mut blk_mq_ctx,
    pub dispatch_busy: ::aya_bpf::cty::c_uint,
    pub type_: ::aya_bpf::cty::c_ushort,
    pub nr_ctx: ::aya_bpf::cty::c_ushort,
    pub ctxs: *mut *mut blk_mq_ctx,
    pub dispatch_wait_lock: spinlock_t,
    pub dispatch_wait: wait_queue_entry_t,
    pub wait_index: atomic_t,
    pub tags: *mut blk_mq_tags,
    pub sched_tags: *mut blk_mq_tags,
    pub queued: ::aya_bpf::cty::c_ulong,
    pub run: ::aya_bpf::cty::c_ulong,
    pub numa_node: ::aya_bpf::cty::c_uint,
    pub queue_num: ::aya_bpf::cty::c_uint,
    pub nr_active: atomic_t,
    pub cpuhp_online: hlist_node,
    pub cpuhp_dead: hlist_node,
    pub kobj: kobject,
    pub debugfs_dir: *mut dentry,
    pub sched_debugfs_dir: *mut dentry,
    pub hctx_list: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_mq_hw_ctx__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub dispatch: list_head,
    pub state: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl blk_mq_hw_ctx__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl blk_mq_hw_ctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_queue_data {
    pub rq: *mut request,
    pub last: bool_,
}
pub mod blk_crypto_mode_num {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const BLK_ENCRYPTION_MODE_INVALID: Type = 0;
    pub const BLK_ENCRYPTION_MODE_AES_256_XTS: Type = 1;
    pub const BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV: Type = 2;
    pub const BLK_ENCRYPTION_MODE_ADIANTUM: Type = 3;
    pub const BLK_ENCRYPTION_MODE_SM4_XTS: Type = 4;
    pub const BLK_ENCRYPTION_MODE_MAX: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_crypto_config {
    pub crypto_mode: blk_crypto_mode_num::Type,
    pub data_unit_size: ::aya_bpf::cty::c_uint,
    pub dun_bytes: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_crypto_key {
    pub crypto_cfg: blk_crypto_config,
    pub data_unit_size_bits: ::aya_bpf::cty::c_uint,
    pub size: ::aya_bpf::cty::c_uint,
    pub raw: [u8_; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_ctxs {
    pub kobj: kobject,
    pub queue_ctx: *mut blk_mq_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_alloc_data {
    pub q: *mut request_queue,
    pub flags: blk_mq_req_flags_t,
    pub shallow_depth: ::aya_bpf::cty::c_uint,
    pub cmd_flags: blk_opf_t,
    pub rq_flags: req_flags_t,
    pub nr_tags: ::aya_bpf::cty::c_uint,
    pub cached_rq: *mut *mut request,
    pub ctx: *mut blk_mq_ctx,
    pub hctx: *mut blk_mq_hw_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_mq_debugfs_attr {
    pub name: *const ::aya_bpf::cty::c_char,
    pub mode: umode_t,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_void,
            arg2: *mut seq_file,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_void,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub seq_ops: *const seq_operations,
}
pub mod elv_merge {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ELEVATOR_NO_MERGE: Type = 0;
    pub const ELEVATOR_FRONT_MERGE: Type = 1;
    pub const ELEVATOR_BACK_MERGE: Type = 2;
    pub const ELEVATOR_DISCARD_MERGE: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elevator_mq_ops {
    pub init_sched: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request_queue,
            arg2: *mut elevator_type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub exit_sched: ::core::option::Option<unsafe extern "C" fn(arg1: *mut elevator_queue)>,
    pub init_hctx: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_mq_hw_ctx,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub exit_hctx: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub depth_updated: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx)>,
    pub allow_merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut bio) -> bool_,
    >,
    pub bio_merge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request_queue,
            arg2: *mut bio,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> bool_,
    >,
    pub request_merge: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut request_queue,
            arg2: *mut *mut request,
            arg3: *mut bio,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub request_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: elv_merge::Type),
    >,
    pub requests_merged: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request, arg3: *mut request),
    >,
    pub limit_depth:
        ::core::option::Option<unsafe extern "C" fn(arg1: blk_opf_t, arg2: *mut blk_mq_alloc_data)>,
    pub prepare_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub finish_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub insert_requests: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx, arg2: *mut list_head, arg3: bool_),
    >,
    pub dispatch_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> *mut request>,
    pub has_work: ::core::option::Option<unsafe extern "C" fn(arg1: *mut blk_mq_hw_ctx) -> bool_>,
    pub completed_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut request, arg2: u64_)>,
    pub requeue_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut request)>,
    pub former_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub next_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut request_queue, arg2: *mut request) -> *mut request,
    >,
    pub init_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
    pub exit_icq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_cq)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elevator_type {
    pub icq_cache: *mut kmem_cache,
    pub ops: elevator_mq_ops,
    pub icq_size: usize,
    pub icq_align: usize,
    pub elevator_attrs: *mut elv_fs_entry,
    pub elevator_name: *const ::aya_bpf::cty::c_char,
    pub elevator_alias: *const ::aya_bpf::cty::c_char,
    pub elevator_features: ::aya_bpf::cty::c_uint,
    pub elevator_owner: *mut module,
    pub queue_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub hctx_debugfs_attrs: *const blk_mq_debugfs_attr,
    pub icq_cache_name: [::aya_bpf::cty::c_char; 22usize],
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elv_fs_entry {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut elevator_queue, arg2: *mut ::aya_bpf::cty::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut elevator_queue,
            arg2: *const ::aya_bpf::cty::c_char,
            arg3: usize,
        ) -> isize,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq_qos_ops {
    pub throttle: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub track: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
    >,
    pub merge: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request, arg3: *mut bio),
    >,
    pub issue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub requeue:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub done: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut request)>,
    pub done_bio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos, arg2: *mut bio)>,
    pub queue_depth_changed: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rq_qos)>,
    pub debugfs_attrs: *const blk_mq_debugfs_attr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blkcg {
    pub css: cgroup_subsys_state,
    pub lock: spinlock_t,
    pub online_pin: refcount_t,
    pub blkg_tree: xarray,
    pub blkg_hint: *mut blkcg_gq,
    pub blkg_list: hlist_head,
    pub cpd: [*mut blkcg_policy_data; 6usize],
    pub all_blkcgs_node: list_head,
    pub lhead: *mut llist_head,
    pub fc_app_id: [::aya_bpf::cty::c_char; 129usize],
    pub cgwb_list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkg_policy_data {
    pub blkg: *mut blkcg_gq,
    pub plid: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkcg_policy_data {
    pub blkcg: *mut blkcg,
    pub plid: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_crypto_ll_ops {
    pub keyslot_program: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_crypto_profile,
            arg2: *const blk_crypto_key,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub keyslot_evict: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut blk_crypto_profile,
            arg2: *const blk_crypto_key,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_crypto_profile {
    pub ll_ops: blk_crypto_ll_ops,
    pub max_dun_bytes_supported: ::aya_bpf::cty::c_uint,
    pub modes_supported: [::aya_bpf::cty::c_uint; 5usize],
    pub dev: *mut device,
    pub num_slots: ::aya_bpf::cty::c_uint,
    pub lock: rw_semaphore,
    pub idle_slots_wait_queue: wait_queue_head_t,
    pub idle_slots: list_head,
    pub idle_slots_lock: spinlock_t,
    pub slot_hashtable: *mut hlist_head,
    pub log_slot_ht_size: ::aya_bpf::cty::c_uint,
    pub slots: *mut blk_crypto_keyslot,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_crypto_keyslot {
    pub slot_refs: atomic_t,
    pub idle_slot_node: list_head,
    pub hash_node: hlist_node,
    pub key: *const blk_crypto_key,
    pub profile: *mut blk_crypto_profile,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_integrity_iter {
    pub prot_buf: *mut ::aya_bpf::cty::c_void,
    pub data_buf: *mut ::aya_bpf::cty::c_void,
    pub seed: sector_t,
    pub data_size: ::aya_bpf::cty::c_uint,
    pub interval: ::aya_bpf::cty::c_ushort,
    pub tuple_size: ::aya_bpf::cty::c_uchar,
    pub disk_name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_task {
    pub cached_refs: ::aya_bpf::cty::c_int,
    pub last: *const io_ring_ctx,
    pub io_wq: *mut io_wq,
    pub registered_rings: [*mut file; 16usize],
    pub xa: xarray,
    pub wait: wait_queue_head,
    pub in_idle: atomic_t,
    pub inflight_tracked: atomic_t,
    pub inflight: percpu_counter,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub __bindgen_anon_1: io_uring_task__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_task__bindgen_ty_1 {
    pub task_list: llist_head,
    pub task_work: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
impl io_uring_task {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_cmd {
    pub file: *mut file,
    pub cmd: *const ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: io_uring_cmd__bindgen_ty_1,
    pub cmd_op: u32_,
    pub flags: u32_,
    pub pdu: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_cmd__bindgen_ty_1 {
    pub task_work_cb: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut io_uring_cmd, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub cookie: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
pub struct io_uring_sqe {
    pub opcode: __u8,
    pub flags: __u8,
    pub ioprio: __u16,
    pub fd: __s32,
    pub __bindgen_anon_1: io_uring_sqe__bindgen_ty_1,
    pub __bindgen_anon_2: io_uring_sqe__bindgen_ty_2,
    pub len: __u32,
    pub __bindgen_anon_3: io_uring_sqe__bindgen_ty_3,
    pub user_data: __u64,
    pub __bindgen_anon_4: io_uring_sqe__bindgen_ty_4,
    pub personality: __u16,
    pub __bindgen_anon_5: io_uring_sqe__bindgen_ty_5,
    pub __bindgen_anon_6: io_uring_sqe__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_sqe__bindgen_ty_1 {
    pub off: __u64,
    pub addr2: __u64,
    pub __bindgen_anon_1: io_uring_sqe__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_sqe__bindgen_ty_1__bindgen_ty_1 {
    pub cmd_op: __u32,
    pub __pad1: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_sqe__bindgen_ty_2 {
    pub addr: __u64,
    pub splice_off_in: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_sqe__bindgen_ty_3 {
    pub rw_flags: __kernel_rwf_t,
    pub fsync_flags: __u32,
    pub poll_events: __u16,
    pub poll32_events: __u32,
    pub sync_range_flags: __u32,
    pub msg_flags: __u32,
    pub timeout_flags: __u32,
    pub accept_flags: __u32,
    pub cancel_flags: __u32,
    pub open_flags: __u32,
    pub statx_flags: __u32,
    pub fadvise_advice: __u32,
    pub splice_flags: __u32,
    pub rename_flags: __u32,
    pub unlink_flags: __u32,
    pub hardlink_flags: __u32,
    pub xattr_flags: __u32,
    pub msg_ring_flags: __u32,
    pub uring_cmd_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_sqe__bindgen_ty_4 {
    pub buf_index: __u16,
    pub buf_group: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_uring_sqe__bindgen_ty_5 {
    pub splice_fd_in: __s32,
    pub file_index: __u32,
    pub __bindgen_anon_1: io_uring_sqe__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_sqe__bindgen_ty_5__bindgen_ty_1 {
    pub addr_len: __u16,
    pub __pad3: [__u16; 1usize],
}
#[repr(C)]
pub struct io_uring_sqe__bindgen_ty_6 {
    pub __bindgen_anon_1: __BindgenUnionField<io_uring_sqe__bindgen_ty_6__bindgen_ty_1>,
    pub cmd: __BindgenUnionField<[__u8; 0usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_sqe__bindgen_ty_6__bindgen_ty_1 {
    pub addr3: __u64,
    pub __pad2: [__u64; 1usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct io_uring_cqe {
    pub user_data: __u64,
    pub res: __s32,
    pub flags: __u32,
    pub big_cqe: __IncompleteArrayField<__u64>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_wq_work_node {
    pub next: *mut io_wq_work_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_wq_work_list {
    pub first: *mut io_wq_work_node,
    pub last: *mut io_wq_work_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_wq_work {
    pub list: io_wq_work_node,
    pub flags: ::aya_bpf::cty::c_uint,
    pub cancel_seq: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_fixed_file {
    pub file_ptr: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_file_table {
    pub files: *mut io_fixed_file,
    pub bitmap: *mut ::aya_bpf::cty::c_ulong,
    pub alloc_hint: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_hash_bucket {
    pub lock: spinlock_t,
    pub list: hlist_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_hash_table {
    pub hbs: *mut io_hash_bucket,
    pub hash_bits: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_submit_link {
    pub head: *mut io_kiocb,
    pub last: *mut io_kiocb,
}
#[repr(C)]
#[derive(Debug)]
pub struct io_submit_state {
    pub free_list: io_wq_work_node,
    pub compl_reqs: io_wq_work_list,
    pub link: io_submit_link,
    pub plug_started: bool_,
    pub need_plug: bool_,
    pub submit_nr: ::aya_bpf::cty::c_ushort,
    pub cqes_count: ::aya_bpf::cty::c_uint,
    pub plug: blk_plug,
    pub cqes: [io_uring_cqe; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_alloc_cache {
    pub list: hlist_head,
    pub nr_cached: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_restriction {
    pub register_op: [::aya_bpf::cty::c_ulong; 1usize],
    pub sqe_op: [::aya_bpf::cty::c_ulong; 1usize],
    pub sqe_flags_allowed: u8_,
    pub sqe_flags_required: u8_,
    pub registered: bool_,
}
#[repr(C)]
pub struct io_ring_ctx {
    pub __bindgen_anon_1: io_ring_ctx__bindgen_ty_1,
    pub __bindgen_anon_2: io_ring_ctx__bindgen_ty_2,
    pub locked_free_list: io_wq_work_list,
    pub locked_free_nr: ::aya_bpf::cty::c_uint,
    pub sq_creds: *const cred,
    pub sq_data: *mut io_sq_data,
    pub sqo_sq_wait: wait_queue_head,
    pub sqd_list: list_head,
    pub check_cq: ::aya_bpf::cty::c_ulong,
    pub file_alloc_start: ::aya_bpf::cty::c_uint,
    pub file_alloc_end: ::aya_bpf::cty::c_uint,
    pub personalities: xarray,
    pub pers_next: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub __bindgen_anon_3: io_ring_ctx__bindgen_ty_3,
    pub __bindgen_anon_4: io_ring_ctx__bindgen_ty_4,
    pub __bindgen_anon_5: io_ring_ctx__bindgen_ty_5,
    pub restrictions: io_restriction,
    pub submitter_task: *mut task_struct,
    pub rsrc_backup_node: *mut io_rsrc_node,
    pub dummy_ubuf: *mut io_mapped_ubuf,
    pub file_data: *mut io_rsrc_data,
    pub buf_data: *mut io_rsrc_data,
    pub rsrc_put_work: delayed_work,
    pub rsrc_put_tw: callback_head,
    pub rsrc_put_llist: llist_head,
    pub rsrc_ref_list: list_head,
    pub rsrc_ref_lock: spinlock_t,
    pub io_buffers_pages: list_head,
    pub ring_sock: *mut socket,
    pub hash_map: *mut io_wq_hash,
    pub user: *mut user_struct,
    pub mm_account: *mut mm_struct,
    pub fallback_llist: llist_head,
    pub fallback_work: delayed_work,
    pub exit_work: work_struct,
    pub tctx_list: list_head,
    pub ref_comp: completion,
    pub iowq_limits: [u32_; 2usize],
    pub iowq_limits_set: bool_,
    pub defer_list: list_head,
    pub sq_thread_idle: ::aya_bpf::cty::c_uint,
    pub evfd_last_cq_tail: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_ring_ctx__bindgen_ty_1 {
    pub refs: percpu_ref,
    pub rings: *mut io_rings,
    pub flags: ::aya_bpf::cty::c_uint,
    pub notify_method: task_work_notify_mode::Type,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl io_ring_ctx__bindgen_ty_1 {
    #[inline]
    pub fn compat(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compat(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drain_next(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drain_next(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restricted(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restricted(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn off_timeout_used(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_off_timeout_used(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drain_active(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drain_active(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drain_disabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drain_disabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_evfd(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_evfd(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syscall_iopoll(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_syscall_iopoll(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn task_complete(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_task_complete(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compat: ::aya_bpf::cty::c_uint,
        drain_next: ::aya_bpf::cty::c_uint,
        restricted: ::aya_bpf::cty::c_uint,
        off_timeout_used: ::aya_bpf::cty::c_uint,
        drain_active: ::aya_bpf::cty::c_uint,
        drain_disabled: ::aya_bpf::cty::c_uint,
        has_evfd: ::aya_bpf::cty::c_uint,
        syscall_iopoll: ::aya_bpf::cty::c_uint,
        task_complete: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compat: u32 = unsafe { ::core::mem::transmute(compat) };
            compat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drain_next: u32 = unsafe { ::core::mem::transmute(drain_next) };
            drain_next as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let restricted: u32 = unsafe { ::core::mem::transmute(restricted) };
            restricted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let off_timeout_used: u32 = unsafe { ::core::mem::transmute(off_timeout_used) };
            off_timeout_used as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let drain_active: u32 = unsafe { ::core::mem::transmute(drain_active) };
            drain_active as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let drain_disabled: u32 = unsafe { ::core::mem::transmute(drain_disabled) };
            drain_disabled as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_evfd: u32 = unsafe { ::core::mem::transmute(has_evfd) };
            has_evfd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let syscall_iopoll: u32 = unsafe { ::core::mem::transmute(syscall_iopoll) };
            syscall_iopoll as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let task_complete: u32 = unsafe { ::core::mem::transmute(task_complete) };
            task_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct io_ring_ctx__bindgen_ty_2 {
    pub uring_lock: mutex,
    pub sq_array: *mut u32_,
    pub sq_sqes: *mut io_uring_sqe,
    pub cached_sq_head: ::aya_bpf::cty::c_uint,
    pub sq_entries: ::aya_bpf::cty::c_uint,
    pub rsrc_node: *mut io_rsrc_node,
    pub rsrc_cached_refs: ::aya_bpf::cty::c_int,
    pub cancel_seq: atomic_t,
    pub file_table: io_file_table,
    pub nr_user_files: ::aya_bpf::cty::c_uint,
    pub nr_user_bufs: ::aya_bpf::cty::c_uint,
    pub user_bufs: *mut *mut io_mapped_ubuf,
    pub submit_state: io_submit_state,
    pub io_bl: *mut io_buffer_list,
    pub io_bl_xa: xarray,
    pub io_buffers_cache: list_head,
    pub cancel_table_locked: io_hash_table,
    pub cq_overflow_list: list_head,
    pub apoll_cache: io_alloc_cache,
    pub netmsg_cache: io_alloc_cache,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
impl io_ring_ctx__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_ring_ctx__bindgen_ty_3 {
    pub cqe_cached: *mut io_uring_cqe,
    pub cqe_sentinel: *mut io_uring_cqe,
    pub cached_cq_tail: ::aya_bpf::cty::c_uint,
    pub cq_entries: ::aya_bpf::cty::c_uint,
    pub io_ev_fd: *mut io_ev_fd,
    pub cq_wait: wait_queue_head,
    pub cq_extra: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_ring_ctx__bindgen_ty_4 {
    pub completion_lock: spinlock_t,
    pub poll_multi_queue: bool_,
    pub iopoll_list: io_wq_work_list,
    pub cancel_table: io_hash_table,
    pub work_llist: llist_head,
    pub io_buffers_comp: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_ring_ctx__bindgen_ty_5 {
    pub timeout_lock: spinlock_t,
    pub cq_timeouts: atomic_t,
    pub timeout_list: list_head,
    pub ltimeout_list: list_head,
    pub cq_last_tm_flush: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub __bindgen_padding_0: u32,
}
impl io_ring_ctx__bindgen_ty_5 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
impl io_ring_ctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring {
    pub head: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_0: u32,
    pub tail: u32_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct io_rings {
    pub sq: io_uring,
    pub cq: io_uring,
    pub sq_ring_mask: u32_,
    pub cq_ring_mask: u32_,
    pub sq_ring_entries: u32_,
    pub cq_ring_entries: u32_,
    pub sq_dropped: u32_,
    pub sq_flags: atomic_t,
    pub cq_flags: u32_,
    pub cq_overflow: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
    pub cqes: __IncompleteArrayField<io_uring_cqe>,
}
impl io_rings {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_cmd_data {
    pub file: *mut file,
    pub data: [__u8; 56usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cqe {
    pub user_data: __u64,
    pub res: __s32,
    pub __bindgen_anon_1: io_cqe__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cqe__bindgen_ty_1 {
    pub flags: __u32,
    pub fd: ::aya_bpf::cty::c_int,
}
pub type io_req_tw_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_kiocb, arg2: *mut bool_)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_task_work {
    pub node: llist_node,
    pub func: io_req_tw_func_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_kiocb {
    pub __bindgen_anon_1: io_kiocb__bindgen_ty_1,
    pub opcode: u8_,
    pub iopoll_completed: u8_,
    pub buf_index: u16_,
    pub flags: ::aya_bpf::cty::c_uint,
    pub cqe: io_cqe,
    pub ctx: *mut io_ring_ctx,
    pub task: *mut task_struct,
    pub rsrc_node: *mut io_rsrc_node,
    pub __bindgen_anon_2: io_kiocb__bindgen_ty_2,
    pub __bindgen_anon_3: io_kiocb__bindgen_ty_3,
    pub refs: atomic_t,
    pub poll_refs: atomic_t,
    pub io_task_work: io_task_work,
    pub __bindgen_anon_4: io_kiocb__bindgen_ty_4,
    pub apoll: *mut async_poll,
    pub async_data: *mut ::aya_bpf::cty::c_void,
    pub link: *mut io_kiocb,
    pub creds: *const cred,
    pub work: io_wq_work,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_kiocb__bindgen_ty_1 {
    pub file: *mut file,
    pub cmd: io_cmd_data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_kiocb__bindgen_ty_2 {
    pub imu: *mut io_mapped_ubuf,
    pub kbuf: *mut io_buffer,
    pub buf_list: *mut io_buffer_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_kiocb__bindgen_ty_3 {
    pub comp_list: io_wq_work_node,
    pub apoll_events: __poll_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_kiocb__bindgen_ty_4 {
    pub hash_node: hlist_node,
    pub __bindgen_anon_1: io_kiocb__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_kiocb__bindgen_ty_4__bindgen_ty_1 {
    pub extra1: u64_,
    pub extra2: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_ev_fd {
    pub cq_ev_fd: *mut eventfd_ctx,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub refs: atomic_t,
    pub ops: atomic_t,
}
impl io_ev_fd {
    #[inline]
    pub fn eventfd_async(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eventfd_async(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        eventfd_async: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eventfd_async: u32 = unsafe { ::core::mem::transmute(eventfd_async) };
            eventfd_async as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_wq_hash {
    pub refs: refcount_t,
    pub map: ::aya_bpf::cty::c_ulong,
    pub wait: wait_queue_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_buf {
    pub addr: __u64,
    pub len: __u32,
    pub bid: __u16,
    pub resv: __u16,
}
#[repr(C)]
pub struct io_uring_buf_ring {
    pub __bindgen_anon_1: io_uring_buf_ring__bindgen_ty_1,
}
#[repr(C)]
pub struct io_uring_buf_ring__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<io_uring_buf_ring__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_buf_ring__bindgen_ty_1__bindgen_ty_1 {
    pub resv1: __u64,
    pub resv2: __u32,
    pub resv3: __u16,
    pub tail: __u16,
}
#[repr(C)]
#[derive(Debug)]
pub struct io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_bufs: io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub bufs: __IncompleteArrayField<io_uring_buf>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_rsrc_node {
    pub refs: percpu_ref,
    pub node: list_head,
    pub rsrc_list: list_head,
    pub rsrc_data: *mut io_rsrc_data,
    pub llist: llist_node,
    pub done: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct io_mapped_ubuf {
    pub ubuf: u64_,
    pub ubuf_end: u64_,
    pub nr_bvecs: ::aya_bpf::cty::c_uint,
    pub acct_pages: ::aya_bpf::cty::c_ulong,
    pub bvec: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_buffer_list {
    pub __bindgen_anon_1: io_buffer_list__bindgen_ty_1,
    pub bgid: __u16,
    pub buf_nr_pages: __u16,
    pub nr_entries: __u16,
    pub head: __u16,
    pub mask: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_buffer_list__bindgen_ty_1 {
    pub buf_list: list_head,
    pub __bindgen_anon_1: io_buffer_list__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_buffer_list__bindgen_ty_1__bindgen_ty_1 {
    pub buf_pages: *mut *mut page,
    pub buf_ring: *mut io_uring_buf_ring,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_sq_data {
    pub refs: refcount_t,
    pub park_pending: atomic_t,
    pub lock: mutex,
    pub ctx_list: list_head,
    pub thread: *mut task_struct,
    pub wait: wait_queue_head,
    pub sq_thread_idle: ::aya_bpf::cty::c_uint,
    pub sq_cpu: ::aya_bpf::cty::c_int,
    pub task_pid: pid_t,
    pub task_tgid: pid_t,
    pub state: ::aya_bpf::cty::c_ulong,
    pub exited: completion,
}
pub type rsrc_put_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_ring_ctx, arg2: *mut io_rsrc_put)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_rsrc_data {
    pub ctx: *mut io_ring_ctx,
    pub tags: *mut *mut u64_,
    pub nr: ::aya_bpf::cty::c_uint,
    pub do_put: rsrc_put_fn,
    pub refs: atomic_t,
    pub done: completion,
    pub quiesce: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_buffer {
    pub list: list_head,
    pub addr: __u64,
    pub len: __u32,
    pub bid: __u16,
    pub bgid: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_poll {
    pub file: *mut file,
    pub head: *mut wait_queue_head,
    pub events: __poll_t,
    pub retries: ::aya_bpf::cty::c_int,
    pub wait: wait_queue_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_cache_entry {
    pub node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct async_poll {
    pub __bindgen_anon_1: async_poll__bindgen_ty_1,
    pub double_poll: *mut io_poll,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union async_poll__bindgen_ty_1 {
    pub poll: io_poll,
    pub cache: io_cache_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_rsrc_put {
    pub list: list_head,
    pub tag: u64_,
    pub __bindgen_anon_1: io_rsrc_put__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_rsrc_put__bindgen_ty_1 {
    pub rsrc: *mut ::aya_bpf::cty::c_void,
    pub file: *mut file,
    pub buf: *mut io_mapped_ubuf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim_sample {
    pub time: ktime_t,
    pub pkt_ctr: u32_,
    pub byte_ctr: u32_,
    pub event_ctr: u16_,
    pub comp_ctr: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim_stats {
    pub ppms: ::aya_bpf::cty::c_int,
    pub bpms: ::aya_bpf::cty::c_int,
    pub epms: ::aya_bpf::cty::c_int,
    pub cpms: ::aya_bpf::cty::c_int,
    pub cpe_ratio: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim {
    pub state: u8_,
    pub prev_stats: dim_stats,
    pub start_sample: dim_sample,
    pub measuring_sample: dim_sample,
    pub work: work_struct,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub profile_ix: u8_,
    pub mode: u8_,
    pub tune_state: u8_,
    pub steps_right: u8_,
    pub steps_left: u8_,
    pub tired: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ida {
    pub xa: xarray,
}
pub mod device_link_state {
    pub type Type = ::aya_bpf::cty::c_int;
    pub const DL_STATE_NONE: Type = -1;
    pub const DL_STATE_DORMANT: Type = 0;
    pub const DL_STATE_AVAILABLE: Type = 1;
    pub const DL_STATE_CONSUMER_PROBE: Type = 2;
    pub const DL_STATE_ACTIVE: Type = 3;
    pub const DL_STATE_SUPPLIER_UNBIND: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pin_info {
    pub p: *mut pinctrl,
    pub default_state: *mut pinctrl_state,
    pub init_state: *mut pinctrl_state,
    pub sleep_state: *mut pinctrl_state,
    pub idle_state: *mut pinctrl_state,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_link {
    pub supplier: *mut device,
    pub s_node: list_head,
    pub consumer: *mut device,
    pub c_node: list_head,
    pub link_dev: device,
    pub status: device_link_state::Type,
    pub flags: u32_,
    pub rpm_active: refcount_t,
    pub kref: kref,
    pub rm_work: work_struct,
    pub supplier_preactivated: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl {
    pub node: list_head,
    pub dev: *mut device,
    pub states: list_head,
    pub state: *mut pinctrl_state,
    pub dt_maps: list_head,
    pub users: kref,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pinctrl_state {
    pub node: list_head,
    pub name: *const ::aya_bpf::cty::c_char,
    pub settings: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_irq_chip {
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub domain_ops: *const irq_domain_ops,
    pub fwnode: *mut fwnode_handle,
    pub parent_domain: *mut irq_domain,
    pub child_to_parent_hwirq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut ::aya_bpf::cty::c_uint,
            arg5: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub populate_parent_alloc_arg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: *mut gpio_irq_fwspec,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub child_offset_to_irq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub child_irq_domain_ops: irq_domain_ops,
    pub handler: irq_flow_handler_t,
    pub default_type: ::aya_bpf::cty::c_uint,
    pub lock_key: *mut lock_class_key,
    pub request_key: *mut lock_class_key,
    pub parent_handler: irq_flow_handler_t,
    pub __bindgen_anon_1: gpio_irq_chip__bindgen_ty_1,
    pub num_parents: ::aya_bpf::cty::c_uint,
    pub parents: *mut ::aya_bpf::cty::c_uint,
    pub map: *mut ::aya_bpf::cty::c_uint,
    pub threaded: bool_,
    pub per_parent_data: bool_,
    pub initialized: bool_,
    pub init_hw:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gpio_chip) -> ::aya_bpf::cty::c_int>,
    pub init_valid_mask: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_uint,
        ),
    >,
    pub valid_mask: *mut ::aya_bpf::cty::c_ulong,
    pub first: ::aya_bpf::cty::c_uint,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(arg1: *mut irq_data)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_irq_chip__bindgen_ty_1 {
    pub parent_handler_data: *mut ::aya_bpf::cty::c_void,
    pub parent_handler_data_array: *mut *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_chip {
    pub label: *const ::aya_bpf::cty::c_char,
    pub gpiodev: *mut gpio_device,
    pub parent: *mut device,
    pub fwnode: *mut fwnode_handle,
    pub owner: *mut module,
    pub request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gpio_chip, arg2: ::aya_bpf::cty::c_uint),
    >,
    pub get_direction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub direction_input: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub direction_output: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_multiple: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: *mut ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_int,
        ),
    >,
    pub set_multiple: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: *mut ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub set_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub to_irq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dbg_show:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut gpio_chip)>,
    pub init_valid_mask: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub add_pin_ranges:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut gpio_chip) -> ::aya_bpf::cty::c_int>,
    pub en_hw_timestamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dis_hw_timestamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gpio_chip,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub base: ::aya_bpf::cty::c_int,
    pub ngpio: u16_,
    pub offset: u16_,
    pub names: *const *const ::aya_bpf::cty::c_char,
    pub can_sleep: bool_,
    pub read_reg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> ::aya_bpf::cty::c_ulong,
    >,
    pub write_reg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void, arg2: ::aya_bpf::cty::c_ulong),
    >,
    pub be_bits: bool_,
    pub reg_dat: *mut ::aya_bpf::cty::c_void,
    pub reg_set: *mut ::aya_bpf::cty::c_void,
    pub reg_clr: *mut ::aya_bpf::cty::c_void,
    pub reg_dir_out: *mut ::aya_bpf::cty::c_void,
    pub reg_dir_in: *mut ::aya_bpf::cty::c_void,
    pub bgpio_dir_unreadable: bool_,
    pub bgpio_bits: ::aya_bpf::cty::c_int,
    pub bgpio_lock: raw_spinlock_t,
    pub bgpio_data: ::aya_bpf::cty::c_ulong,
    pub bgpio_dir: ::aya_bpf::cty::c_ulong,
    pub irq: gpio_irq_chip,
    pub valid_mask: *mut ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_irq_fwspec {
    pub fwspec: irq_fwspec,
    pub msiinfo: msi_alloc_info_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_device {
    pub dev: device,
    pub chrdev: cdev,
    pub id: ::aya_bpf::cty::c_int,
    pub mockdev: *mut device,
    pub owner: *mut module,
    pub chip: *mut gpio_chip,
    pub descs: *mut gpio_desc,
    pub base: ::aya_bpf::cty::c_int,
    pub ngpio: u16_,
    pub label: *const ::aya_bpf::cty::c_char,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub list: list_head,
    pub notifier: blocking_notifier_head,
    pub sem: rw_semaphore,
    pub pin_ranges: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_desc {
    pub gdev: *mut gpio_device,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub label: *const ::aya_bpf::cty::c_char,
    pub name: *const ::aya_bpf::cty::c_char,
    pub debounce_period_us: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    pub lock: mutex,
    pub fault_param: *mut iommu_fault_param,
    pub iopf_param: *mut iopf_device_param,
    pub fwspec: *mut iommu_fwspec,
    pub iommu_dev: *mut iommu_device,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub max_pasids: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl dev_iommu {
    #[inline]
    pub fn attach_deferred(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_attach_deferred(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(attach_deferred: u32_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let attach_deferred: u32 = unsafe { ::core::mem::transmute(attach_deferred) };
            attach_deferred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct of_phandle_args {
    pub np: *mut device_node,
    pub args_count: ::aya_bpf::cty::c_int,
    pub args: [u32; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fault_unrecoverable {
    pub reason: __u32,
    pub flags: __u32,
    pub pasid: __u32,
    pub perm: __u32,
    pub addr: __u64,
    pub fetch_addr: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_fault_page_request {
    pub flags: __u32,
    pub pasid: __u32,
    pub grpid: __u32,
    pub perm: __u32,
    pub addr: __u64,
    pub private_data: [__u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault {
    pub type_: __u32,
    pub padding: __u32,
    pub __bindgen_anon_1: iommu_fault__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_fault__bindgen_ty_1 {
    pub event: iommu_fault_unrecoverable,
    pub prm: iommu_fault_page_request,
    pub padding2: [__u8; 56usize],
}
pub mod iommu_page_response_code {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IOMMU_PAGE_RESP_SUCCESS: Type = 0;
    pub const IOMMU_PAGE_RESP_INVALID: Type = 1;
    pub const IOMMU_PAGE_RESP_FAILURE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_page_response {
    pub argsz: __u32,
    pub version: __u32,
    pub flags: __u32,
    pub pasid: __u32,
    pub grpid: __u32,
    pub code: __u32,
}
pub type iommu_fault_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut iommu_domain,
        arg2: *mut device,
        arg3: ::aya_bpf::cty::c_ulong,
        arg4: ::aya_bpf::cty::c_int,
        arg5: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain_geometry {
    pub aperture_start: dma_addr_t,
    pub aperture_end: dma_addr_t,
    pub force_aperture: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_domain {
    pub type_: ::aya_bpf::cty::c_uint,
    pub ops: *const iommu_domain_ops,
    pub pgsize_bitmap: ::aya_bpf::cty::c_ulong,
    pub geometry: iommu_domain_geometry,
    pub iova_cookie: *mut iommu_dma_cookie,
    pub iopf_handler: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_fault,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> iommu_page_response_code::Type,
    >,
    pub fault_data: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: iommu_domain__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_domain__bindgen_ty_1 {
    pub __bindgen_anon_1: iommu_domain__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: iommu_domain__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain__bindgen_ty_1__bindgen_ty_1 {
    pub handler: iommu_fault_handler_t,
    pub handler_token: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain__bindgen_ty_1__bindgen_ty_2 {
    pub mm: *mut mm_struct,
    pub users: ::aya_bpf::cty::c_int,
}
pub type iommu_dev_fault_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut iommu_fault,
        arg2: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_domain_ops {
    pub attach_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device) -> ::aya_bpf::cty::c_int,
    >,
    pub detach_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut device)>,
    pub set_dev_pasid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: *mut device,
            arg3: ioasid_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: phys_addr_t,
            arg4: usize,
            arg5: ::aya_bpf::cty::c_int,
            arg6: gfp_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: phys_addr_t,
            arg4: usize,
            arg5: usize,
            arg6: ::aya_bpf::cty::c_int,
            arg7: gfp_t,
            arg8: *mut usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: usize,
            arg4: *mut iommu_iotlb_gather,
        ) -> usize,
    >,
    pub unmap_pages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: usize,
            arg4: usize,
            arg5: *mut iommu_iotlb_gather,
        ) -> usize,
    >,
    pub flush_iotlb_all: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>,
    pub iotlb_sync_map: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: ::aya_bpf::cty::c_ulong, arg3: usize),
    >,
    pub iotlb_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: *mut iommu_iotlb_gather),
    >,
    pub iova_to_phys: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain, arg2: dma_addr_t) -> phys_addr_t,
    >,
    pub enforce_cache_coherency:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain) -> bool_>,
    pub enable_nesting: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut iommu_domain) -> ::aya_bpf::cty::c_int,
    >,
    pub set_pgtable_quirks: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iommu_domain,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut iommu_domain)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_iotlb_gather {
    pub start: ::aya_bpf::cty::c_ulong,
    pub end: ::aya_bpf::cty::c_ulong,
    pub pgsize: usize,
    pub freelist: list_head,
    pub queued: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_device {
    pub list: list_head,
    pub ops: *const iommu_ops,
    pub fwnode: *mut fwnode_handle,
    pub dev: *mut device,
    pub max_pasids: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault_event {
    pub fault: iommu_fault,
    pub list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_fault_param {
    pub handler: iommu_dev_fault_handler_t,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub faults: list_head,
    pub lock: mutex,
}
#[repr(C)]
#[derive(Debug)]
pub struct iommu_fwspec {
    pub ops: *const iommu_ops,
    pub iommu_fwnode: *mut fwnode_handle,
    pub flags: u32_,
    pub num_ids: ::aya_bpf::cty::c_uint,
    pub ids: __IncompleteArrayField<u32_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist {
    pub k_lock: spinlock_t,
    pub k_list: list_head,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut ::aya_bpf::cty::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
pub type u_char = ::aya_bpf::cty::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_domain_data {
    pub list_node: list_head,
    pub dev: *mut device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reset_control {
    pub rcdev: *mut reset_controller_dev,
    pub list: list_head,
    pub id: ::aya_bpf::cty::c_uint,
    pub refcnt: kref,
    pub acquired: bool_,
    pub shared: bool_,
    pub array: bool_,
    pub deassert_count: atomic_t,
    pub triggered_count: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reset_control_ops {
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut reset_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub assert: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut reset_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub deassert: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut reset_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut reset_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reset_controller_dev {
    pub ops: *const reset_control_ops,
    pub owner: *mut module,
    pub list: list_head,
    pub reset_control_head: list_head,
    pub dev: *mut device,
    pub of_node: *mut device_node,
    pub of_reset_n_cells: ::aya_bpf::cty::c_int,
    pub of_xlate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut reset_controller_dev,
            arg2: *const of_phandle_args,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub nr_resets: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tty_audit_buf {
    pub mutex: mutex,
    pub dev: dev_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub valid: usize,
    pub data: *mut ::aya_bpf::cty::c_uchar,
}
impl tty_audit_buf {
    #[inline]
    pub fn icanon(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_icanon(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(icanon: ::aya_bpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let icanon: u32 = unsafe { ::core::mem::transmute(icanon) };
            icanon as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iova {
    pub node: rb_node,
    pub pfn_hi: ::aya_bpf::cty::c_ulong,
    pub pfn_lo: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iova_domain {
    pub iova_rbtree_lock: spinlock_t,
    pub rbroot: rb_root,
    pub cached_node: *mut rb_node,
    pub cached32_node: *mut rb_node,
    pub granule: ::aya_bpf::cty::c_ulong,
    pub start_pfn: ::aya_bpf::cty::c_ulong,
    pub dma_32bit_pfn: ::aya_bpf::cty::c_ulong,
    pub max32_alloc_size: ::aya_bpf::cty::c_ulong,
    pub anchor: iova,
    pub rcaches: *mut iova_rcache,
    pub cpuhp_dead: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iova_rcache {
    pub lock: spinlock_t,
    pub depot_size: ::aya_bpf::cty::c_ulong,
    pub depot: [*mut iova_magazine; 32usize],
    pub cpu_rcaches: *mut iova_cpu_rcache,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iova_magazine {
    pub size: ::aya_bpf::cty::c_ulong,
    pub pfns: [::aya_bpf::cty::c_ulong; 127usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iova_cpu_rcache {
    pub lock: spinlock_t,
    pub loaded: *mut iova_magazine,
    pub prev: *mut iova_magazine,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ww_acquire_ctx {
    pub task: *mut task_struct,
    pub stamp: ::aya_bpf::cty::c_ulong,
    pub acquired: ::aya_bpf::cty::c_uint,
    pub wounded: ::aya_bpf::cty::c_ushort,
    pub is_wait_die: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex_base {
    pub wait_lock: raw_spinlock_t,
    pub waiters: rb_root_cached,
    pub owner: *mut task_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_mutex {
    pub rtmutex: rt_mutex_base,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_private {
    pub subsys: kset,
    pub devices_kset: *mut kset,
    pub interfaces: list_head,
    pub mutex: mutex,
    pub drivers_kset: *mut kset,
    pub klist_devices: klist,
    pub klist_drivers: klist,
    pub bus_notifier: blocking_notifier_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bus: *mut bus_type,
    pub glue_dirs: kset,
    pub class: *mut class,
}
impl subsys_private {
    #[inline]
    pub fn drivers_autoprobe(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_drivers_autoprobe(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drivers_autoprobe: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drivers_autoprobe: u32 = unsafe { ::core::mem::transmute(drivers_autoprobe) };
            drivers_autoprobe as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    pub kobj: kobject,
    pub klist_devices: klist,
    pub knode_bus: klist_node,
    pub mkobj: *mut module_kobject,
    pub driver: *mut device_driver,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    pub klist_children: klist,
    pub knode_parent: klist_node,
    pub knode_driver: klist_node,
    pub knode_bus: klist_node,
    pub knode_class: klist_node,
    pub deferred_probe: list_head,
    pub async_driver: *mut device_driver,
    pub deferred_probe_reason: *mut ::aya_bpf::cty::c_char,
    pub device: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl device_private {
    #[inline]
    pub fn dead(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dead(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dead: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dead: u8 = unsafe { ::core::mem::transmute(dead) };
            dead as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod phy_interface_t {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PHY_INTERFACE_MODE_NA: Type = 0;
    pub const PHY_INTERFACE_MODE_INTERNAL: Type = 1;
    pub const PHY_INTERFACE_MODE_MII: Type = 2;
    pub const PHY_INTERFACE_MODE_GMII: Type = 3;
    pub const PHY_INTERFACE_MODE_SGMII: Type = 4;
    pub const PHY_INTERFACE_MODE_TBI: Type = 5;
    pub const PHY_INTERFACE_MODE_REVMII: Type = 6;
    pub const PHY_INTERFACE_MODE_RMII: Type = 7;
    pub const PHY_INTERFACE_MODE_REVRMII: Type = 8;
    pub const PHY_INTERFACE_MODE_RGMII: Type = 9;
    pub const PHY_INTERFACE_MODE_RGMII_ID: Type = 10;
    pub const PHY_INTERFACE_MODE_RGMII_RXID: Type = 11;
    pub const PHY_INTERFACE_MODE_RGMII_TXID: Type = 12;
    pub const PHY_INTERFACE_MODE_RTBI: Type = 13;
    pub const PHY_INTERFACE_MODE_SMII: Type = 14;
    pub const PHY_INTERFACE_MODE_XGMII: Type = 15;
    pub const PHY_INTERFACE_MODE_XLGMII: Type = 16;
    pub const PHY_INTERFACE_MODE_MOCA: Type = 17;
    pub const PHY_INTERFACE_MODE_QSGMII: Type = 18;
    pub const PHY_INTERFACE_MODE_TRGMII: Type = 19;
    pub const PHY_INTERFACE_MODE_100BASEX: Type = 20;
    pub const PHY_INTERFACE_MODE_1000BASEX: Type = 21;
    pub const PHY_INTERFACE_MODE_2500BASEX: Type = 22;
    pub const PHY_INTERFACE_MODE_5GBASER: Type = 23;
    pub const PHY_INTERFACE_MODE_RXAUI: Type = 24;
    pub const PHY_INTERFACE_MODE_XAUI: Type = 25;
    pub const PHY_INTERFACE_MODE_10GBASER: Type = 26;
    pub const PHY_INTERFACE_MODE_25GBASER: Type = 27;
    pub const PHY_INTERFACE_MODE_USXGMII: Type = 28;
    pub const PHY_INTERFACE_MODE_10GKR: Type = 29;
    pub const PHY_INTERFACE_MODE_QUSGMII: Type = 30;
    pub const PHY_INTERFACE_MODE_1000BASEKX: Type = 31;
    pub const PHY_INTERFACE_MODE_MAX: Type = 32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    pub dev: *mut device,
    pub status: ::aya_bpf::cty::c_uint,
    pub irq: ::aya_bpf::cty::c_int,
    pub name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dax_operations {
    pub direct_access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dax_device,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_long,
            arg4: dax_access_mode::Type,
            arg5: *mut *mut ::aya_bpf::cty::c_void,
            arg6: *mut pfn_t,
        ) -> ::aya_bpf::cty::c_long,
    >,
    pub dax_supported: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dax_device,
            arg2: *mut block_device,
            arg3: ::aya_bpf::cty::c_int,
            arg4: sector_t,
            arg5: sector_t,
        ) -> bool_,
    >,
    pub zero_page_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dax_device,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub recovery_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dax_device,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: usize,
            arg5: *mut iov_iter,
        ) -> usize,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scsi_sense_hdr {
    pub response_code: u8_,
    pub sense_key: u8_,
    pub asc: u8_,
    pub ascq: u8_,
    pub byte4: u8_,
    pub byte5: u8_,
    pub byte6: u8_,
    pub additional_length: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_device_info {
    pub ops: *const cdrom_device_ops,
    pub list: list_head,
    pub disk: *mut gendisk,
    pub handle: *mut ::aya_bpf::cty::c_void,
    pub mask: ::aya_bpf::cty::c_int,
    pub speed: ::aya_bpf::cty::c_int,
    pub capacity: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub vfs_events: ::aya_bpf::cty::c_uint,
    pub ioctl_events: ::aya_bpf::cty::c_uint,
    pub use_count: ::aya_bpf::cty::c_int,
    pub name: [::aya_bpf::cty::c_char; 20usize],
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cdda_method: ::aya_bpf::cty::c_int,
    pub last_sense: __u8,
    pub media_written: __u8,
    pub mmc3_profile: ::aya_bpf::cty::c_ushort,
    pub for_data: ::aya_bpf::cty::c_int,
    pub exit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf::cty::c_int,
    >,
    pub mrw_mode_page: ::aya_bpf::cty::c_int,
    pub last_media_change_ms: __s64,
}
impl cdrom_device_info {
    #[inline]
    pub fn options(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_options(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_flags(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_mc_flags(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        options: ::aya_bpf::cty::c_uint,
        mc_flags: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let options: u32 = unsafe { ::core::mem::transmute(options) };
            options as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let mc_flags: u32 = unsafe { ::core::mem::transmute(mc_flags) };
            mc_flags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sanyo_slot(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sanyo_slot(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn keeplocked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keeplocked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sanyo_slot: __u8,
        keeplocked: __u8,
        reserved: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sanyo_slot: u8 = unsafe { ::core::mem::transmute(sanyo_slot) };
            sanyo_slot as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let keeplocked: u8 = unsafe { ::core::mem::transmute(keeplocked) };
            keeplocked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hd_geometry {
    pub heads: ::aya_bpf::cty::c_uchar,
    pub sectors: ::aya_bpf::cty::c_uchar,
    pub cylinders: ::aya_bpf::cty::c_ushort,
    pub start: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_msf0 {
    pub minute: __u8,
    pub second: __u8,
    pub frame: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cdrom_addr {
    pub msf: cdrom_msf0,
    pub lba: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cdrom_multisession {
    pub addr: cdrom_addr,
    pub xa_flag: __u8,
    pub addr_format: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_mcn {
    pub medium_catalog_number: [__u8; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct packet_command {
    pub cmd: [::aya_bpf::cty::c_uchar; 12usize],
    pub buffer: *mut ::aya_bpf::cty::c_uchar,
    pub buflen: ::aya_bpf::cty::c_uint,
    pub stat: ::aya_bpf::cty::c_int,
    pub sshdr: *mut scsi_sense_hdr,
    pub data_direction: ::aya_bpf::cty::c_uchar,
    pub quiet: ::aya_bpf::cty::c_int,
    pub timeout: ::aya_bpf::cty::c_int,
    pub reserved: [*mut ::aya_bpf::cty::c_void; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdrom_device_ops {
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cdrom_device_info)>,
    pub drive_status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub check_events: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub tray_move: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lock_door: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub select_speed: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_last_session: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut cdrom_multisession,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_mcn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut cdrom_mcn,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cdrom_device_info) -> ::aya_bpf::cty::c_int,
    >,
    pub audio_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub generic_packet: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut packet_command,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_cdda_bpc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cdrom_device_info,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
            arg4: u32_,
            arg5: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub capability: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mdio_device {
    pub dev: device,
    pub bus: *mut mii_bus,
    pub modalias: [::aya_bpf::cty::c_char; 32usize],
    pub bus_match: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut device_driver) -> ::aya_bpf::cty::c_int,
    >,
    pub device_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>,
    pub device_remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mdio_device)>,
    pub addr: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub reset_gpio: *mut gpio_desc,
    pub reset_ctrl: *mut reset_control,
    pub reset_assert_delay: ::aya_bpf::cty::c_uint,
    pub reset_deassert_delay: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdio_bus_stats {
    pub transfers: u64_stats_t,
    pub errors: u64_stats_t,
    pub writes: u64_stats_t,
    pub reads: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mii_bus {
    pub owner: *mut module,
    pub name: *const ::aya_bpf::cty::c_char,
    pub id: [::aya_bpf::cty::c_char; 61usize],
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_bus,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_bus,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reset:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mii_bus) -> ::aya_bpf::cty::c_int>,
    pub stats: [mdio_bus_stats; 32usize],
    pub mdio_lock: mutex,
    pub parent: *mut device,
    pub state: mii_bus__bindgen_ty_1::Type,
    pub dev: device,
    pub mdio_map: [*mut mdio_device; 32usize],
    pub phy_mask: u32_,
    pub phy_ignore_ta_mask: u32_,
    pub irq: [::aya_bpf::cty::c_int; 32usize],
    pub reset_delay_us: ::aya_bpf::cty::c_int,
    pub reset_post_delay_us: ::aya_bpf::cty::c_int,
    pub reset_gpiod: *mut gpio_desc,
    pub probe_capabilities: mii_bus__bindgen_ty_2::Type,
    pub shared_lock: mutex,
    pub shared: [*mut phy_package_shared; 32usize],
}
pub mod mii_bus__bindgen_ty_1 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MDIOBUS_ALLOCATED: Type = 1;
    pub const MDIOBUS_REGISTERED: Type = 2;
    pub const MDIOBUS_UNREGISTERED: Type = 3;
    pub const MDIOBUS_RELEASED: Type = 4;
}
pub mod mii_bus__bindgen_ty_2 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MDIOBUS_NO_CAP: Type = 0;
    pub const MDIOBUS_C22: Type = 1;
    pub const MDIOBUS_C45: Type = 2;
    pub const MDIOBUS_C22_C45: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_package_shared {
    pub addr: ::aya_bpf::cty::c_int,
    pub refcnt: refcount_t,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub priv_size: usize,
    pub priv_: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuidle_state_kobj {
    pub state: *mut cpuidle_state,
    pub state_usage: *mut cpuidle_state_usage,
    pub kobj_unregister: completion,
    pub kobj: kobject,
    pub device: *mut cpuidle_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuidle_device_kobj {
    pub dev: *mut cpuidle_device,
    pub kobj_unregister: completion,
    pub kobj: kobject,
}
pub type nf_hookfn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf::cty::c_void,
        arg2: *mut sk_buff,
        arg3: *const nf_hook_state,
    ) -> ::aya_bpf::cty::c_uint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_entry {
    pub hook: nf_hookfn,
    pub priv_: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug)]
pub struct nf_hook_entries {
    pub num_hook_entries: u16_,
    pub hooks: __IncompleteArrayField<nf_hook_entry>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libipw_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_public_data {
    pub spy_data: *mut iw_spy_data,
    pub libipw: *mut libipw_device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_param {
    pub value: __s32,
    pub fixed: __u8,
    pub disabled: __u8,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_point {
    pub pointer: *mut ::aya_bpf::cty::c_void,
    pub length: __u16,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_freq {
    pub m: __s32,
    pub e: __s16,
    pub i: __u8,
    pub flags: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_quality {
    pub qual: __u8,
    pub level: __u8,
    pub noise: __u8,
    pub updated: __u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_discarded {
    pub nwid: __u32,
    pub code: __u32,
    pub fragment: __u32,
    pub retries: __u32,
    pub misc: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_missed {
    pub beacon: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_statistics {
    pub status: __u16,
    pub qual: iw_quality,
    pub discard: iw_discarded,
    pub miss: iw_missed,
}
#[repr(C)]
pub struct iwreq_data {
    pub name: __BindgenUnionField<[::aya_bpf::cty::c_char; 16usize]>,
    pub essid: __BindgenUnionField<iw_point>,
    pub nwid: __BindgenUnionField<iw_param>,
    pub freq: __BindgenUnionField<iw_freq>,
    pub sens: __BindgenUnionField<iw_param>,
    pub bitrate: __BindgenUnionField<iw_param>,
    pub txpower: __BindgenUnionField<iw_param>,
    pub rts: __BindgenUnionField<iw_param>,
    pub frag: __BindgenUnionField<iw_param>,
    pub mode: __BindgenUnionField<__u32>,
    pub retry: __BindgenUnionField<iw_param>,
    pub encoding: __BindgenUnionField<iw_point>,
    pub power: __BindgenUnionField<iw_param>,
    pub qual: __BindgenUnionField<iw_quality>,
    pub ap_addr: __BindgenUnionField<sockaddr>,
    pub addr: __BindgenUnionField<sockaddr>,
    pub param: __BindgenUnionField<iw_param>,
    pub data: __BindgenUnionField<iw_point>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_priv_args {
    pub cmd: __u32,
    pub set_args: __u16,
    pub get_args: __u16,
    pub name: [::aya_bpf::cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_request_info {
    pub cmd: __u16,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_spy_data {
    pub spy_number: ::aya_bpf::cty::c_int,
    pub spy_address: [u_char; 48usize],
    pub spy_stat: [iw_quality; 8usize],
    pub spy_thr_low: iw_quality,
    pub spy_thr_high: iw_quality,
    pub spy_thr_under: [u_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_hook_state {
    pub hook: u8_,
    pub pf: u8_,
    pub in_: *mut net_device,
    pub out: *mut net_device,
    pub sk: *mut sock,
    pub net: *mut net,
    pub okfn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
pub type __sum16 = __u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_dissector {
    pub used_keys: ::aya_bpf::cty::c_uint,
    pub offset: [::aya_bpf::cty::c_ushort; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv4_devconf {
    pub sysctl: *mut ::aya_bpf::cty::c_void,
    pub data: [::aya_bpf::cty::c_int; 33usize],
    pub state: [::aya_bpf::cty::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt6key {
    pub addr: in6_addr,
    pub plen: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh_common {
    pub nhc_dev: *mut net_device,
    pub nhc_dev_tracker: netdevice_tracker,
    pub nhc_oif: ::aya_bpf::cty::c_int,
    pub nhc_scope: ::aya_bpf::cty::c_uchar,
    pub nhc_family: u8_,
    pub nhc_gw_family: u8_,
    pub nhc_flags: ::aya_bpf::cty::c_uchar,
    pub nhc_lwtstate: *mut lwtunnel_state,
    pub nhc_gw: fib_nh_common__bindgen_ty_1,
    pub nhc_weight: ::aya_bpf::cty::c_int,
    pub nhc_upper_bound: atomic_t,
    pub nhc_pcpu_rth_output: *mut *mut rtable,
    pub nhc_rth_input: *mut rtable,
    pub nhc_exceptions: *mut fnhe_hash_bucket,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib_nh_common__bindgen_ty_1 {
    pub ipv4: __be32,
    pub ipv6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_nh {
    pub nh_common: fib_nh_common,
    pub last_probe: ::aya_bpf::cty::c_ulong,
    pub rt6i_pcpu: *mut *mut rt6_info,
    pub rt6i_exception_bucket: *mut rt6_exception_bucket,
}
#[repr(C)]
pub struct fib6_info {
    pub fib6_table: *mut fib6_table,
    pub fib6_next: *mut fib6_info,
    pub fib6_node: *mut fib6_node,
    pub __bindgen_anon_1: fib6_info__bindgen_ty_1,
    pub fib6_nsiblings: ::aya_bpf::cty::c_uint,
    pub fib6_ref: refcount_t,
    pub expires: ::aya_bpf::cty::c_ulong,
    pub fib6_metrics: *mut dst_metrics,
    pub fib6_dst: rt6key,
    pub fib6_flags: u32_,
    pub fib6_src: rt6key,
    pub fib6_prefsrc: rt6key,
    pub fib6_metric: u32_,
    pub fib6_protocol: u8_,
    pub fib6_type: u8_,
    pub offload: u8_,
    pub trap: u8_,
    pub offload_failed: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub nh: *mut nexthop,
    pub fib6_nh: __IncompleteArrayField<fib6_nh>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib6_info__bindgen_ty_1 {
    pub fib6_siblings: list_head,
    pub nh_list: list_head,
}
impl fib6_info {
    #[inline]
    pub fn should_flush(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_should_flush(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_nocount(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_nocount(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_nopolicy(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_nopolicy(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fib6_destroying(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fib6_destroying(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        should_flush: u8_,
        dst_nocount: u8_,
        dst_nopolicy: u8_,
        fib6_destroying: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let should_flush: u8 = unsafe { ::core::mem::transmute(should_flush) };
            should_flush as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dst_nocount: u8 = unsafe { ::core::mem::transmute(dst_nocount) };
            dst_nocount as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dst_nopolicy: u8 = unsafe { ::core::mem::transmute(dst_nopolicy) };
            dst_nopolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fib6_destroying: u8 = unsafe { ::core::mem::transmute(fib6_destroying) };
            fib6_destroying as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt6_info {
    pub dst: dst_entry,
    pub from: *mut fib6_info,
    pub sernum: ::aya_bpf::cty::c_int,
    pub rt6i_dst: rt6key,
    pub rt6i_src: rt6key,
    pub rt6i_gateway: in6_addr,
    pub rt6i_idev: *mut inet6_dev,
    pub rt6i_flags: u32_,
    pub rt6i_uncached: list_head,
    pub rt6i_uncached_list: *mut uncached_list,
    pub rt6i_nfheader_len: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt6_statistics {
    pub fib_nodes: __u32,
    pub fib_route_nodes: __u32,
    pub fib_rt_entries: __u32,
    pub fib_rt_cache: __u32,
    pub fib_discarded_routes: __u32,
    pub fib_rt_alloc: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib6_node {
    pub parent: *mut fib6_node,
    pub left: *mut fib6_node,
    pub right: *mut fib6_node,
    pub subtree: *mut fib6_node,
    pub leaf: *mut fib6_info,
    pub fn_bit: __u16,
    pub fn_flags: __u16,
    pub fn_sernum: ::aya_bpf::cty::c_int,
    pub rr_ptr: *mut fib6_info,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_table {
    pub tb6_hlist: hlist_node,
    pub tb6_id: u32_,
    pub tb6_lock: spinlock_t,
    pub tb6_root: fib6_node,
    pub tb6_peers: inet_peer_base,
    pub flags: ::aya_bpf::cty::c_uint,
    pub fib_seq: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xfrm_address_t {
    pub a4: __be32,
    pub a6: [__be32; 4usize],
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_id {
    pub daddr: xfrm_address_t,
    pub spi: __be32,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_sec_ctx {
    pub ctx_doi: __u8,
    pub ctx_alg: __u8,
    pub ctx_len: __u16,
    pub ctx_sid: __u32,
    pub ctx_str: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_selector {
    pub daddr: xfrm_address_t,
    pub saddr: xfrm_address_t,
    pub dport: __be16,
    pub dport_mask: __be16,
    pub sport: __be16,
    pub sport_mask: __be16,
    pub family: __u16,
    pub prefixlen_d: __u8,
    pub prefixlen_s: __u8,
    pub proto: __u8,
    pub ifindex: ::aya_bpf::cty::c_int,
    pub user: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_lifetime_cfg {
    pub soft_byte_limit: __u64,
    pub hard_byte_limit: __u64,
    pub soft_packet_limit: __u64,
    pub hard_packet_limit: __u64,
    pub soft_add_expires_seconds: __u64,
    pub hard_add_expires_seconds: __u64,
    pub soft_use_expires_seconds: __u64,
    pub hard_use_expires_seconds: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_lifetime_cur {
    pub bytes: __u64,
    pub packets: __u64,
    pub add_time: __u64,
    pub use_time: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_replay_state {
    pub oseq: __u32,
    pub seq: __u32,
    pub bitmap: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_replay_state_esn {
    pub bmp_len: ::aya_bpf::cty::c_uint,
    pub oseq: __u32,
    pub seq: __u32,
    pub oseq_hi: __u32,
    pub seq_hi: __u32,
    pub replay_window: __u32,
    pub bmp: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_algo {
    pub alg_name: [::aya_bpf::cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf::cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_algo_auth {
    pub alg_name: [::aya_bpf::cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf::cty::c_uint,
    pub alg_trunc_len: ::aya_bpf::cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xfrm_algo_aead {
    pub alg_name: [::aya_bpf::cty::c_char; 64usize],
    pub alg_key_len: ::aya_bpf::cty::c_uint,
    pub alg_icv_len: ::aya_bpf::cty::c_uint,
    pub alg_key: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_stats {
    pub replay_window: __u32,
    pub replay: __u32,
    pub integrity_failed: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_encap_tmpl {
    pub encap_type: __u16,
    pub encap_sport: __be16,
    pub encap_dport: __be16,
    pub encap_oa: xfrm_address_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_mark {
    pub v: __u32,
    pub m: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_address_filter {
    pub saddr: xfrm_address_t,
    pub daddr: xfrm_address_t,
    pub family: __u16,
    pub splen: __u8,
    pub dplen: __u8,
}
#[repr(C)]
pub struct net_generic {
    pub __bindgen_anon_1: net_generic__bindgen_ty_1,
}
#[repr(C)]
pub struct net_generic__bindgen_ty_1 {
    pub s: __BindgenUnionField<net_generic__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_1: __BindgenUnionField<net_generic__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_generic__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::aya_bpf::cty::c_uint,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug)]
pub struct net_generic__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_ptr: net_generic__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub ptr: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_generic__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
pub mod macsec_validation_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MACSEC_VALIDATE_DISABLED: Type = 0;
    pub const MACSEC_VALIDATE_CHECK: Type = 1;
    pub const MACSEC_VALIDATE_STRICT: Type = 2;
    pub const __MACSEC_VALIDATE_END: Type = 3;
    pub const MACSEC_VALIDATE_MAX: Type = 2;
}
pub mod macsec_offload {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const MACSEC_OFFLOAD_OFF: Type = 0;
    pub const MACSEC_OFFLOAD_PHY: Type = 1;
    pub const MACSEC_OFFLOAD_MAC: Type = 2;
    pub const __MACSEC_OFFLOAD_END: Type = 3;
    pub const MACSEC_OFFLOAD_MAX: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_xdp_link {
    pub link: bpf_link,
    pub dev: *mut net_device,
    pub flags: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_state_walk {
    pub all: list_head,
    pub state: u8_,
    pub dying: u8_,
    pub proto: u8_,
    pub seq: u32_,
    pub filter: *mut xfrm_address_filter,
}
pub mod xfrm_replay_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const XFRM_REPLAY_MODE_LEGACY: Type = 0;
    pub const XFRM_REPLAY_MODE_BMP: Type = 1;
    pub const XFRM_REPLAY_MODE_ESN: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_dev_offload {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub real_dev: *mut net_device,
    pub offload_handle: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl xfrm_dev_offload {
    #[inline]
    pub fn dir(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dir: u8_, type_: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dir: u8 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_mode {
    pub encap: u8_,
    pub family: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state {
    pub xs_net: possible_net_t,
    pub __bindgen_anon_1: xfrm_state__bindgen_ty_1,
    pub bysrc: hlist_node,
    pub byspi: hlist_node,
    pub byseq: hlist_node,
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub id: xfrm_id,
    pub sel: xfrm_selector,
    pub mark: xfrm_mark,
    pub if_id: u32_,
    pub tfcpad: u32_,
    pub genid: u32_,
    pub km: xfrm_state_walk,
    pub props: xfrm_state__bindgen_ty_2,
    pub lft: xfrm_lifetime_cfg,
    pub aalg: *mut xfrm_algo_auth,
    pub ealg: *mut xfrm_algo,
    pub calg: *mut xfrm_algo,
    pub aead: *mut xfrm_algo_aead,
    pub geniv: *const ::aya_bpf::cty::c_char,
    pub new_mapping_sport: __be16,
    pub new_mapping: u32_,
    pub mapping_maxage: u32_,
    pub encap: *mut xfrm_encap_tmpl,
    pub encap_sk: *mut sock,
    pub coaddr: *mut xfrm_address_t,
    pub tunnel: *mut xfrm_state,
    pub tunnel_users: atomic_t,
    pub replay: xfrm_replay_state,
    pub replay_esn: *mut xfrm_replay_state_esn,
    pub preplay: xfrm_replay_state,
    pub preplay_esn: *mut xfrm_replay_state_esn,
    pub repl_mode: xfrm_replay_mode::Type,
    pub xflags: u32_,
    pub replay_maxage: u32_,
    pub replay_maxdiff: u32_,
    pub rtimer: timer_list,
    pub stats: xfrm_stats,
    pub curlft: xfrm_lifetime_cur,
    pub mtimer: hrtimer,
    pub xso: xfrm_dev_offload,
    pub saved_tmo: ::aya_bpf::cty::c_long,
    pub lastused: time64_t,
    pub xfrag: page_frag,
    pub type_: *const xfrm_type,
    pub inner_mode: xfrm_mode,
    pub inner_mode_iaf: xfrm_mode,
    pub outer_mode: xfrm_mode,
    pub type_offload: *const xfrm_type_offload,
    pub security: *mut xfrm_sec_ctx,
    pub data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xfrm_state__bindgen_ty_1 {
    pub gclist: hlist_node,
    pub bydst: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state__bindgen_ty_2 {
    pub reqid: u32_,
    pub mode: u8_,
    pub replay_window: u8_,
    pub aalgo: u8_,
    pub ealgo: u8_,
    pub calgo: u8_,
    pub flags: u8_,
    pub family: u16_,
    pub saddr: xfrm_address_t,
    pub header_len: ::aya_bpf::cty::c_int,
    pub trailer_len: ::aya_bpf::cty::c_int,
    pub extra_flags: u32_,
    pub smark: xfrm_mark,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_policy_walk_entry {
    pub all: list_head,
    pub dead: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_queue {
    pub hold_queue: sk_buff_head,
    pub hold_timer: timer_list,
    pub timeout: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_tmpl {
    pub id: xfrm_id,
    pub saddr: xfrm_address_t,
    pub encap_family: ::aya_bpf::cty::c_ushort,
    pub reqid: u32_,
    pub mode: u8_,
    pub share: u8_,
    pub optional: u8_,
    pub allalgs: u8_,
    pub aalgos: u32_,
    pub ealgos: u32_,
    pub calgos: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy {
    pub xp_net: possible_net_t,
    pub bydst: hlist_node,
    pub byidx: hlist_node,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub pos: u32_,
    pub timer: timer_list,
    pub genid: atomic_t,
    pub priority: u32_,
    pub index: u32_,
    pub if_id: u32_,
    pub mark: xfrm_mark,
    pub selector: xfrm_selector,
    pub lft: xfrm_lifetime_cfg,
    pub curlft: xfrm_lifetime_cur,
    pub walk: xfrm_policy_walk_entry,
    pub polq: xfrm_policy_queue,
    pub bydst_reinsert: bool_,
    pub type_: u8_,
    pub action: u8_,
    pub flags: u8_,
    pub xfrm_nr: u8_,
    pub family: u16_,
    pub security: *mut xfrm_sec_ctx,
    pub xfrm_vec: [xfrm_tmpl; 6usize],
    pub bydst_inexact_list: hlist_node,
    pub rcu: callback_head,
    pub xdo: xfrm_dev_offload,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll_info {
    pub refcnt: refcount_t,
    pub dev_lock: semaphore,
    pub txq: sk_buff_head,
    pub tx_work: delayed_work,
    pub netpoll: *mut netpoll,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iphdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tos: __u8,
    pub tot_len: __be16,
    pub id: __be16,
    pub frag_off: __be16,
    pub ttl: __u8,
    pub protocol: __u8,
    pub check: __sum16,
    pub __bindgen_anon_1: iphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: iphdr__bindgen_ty_1__bindgen_ty_1,
    pub addrs: iphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr__bindgen_ty_1__bindgen_ty_1 {
    pub saddr: __be32,
    pub daddr: __be32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr__bindgen_ty_1__bindgen_ty_2 {
    pub saddr: __be32,
    pub daddr: __be32,
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_parm {
    pub name: [::aya_bpf::cty::c_char; 16usize],
    pub link: ::aya_bpf::cty::c_int,
    pub i_flags: __be16,
    pub o_flags: __be16,
    pub i_key: __be32,
    pub o_key: __be32,
    pub iph: iphdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_name_node {
    pub hlist: hlist_node,
    pub list: list_head,
    pub dev: *mut net_device,
    pub name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_device {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub refcnt: refcount_t,
    pub dead: ::aya_bpf::cty::c_int,
    pub ifa_list: *mut in_ifaddr,
    pub mc_list: *mut ip_mc_list,
    pub mc_hash: *mut *mut ip_mc_list,
    pub mc_count: ::aya_bpf::cty::c_int,
    pub mc_tomb_lock: spinlock_t,
    pub mc_tomb: *mut ip_mc_list,
    pub mr_v1_seen: ::aya_bpf::cty::c_ulong,
    pub mr_v2_seen: ::aya_bpf::cty::c_ulong,
    pub mr_maxdelay: ::aya_bpf::cty::c_ulong,
    pub mr_qi: ::aya_bpf::cty::c_ulong,
    pub mr_qri: ::aya_bpf::cty::c_ulong,
    pub mr_qrv: ::aya_bpf::cty::c_uchar,
    pub mr_gq_running: ::aya_bpf::cty::c_uchar,
    pub mr_ifc_count: u32_,
    pub mr_gq_timer: timer_list,
    pub mr_ifc_timer: timer_list,
    pub arp_parms: *mut neigh_parms,
    pub cnf: ipv4_devconf,
    pub callback_head: callback_head,
}
pub mod devlink_port_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_PORT_TYPE_NOTSET: Type = 0;
    pub const DEVLINK_PORT_TYPE_AUTO: Type = 1;
    pub const DEVLINK_PORT_TYPE_ETH: Type = 2;
    pub const DEVLINK_PORT_TYPE_IB: Type = 3;
}
pub mod devlink_port_flavour {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_PORT_FLAVOUR_PHYSICAL: Type = 0;
    pub const DEVLINK_PORT_FLAVOUR_CPU: Type = 1;
    pub const DEVLINK_PORT_FLAVOUR_DSA: Type = 2;
    pub const DEVLINK_PORT_FLAVOUR_PCI_PF: Type = 3;
    pub const DEVLINK_PORT_FLAVOUR_PCI_VF: Type = 4;
    pub const DEVLINK_PORT_FLAVOUR_VIRTUAL: Type = 5;
    pub const DEVLINK_PORT_FLAVOUR_UNUSED: Type = 6;
    pub const DEVLINK_PORT_FLAVOUR_PCI_SF: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_phys_attrs {
    pub port_number: u32_,
    pub split_subport_number: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_pci_pf_attrs {
    pub controller: u32_,
    pub pf: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl devlink_port_pci_pf_attrs {
    #[inline]
    pub fn external(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(external: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_pci_vf_attrs {
    pub controller: u32_,
    pub pf: u16_,
    pub vf: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl devlink_port_pci_vf_attrs {
    #[inline]
    pub fn external(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(external: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_pci_sf_attrs {
    pub controller: u32_,
    pub sf: u32_,
    pub pf: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl devlink_port_pci_sf_attrs {
    #[inline]
    pub fn external(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(external: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_port_attrs {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub lanes: u32_,
    pub flavour: devlink_port_flavour::Type,
    pub switch_id: netdev_phys_item_id,
    pub __bindgen_anon_1: devlink_port_attrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_port_attrs__bindgen_ty_1 {
    pub phys: devlink_port_phys_attrs,
    pub pci_pf: devlink_port_pci_pf_attrs,
    pub pci_vf: devlink_port_pci_vf_attrs,
    pub pci_sf: devlink_port_pci_sf_attrs,
}
impl devlink_port_attrs {
    #[inline]
    pub fn split(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_split(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn splittable(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_splittable(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(split: u8_, splittable: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let split: u8 = unsafe { ::core::mem::transmute(split) };
            split as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let splittable: u8 = unsafe { ::core::mem::transmute(splittable) };
            splittable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_port {
    pub list: list_head,
    pub region_list: list_head,
    pub devlink: *mut devlink,
    pub index: ::aya_bpf::cty::c_uint,
    pub type_lock: spinlock_t,
    pub type_: devlink_port_type::Type,
    pub desired_type: devlink_port_type::Type,
    pub __bindgen_anon_1: devlink_port__bindgen_ty_1,
    pub attrs: devlink_port_attrs,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub type_warn_dw: delayed_work,
    pub reporter_list: list_head,
    pub reporters_lock: mutex,
    pub devlink_rate: *mut devlink_rate,
    pub linecard: *mut devlink_linecard,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_port__bindgen_ty_1 {
    pub type_eth: devlink_port__bindgen_ty_1__bindgen_ty_1,
    pub type_ib: devlink_port__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port__bindgen_ty_1__bindgen_ty_1 {
    pub netdev: *mut net_device,
    pub ifindex: ::aya_bpf::cty::c_int,
    pub ifname: [::aya_bpf::cty::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port__bindgen_ty_1__bindgen_ty_2 {
    pub ibdev: *mut ib_device,
}
impl devlink_port {
    #[inline]
    pub fn attrs_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_attrs_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn switch_port(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_switch_port(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn registered(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_registered(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn initialized(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        attrs_set: u8_,
        switch_port: u8_,
        registered: u8_,
        initialized: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let attrs_set: u8 = unsafe { ::core::mem::transmute(attrs_set) };
            attrs_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let switch_port: u8 = unsafe { ::core::mem::transmute(switch_port) };
            switch_port as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let registered: u8 = unsafe { ::core::mem::transmute(registered) };
            registered as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink {
    _unused: [u8; 0],
}
pub mod phylink_op_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PHYLINK_NETDEV: Type = 0;
    pub const PHYLINK_DEV: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_config {
    pub dev: *mut device,
    pub type_: phylink_op_type::Type,
    pub legacy_pre_march2020: bool_,
    pub poll_fixed_state: bool_,
    pub mac_managed_pm: bool_,
    pub ovr_an_inband: bool_,
    pub get_fixed_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phylink_config, arg2: *mut phylink_link_state),
    >,
    pub supported_interfaces: [::aya_bpf::cty::c_ulong; 1usize],
    pub mac_capabilities: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_port {
    pub __bindgen_anon_1: dsa_port__bindgen_ty_1,
    pub tag_ops: *const dsa_device_ops,
    pub dst: *mut dsa_switch_tree,
    pub rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> *mut sk_buff,
    >,
    pub ds: *mut dsa_switch,
    pub index: ::aya_bpf::cty::c_uint,
    pub type_: dsa_port__bindgen_ty_2::Type,
    pub name: *const ::aya_bpf::cty::c_char,
    pub cpu_dp: *mut dsa_port,
    pub mac: [u8_; 6usize],
    pub stp_state: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub dn: *mut device_node,
    pub ageing_time: ::aya_bpf::cty::c_uint,
    pub bridge: *mut dsa_bridge,
    pub devlink_port: devlink_port,
    pub pl: *mut phylink,
    pub pl_config: phylink_config,
    pub lag: *mut dsa_lag,
    pub hsr_dev: *mut net_device,
    pub list: list_head,
    pub orig_ethtool_ops: *const ethtool_ops,
    pub netdev_ops: *const dsa_netdevice_ops,
    pub addr_lists_lock: mutex,
    pub fdbs: list_head,
    pub mdbs: list_head,
    pub vlans_lock: mutex,
    pub vlans: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dsa_port__bindgen_ty_1 {
    pub master: *mut net_device,
    pub slave: *mut net_device,
}
pub mod dsa_port__bindgen_ty_2 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DSA_PORT_TYPE_UNUSED: Type = 0;
    pub const DSA_PORT_TYPE_CPU: Type = 1;
    pub const DSA_PORT_TYPE_DSA: Type = 2;
    pub const DSA_PORT_TYPE_USER: Type = 3;
}
impl dsa_port {
    #[inline]
    pub fn vlan_filtering(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_filtering(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn learning(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_learning(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lag_tx_enabled(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lag_tx_enabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn master_admin_up(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_master_admin_up(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn master_oper_up(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_master_oper_up(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpu_port_in_lag(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cpu_port_in_lag(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn setup(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_setup(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vlan_filtering: u8_,
        learning: u8_,
        lag_tx_enabled: u8_,
        master_admin_up: u8_,
        master_oper_up: u8_,
        cpu_port_in_lag: u8_,
        setup: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_filtering: u8 = unsafe { ::core::mem::transmute(vlan_filtering) };
            vlan_filtering as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let learning: u8 = unsafe { ::core::mem::transmute(learning) };
            learning as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lag_tx_enabled: u8 = unsafe { ::core::mem::transmute(lag_tx_enabled) };
            lag_tx_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let master_admin_up: u8 = unsafe { ::core::mem::transmute(master_admin_up) };
            master_admin_up as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let master_oper_up: u8 = unsafe { ::core::mem::transmute(master_oper_up) };
            master_oper_up as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cpu_port_in_lag: u8 = unsafe { ::core::mem::transmute(cpu_port_in_lag) };
            cpu_port_in_lag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let setup: u8 = unsafe { ::core::mem::transmute(setup) };
            setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cpu_rmap {
    pub refcount: kref,
    pub size: u16_,
    pub used: u16_,
    pub obj: *mut *mut ::aya_bpf::cty::c_void,
    pub near: __IncompleteArrayField<cpu_rmap__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_rmap__bindgen_ty_1 {
    pub index: u16_,
    pub dist: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_c45_device_ids {
    pub devices_in_package: u32_,
    pub mmds_present: u32_,
    pub device_ids: [u32_; 32usize],
}
pub mod phy_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const PHY_DOWN: Type = 0;
    pub const PHY_READY: Type = 1;
    pub const PHY_HALTED: Type = 2;
    pub const PHY_UP: Type = 3;
    pub const PHY_RUNNING: Type = 4;
    pub const PHY_NOLINK: Type = 5;
    pub const PHY_CABLETEST: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_led_trigger {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_device {
    pub mdio: mdio_device,
    pub drv: *mut phy_driver,
    pub devlink: *mut device_link,
    pub phy_id: u32_,
    pub c45_ids: phy_c45_device_ids,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub rate_matching: ::aya_bpf::cty::c_int,
    pub state: phy_state::Type,
    pub dev_flags: u32_,
    pub interface: phy_interface_t::Type,
    pub speed: ::aya_bpf::cty::c_int,
    pub duplex: ::aya_bpf::cty::c_int,
    pub port: ::aya_bpf::cty::c_int,
    pub pause: ::aya_bpf::cty::c_int,
    pub asym_pause: ::aya_bpf::cty::c_int,
    pub master_slave_get: u8_,
    pub master_slave_set: u8_,
    pub master_slave_state: u8_,
    pub supported: [::aya_bpf::cty::c_ulong; 2usize],
    pub advertising: [::aya_bpf::cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf::cty::c_ulong; 2usize],
    pub adv_old: [::aya_bpf::cty::c_ulong; 2usize],
    pub host_interfaces: [::aya_bpf::cty::c_ulong; 1usize],
    pub eee_broken_modes: u32_,
    pub phy_led_triggers: *mut phy_led_trigger,
    pub phy_num_led_triggers: ::aya_bpf::cty::c_uint,
    pub last_triggered: *mut phy_led_trigger,
    pub led_link_trigger: *mut phy_led_trigger,
    pub irq: ::aya_bpf::cty::c_int,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub shared: *mut phy_package_shared,
    pub skb: *mut sk_buff,
    pub ehdr: *mut ::aya_bpf::cty::c_void,
    pub nest: *mut nlattr,
    pub state_queue: delayed_work,
    pub lock: mutex,
    pub sfp_bus_attached: bool_,
    pub sfp_bus: *mut sfp_bus,
    pub phylink: *mut phylink,
    pub attached_dev: *mut net_device,
    pub mii_ts: *mut mii_timestamper,
    pub psec: *mut pse_control,
    pub mdix: u8_,
    pub mdix_ctrl: u8_,
    pub pma_extable: ::aya_bpf::cty::c_int,
    pub link_down_events: ::aya_bpf::cty::c_uint,
    pub phy_link_change:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_)>,
    pub adjust_link: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
    pub macsec_ops: *const macsec_ops,
}
impl phy_device {
    #[inline]
    pub fn is_c45(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_c45(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_internal(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_internal(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_pseudo_fixed_link(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_pseudo_fixed_link(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_gigabit_capable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_gigabit_capable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_fixups(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_fixups(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn suspended_by_mdio_bus(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_suspended_by_mdio_bus(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sysfs_links(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sysfs_links(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback_enabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback_enabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downshifted_rate(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downshifted_rate(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_on_sfp_module(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_on_sfp_module(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mac_managed_pm(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mac_managed_pm(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoneg_complete(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autoneg_complete(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupts(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupts(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_suspended(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_suspended(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_rerun(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_rerun(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_c45: ::aya_bpf::cty::c_uint,
        is_internal: ::aya_bpf::cty::c_uint,
        is_pseudo_fixed_link: ::aya_bpf::cty::c_uint,
        is_gigabit_capable: ::aya_bpf::cty::c_uint,
        has_fixups: ::aya_bpf::cty::c_uint,
        suspended: ::aya_bpf::cty::c_uint,
        suspended_by_mdio_bus: ::aya_bpf::cty::c_uint,
        sysfs_links: ::aya_bpf::cty::c_uint,
        loopback_enabled: ::aya_bpf::cty::c_uint,
        downshifted_rate: ::aya_bpf::cty::c_uint,
        is_on_sfp_module: ::aya_bpf::cty::c_uint,
        mac_managed_pm: ::aya_bpf::cty::c_uint,
        autoneg: ::aya_bpf::cty::c_uint,
        link: ::aya_bpf::cty::c_uint,
        autoneg_complete: ::aya_bpf::cty::c_uint,
        interrupts: ::aya_bpf::cty::c_uint,
        irq_suspended: ::aya_bpf::cty::c_uint,
        irq_rerun: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_c45: u32 = unsafe { ::core::mem::transmute(is_c45) };
            is_c45 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_internal: u32 = unsafe { ::core::mem::transmute(is_internal) };
            is_internal as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_pseudo_fixed_link: u32 = unsafe { ::core::mem::transmute(is_pseudo_fixed_link) };
            is_pseudo_fixed_link as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_gigabit_capable: u32 = unsafe { ::core::mem::transmute(is_gigabit_capable) };
            is_gigabit_capable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_fixups: u32 = unsafe { ::core::mem::transmute(has_fixups) };
            has_fixups as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let suspended: u32 = unsafe { ::core::mem::transmute(suspended) };
            suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let suspended_by_mdio_bus: u32 =
                unsafe { ::core::mem::transmute(suspended_by_mdio_bus) };
            suspended_by_mdio_bus as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sysfs_links: u32 = unsafe { ::core::mem::transmute(sysfs_links) };
            sysfs_links as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let loopback_enabled: u32 = unsafe { ::core::mem::transmute(loopback_enabled) };
            loopback_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downshifted_rate: u32 = unsafe { ::core::mem::transmute(downshifted_rate) };
            downshifted_rate as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_on_sfp_module: u32 = unsafe { ::core::mem::transmute(is_on_sfp_module) };
            is_on_sfp_module as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let mac_managed_pm: u32 = unsafe { ::core::mem::transmute(mac_managed_pm) };
            mac_managed_pm as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let autoneg: u32 = unsafe { ::core::mem::transmute(autoneg) };
            autoneg as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let autoneg_complete: u32 = unsafe { ::core::mem::transmute(autoneg_complete) };
            autoneg_complete as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let interrupts: u32 = unsafe { ::core::mem::transmute(interrupts) };
            interrupts as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let irq_suspended: u32 = unsafe { ::core::mem::transmute(irq_suspended) };
            irq_suspended as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let irq_rerun: u32 = unsafe { ::core::mem::transmute(irq_rerun) };
            irq_rerun as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod netdev_lag_tx_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NETDEV_LAG_TX_TYPE_UNKNOWN: Type = 0;
    pub const NETDEV_LAG_TX_TYPE_RANDOM: Type = 1;
    pub const NETDEV_LAG_TX_TYPE_BROADCAST: Type = 2;
    pub const NETDEV_LAG_TX_TYPE_ROUNDROBIN: Type = 3;
    pub const NETDEV_LAG_TX_TYPE_ACTIVEBACKUP: Type = 4;
    pub const NETDEV_LAG_TX_TYPE_HASH: Type = 5;
}
pub mod netdev_lag_hash {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NETDEV_LAG_HASH_NONE: Type = 0;
    pub const NETDEV_LAG_HASH_L2: Type = 1;
    pub const NETDEV_LAG_HASH_L34: Type = 2;
    pub const NETDEV_LAG_HASH_L23: Type = 3;
    pub const NETDEV_LAG_HASH_E23: Type = 4;
    pub const NETDEV_LAG_HASH_E34: Type = 5;
    pub const NETDEV_LAG_HASH_VLAN_SRCMAC: Type = 6;
    pub const NETDEV_LAG_HASH_UNKNOWN: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_lag_upper_info {
    pub tx_type: netdev_lag_tx_type::Type,
    pub hash_type: netdev_lag_hash::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_notifier_info {
    pub dev: *mut net_device,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_notifier_changeupper_info {
    pub info: netdev_notifier_info,
    pub upper_dev: *mut net_device,
    pub master: bool_,
    pub linking: bool_,
    pub upper_info: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_match {
    pub dissector: *mut flow_dissector,
    pub mask: *mut ::aya_bpf::cty::c_void,
    pub key: *mut ::aya_bpf::cty::c_void,
}
pub mod flow_action_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FLOW_ACTION_ACCEPT: Type = 0;
    pub const FLOW_ACTION_DROP: Type = 1;
    pub const FLOW_ACTION_TRAP: Type = 2;
    pub const FLOW_ACTION_GOTO: Type = 3;
    pub const FLOW_ACTION_REDIRECT: Type = 4;
    pub const FLOW_ACTION_MIRRED: Type = 5;
    pub const FLOW_ACTION_REDIRECT_INGRESS: Type = 6;
    pub const FLOW_ACTION_MIRRED_INGRESS: Type = 7;
    pub const FLOW_ACTION_VLAN_PUSH: Type = 8;
    pub const FLOW_ACTION_VLAN_POP: Type = 9;
    pub const FLOW_ACTION_VLAN_MANGLE: Type = 10;
    pub const FLOW_ACTION_TUNNEL_ENCAP: Type = 11;
    pub const FLOW_ACTION_TUNNEL_DECAP: Type = 12;
    pub const FLOW_ACTION_MANGLE: Type = 13;
    pub const FLOW_ACTION_ADD: Type = 14;
    pub const FLOW_ACTION_CSUM: Type = 15;
    pub const FLOW_ACTION_MARK: Type = 16;
    pub const FLOW_ACTION_PTYPE: Type = 17;
    pub const FLOW_ACTION_PRIORITY: Type = 18;
    pub const FLOW_ACTION_RX_QUEUE_MAPPING: Type = 19;
    pub const FLOW_ACTION_WAKE: Type = 20;
    pub const FLOW_ACTION_QUEUE: Type = 21;
    pub const FLOW_ACTION_SAMPLE: Type = 22;
    pub const FLOW_ACTION_POLICE: Type = 23;
    pub const FLOW_ACTION_CT: Type = 24;
    pub const FLOW_ACTION_CT_METADATA: Type = 25;
    pub const FLOW_ACTION_MPLS_PUSH: Type = 26;
    pub const FLOW_ACTION_MPLS_POP: Type = 27;
    pub const FLOW_ACTION_MPLS_MANGLE: Type = 28;
    pub const FLOW_ACTION_GATE: Type = 29;
    pub const FLOW_ACTION_PPPOE_PUSH: Type = 30;
    pub const FLOW_ACTION_JUMP: Type = 31;
    pub const FLOW_ACTION_PIPE: Type = 32;
    pub const FLOW_ACTION_VLAN_PUSH_ETH: Type = 33;
    pub const FLOW_ACTION_VLAN_POP_ETH: Type = 34;
    pub const FLOW_ACTION_CONTINUE: Type = 35;
    pub const NUM_FLOW_ACTIONS: Type = 36;
}
pub mod flow_action_hw_stats {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FLOW_ACTION_HW_STATS_IMMEDIATE: Type = 1;
    pub const FLOW_ACTION_HW_STATS_DELAYED: Type = 2;
    pub const FLOW_ACTION_HW_STATS_ANY: Type = 3;
    pub const FLOW_ACTION_HW_STATS_DISABLED: Type = 4;
    pub const FLOW_ACTION_HW_STATS_DONT_CARE: Type = 7;
}
pub type action_destr =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>;
pub mod flow_action_mangle_base {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FLOW_ACT_MANGLE_UNSPEC: Type = 0;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_ETH: Type = 1;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_IP4: Type = 2;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_IP6: Type = 3;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_TCP: Type = 4;
    pub const FLOW_ACT_MANGLE_HDR_TYPE_UDP: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_flowtable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry {
    pub id: flow_action_id::Type,
    pub hw_index: u32_,
    pub hw_stats: flow_action_hw_stats::Type,
    pub destructor: action_destr,
    pub destructor_priv: *mut ::aya_bpf::cty::c_void,
    pub __bindgen_anon_1: flow_action_entry__bindgen_ty_1,
    pub cookie: *mut flow_action_cookie,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_action_entry__bindgen_ty_1 {
    pub chain_index: u32_,
    pub dev: *mut net_device,
    pub vlan: flow_action_entry__bindgen_ty_1__bindgen_ty_1,
    pub vlan_push_eth: flow_action_entry__bindgen_ty_1__bindgen_ty_2,
    pub mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_3,
    pub tunnel: *mut ip_tunnel_info,
    pub csum_flags: u32_,
    pub mark: u32_,
    pub ptype: u16_,
    pub rx_queue: u16_,
    pub priority: u32_,
    pub queue: flow_action_entry__bindgen_ty_1__bindgen_ty_4,
    pub sample: flow_action_entry__bindgen_ty_1__bindgen_ty_5,
    pub police: flow_action_entry__bindgen_ty_1__bindgen_ty_6,
    pub ct: flow_action_entry__bindgen_ty_1__bindgen_ty_7,
    pub ct_metadata: flow_action_entry__bindgen_ty_1__bindgen_ty_8,
    pub mpls_push: flow_action_entry__bindgen_ty_1__bindgen_ty_9,
    pub mpls_pop: flow_action_entry__bindgen_ty_1__bindgen_ty_10,
    pub mpls_mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_11,
    pub gate: flow_action_entry__bindgen_ty_1__bindgen_ty_12,
    pub pppoe: flow_action_entry__bindgen_ty_1__bindgen_ty_13,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_1 {
    pub vid: u16_,
    pub proto: __be16,
    pub prio: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_2 {
    pub dst: [::aya_bpf::cty::c_uchar; 6usize],
    pub src: [::aya_bpf::cty::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_3 {
    pub htype: flow_action_mangle_base::Type,
    pub offset: u32_,
    pub mask: u32_,
    pub val: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_4 {
    pub ctx: u32_,
    pub index: u32_,
    pub vf: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_5 {
    pub psample_group: *mut psample_group,
    pub rate: u32_,
    pub trunc_size: u32_,
    pub truncate: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6 {
    pub burst: u32_,
    pub rate_bytes_ps: u64_,
    pub peakrate_bytes_ps: u64_,
    pub avrate: u32_,
    pub overhead: u16_,
    pub burst_pkt: u64_,
    pub rate_pkt_ps: u64_,
    pub mtu: u32_,
    pub exceed: flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub notexceed: flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub act_id: flow_action_id::Type,
    pub extval: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub act_id: flow_action_id::Type,
    pub extval: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_7 {
    pub action: ::aya_bpf::cty::c_int,
    pub zone: u16_,
    pub flow_table: *mut nf_flowtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_8 {
    pub cookie: ::aya_bpf::cty::c_ulong,
    pub mark: u32_,
    pub labels: [u32_; 4usize],
    pub orig_dir: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_9 {
    pub label: u32_,
    pub proto: __be16,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_10 {
    pub proto: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_11 {
    pub label: u32_,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_12 {
    pub prio: s32,
    pub basetime: u64_,
    pub cycletime: u64_,
    pub cycletimeext: u64_,
    pub num_entries: u32_,
    pub entries: *mut action_gate_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_13 {
    pub sid: u16_,
}
#[repr(C)]
pub struct flow_action {
    pub num_entries: ::aya_bpf::cty::c_uint,
    pub entries: __IncompleteArrayField<flow_action_entry>,
}
#[repr(C)]
pub struct flow_rule {
    pub match_: flow_match,
    pub action: flow_action,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_tdr_config {
    pub first: u32_,
    pub last: u32_,
    pub step: u32_,
    pub pair: s8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub dev_name: [::aya_bpf::cty::c_char; 16usize],
    pub name: *const ::aya_bpf::cty::c_char,
    pub local_ip: inet_addr,
    pub remote_ip: inet_addr,
    pub ipv6: bool_,
    pub local_port: u16_,
    pub remote_port: u16_,
    pub remote_mac: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct flow_action_cookie {
    pub cookie_len: u32_,
    pub cookie: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_key {
    pub tun_id: __be64,
    pub u: ip_tunnel_key__bindgen_ty_1,
    pub tun_flags: __be16,
    pub tos: u8_,
    pub ttl: u8_,
    pub label: __be32,
    pub tp_src: __be16,
    pub tp_dst: __be16,
    pub flow_flags: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_tunnel_key__bindgen_ty_1 {
    pub ipv4: ip_tunnel_key__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: ip_tunnel_key__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_tunnel_key__bindgen_ty_1__bindgen_ty_1 {
    pub src: __be32,
    pub dst: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_key__bindgen_ty_1__bindgen_ty_2 {
    pub src: in6_addr,
    pub dst: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_cache {
    pub cache: *mut dst_cache_pcpu,
    pub reset_ts: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_info {
    pub key: ip_tunnel_key,
    pub dst_cache: dst_cache,
    pub options_len: u8_,
    pub mode: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_stats {
    pub pkts: u64_,
    pub bytes: u64_,
    pub drops: u64_,
    pub lastused: u64_,
    pub used_hw_stats: flow_action_hw_stats::Type,
    pub used_hw_stats_valid: bool_,
}
pub mod flow_cls_command {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FLOW_CLS_REPLACE: Type = 0;
    pub const FLOW_CLS_DESTROY: Type = 1;
    pub const FLOW_CLS_STATS: Type = 2;
    pub const FLOW_CLS_TMPLT_CREATE: Type = 3;
    pub const FLOW_CLS_TMPLT_DESTROY: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_cls_common_offload {
    pub chain_index: u32_,
    pub protocol: __be16,
    pub prio: u32_,
    pub extack: *mut netlink_ext_ack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flow_cls_offload {
    pub common: flow_cls_common_offload,
    pub command: flow_cls_command::Type,
    pub cookie: ::aya_bpf::cty::c_ulong,
    pub rule: *mut flow_rule,
    pub stats: flow_stats,
    pub classid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdisc_walker {
    pub stop: ::aya_bpf::cty::c_int,
    pub skip: ::aya_bpf::cty::c_int,
    pub count: ::aya_bpf::cty::c_int,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut qdisc_walker,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcf_walker {
    pub stop: ::aya_bpf::cty::c_int,
    pub skip: ::aya_bpf::cty::c_int,
    pub count: ::aya_bpf::cty::c_int,
    pub nonempty: bool_,
    pub cookie: ::aya_bpf::cty::c_ulong,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut tcf_proto,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut tcf_walker,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dst_metrics {
    pub metrics: [u32_; 17usize],
    pub refcnt: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fib_nh_exception {
    pub fnhe_next: *mut fib_nh_exception,
    pub fnhe_genid: ::aya_bpf::cty::c_int,
    pub fnhe_daddr: __be32,
    pub fnhe_pmtu: u32_,
    pub fnhe_mtu_locked: bool_,
    pub fnhe_gw: __be32,
    pub fnhe_expires: ::aya_bpf::cty::c_ulong,
    pub fnhe_rth_input: *mut rtable,
    pub fnhe_rth_output: *mut rtable,
    pub fnhe_stamp: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtable {
    pub dst: dst_entry,
    pub rt_genid: ::aya_bpf::cty::c_int,
    pub rt_flags: ::aya_bpf::cty::c_uint,
    pub rt_type: __u16,
    pub rt_is_input: __u8,
    pub rt_uses_gateway: __u8,
    pub rt_iif: ::aya_bpf::cty::c_int,
    pub rt_gw_family: u8_,
    pub __bindgen_anon_1: rtable__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub rt_uncached: list_head,
    pub rt_uncached_list: *mut uncached_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtable__bindgen_ty_1 {
    pub rt_gw4: __be32,
    pub rt_gw6: in6_addr,
}
impl rtable {
    #[inline]
    pub fn rt_mtu_locked(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_mtu_locked(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rt_pmtu(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rt_pmtu(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rt_mtu_locked: u32_,
        rt_pmtu: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rt_mtu_locked: u32 = unsafe { ::core::mem::transmute(rt_mtu_locked) };
            rt_mtu_locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rt_pmtu: u32 = unsafe { ::core::mem::transmute(rt_pmtu) };
            rt_pmtu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fnhe_hash_bucket {
    pub chain: *mut fib_nh_exception,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh {
    pub nh_common: fib_nh_common,
    pub nh_hash: hlist_node,
    pub nh_parent: *mut fib_info,
    pub nh_tclassid: __u32,
    pub nh_saddr: __be32,
    pub nh_saddr_genid: ::aya_bpf::cty::c_int,
}
#[repr(C)]
pub struct fib_info {
    pub fib_hash: hlist_node,
    pub fib_lhash: hlist_node,
    pub nh_list: list_head,
    pub fib_net: *mut net,
    pub fib_treeref: refcount_t,
    pub fib_clntref: refcount_t,
    pub fib_flags: ::aya_bpf::cty::c_uint,
    pub fib_dead: ::aya_bpf::cty::c_uchar,
    pub fib_protocol: ::aya_bpf::cty::c_uchar,
    pub fib_scope: ::aya_bpf::cty::c_uchar,
    pub fib_type: ::aya_bpf::cty::c_uchar,
    pub fib_prefsrc: __be32,
    pub fib_tb_id: u32_,
    pub fib_priority: u32_,
    pub fib_metrics: *mut dst_metrics,
    pub fib_nhs: ::aya_bpf::cty::c_int,
    pub fib_nh_is_v6: bool_,
    pub nh_updated: bool_,
    pub nh: *mut nexthop,
    pub rcu: callback_head,
    pub fib_nh: __IncompleteArrayField<fib_nh>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nexthop {
    pub rb_node: rb_node,
    pub fi_list: list_head,
    pub f6i_list: list_head,
    pub fdb_list: list_head,
    pub grp_list: list_head,
    pub net: *mut net,
    pub id: u32_,
    pub protocol: u8_,
    pub nh_flags: u8_,
    pub is_group: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub __bindgen_anon_1: nexthop__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nexthop__bindgen_ty_1 {
    pub nh_info: *mut nh_info,
    pub nh_grp: *mut nh_group,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mdio_driver_common {
    pub driver: device_driver,
    pub flags: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mii_timestamper {
    pub rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut sk_buff,
            arg3: ::aya_bpf::cty::c_int,
        ) -> bool_,
    >,
    pub txtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut sk_buff,
            arg3: ::aya_bpf::cty::c_int,
        ),
    >,
    pub hwtstamp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mii_timestamper, arg2: *mut ifreq) -> ::aya_bpf::cty::c_int,
    >,
    pub link_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mii_timestamper, arg2: *mut phy_device),
    >,
    pub ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mii_timestamper,
            arg2: *mut ethtool_ts_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub device: *mut device,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_driver {
    pub mdiodrv: mdio_driver_common,
    pub phy_id: u32_,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub phy_id_mask: u32_,
    pub features: *const ::aya_bpf::cty::c_ulong,
    pub flags: u32_,
    pub driver_data: *const ::aya_bpf::cty::c_void,
    pub soft_reset: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub config_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_features: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_rate_matching: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: phy_interface_t::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub resume: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub config_aneg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub aneg_done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub read_status: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub config_intr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub handle_interrupt:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device) -> irqreturn_t>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>,
    pub match_phy_device: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_wolinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_wolinfo),
    >,
    pub link_change_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device)>,
    pub read_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write_mmd: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
            arg4: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub write_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_modinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cable_test_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub cable_test_tdr_start: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *const phy_tdr_config,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cable_test_get_status: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut bool_) -> ::aya_bpf::cty::c_int,
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_strings:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut u8_)>,
    pub get_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: *mut ethtool_stats, arg3: *mut u64_),
    >,
    pub get_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_tunable,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_tunable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phy_device,
            arg2: *mut ethtool_tunable,
            arg3: *const ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_loopback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device, arg2: bool_) -> ::aya_bpf::cty::c_int,
    >,
    pub get_sqi: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
    pub get_sqi_max: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phy_device) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_chip_data {
    pub host_dev: *mut device,
    pub sw_addr: ::aya_bpf::cty::c_int,
    pub netdev: [*mut device; 12usize],
    pub eeprom_len: ::aya_bpf::cty::c_int,
    pub of_node: *mut device_node,
    pub port_names: [*mut ::aya_bpf::cty::c_char; 12usize],
    pub port_dn: [*mut device_node; 12usize],
    pub rtable: [s8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_platform_data {
    pub netdev: *mut device,
    pub of_netdev: *mut net_device,
    pub nr_chips: ::aya_bpf::cty::c_int,
    pub chip: *mut dsa_chip_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_link_state {
    pub advertising: [::aya_bpf::cty::c_ulong; 2usize],
    pub lp_advertising: [::aya_bpf::cty::c_ulong; 2usize],
    pub interface: phy_interface_t::Type,
    pub speed: ::aya_bpf::cty::c_int,
    pub duplex: ::aya_bpf::cty::c_int,
    pub pause: ::aya_bpf::cty::c_int,
    pub rate_matching: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl phylink_link_state {
    #[inline]
    pub fn link(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn an_enabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_an_enabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn an_complete(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_an_complete(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link: ::aya_bpf::cty::c_uint,
        an_enabled: ::aya_bpf::cty::c_uint,
        an_complete: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link: u32 = unsafe { ::core::mem::transmute(link) };
            link as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let an_enabled: u32 = unsafe { ::core::mem::transmute(an_enabled) };
            an_enabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let an_complete: u32 = unsafe { ::core::mem::transmute(an_complete) };
            an_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_pcs {
    pub ops: *const phylink_pcs_ops,
    pub poll: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phylink_pcs_ops {
    pub pcs_validate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phylink_pcs,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: *const phylink_link_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pcs_get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut phylink_pcs, arg2: *mut phylink_link_state),
    >,
    pub pcs_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phylink_pcs,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: phy_interface_t::Type,
            arg4: *const ::aya_bpf::cty::c_ulong,
            arg5: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pcs_an_restart: ::core::option::Option<unsafe extern "C" fn(arg1: *mut phylink_pcs)>,
    pub pcs_link_up: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut phylink_pcs,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: phy_interface_t::Type,
            arg4: ::aya_bpf::cty::c_int,
            arg5: ::aya_bpf::cty::c_int,
        ),
    >,
}
pub mod devlink_sb_pool_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_SB_POOL_TYPE_INGRESS: Type = 0;
    pub const DEVLINK_SB_POOL_TYPE_EGRESS: Type = 1;
}
pub mod devlink_sb_threshold_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_SB_THRESHOLD_TYPE_STATIC: Type = 0;
    pub const DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC: Type = 1;
}
pub mod devlink_rate_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_RATE_TYPE_LEAF: Type = 0;
    pub const DEVLINK_RATE_TYPE_NODE: Type = 1;
}
pub mod devlink_param_cmode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_PARAM_CMODE_RUNTIME: Type = 0;
    pub const DEVLINK_PARAM_CMODE_DRIVERINIT: Type = 1;
    pub const DEVLINK_PARAM_CMODE_PERMANENT: Type = 2;
    pub const __DEVLINK_PARAM_CMODE_MAX: Type = 3;
    pub const DEVLINK_PARAM_CMODE_MAX: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_rate {
    pub list: list_head,
    pub type_: devlink_rate_type::Type,
    pub devlink: *mut devlink,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub tx_share: u64_,
    pub tx_max: u64_,
    pub parent: *mut devlink_rate,
    pub __bindgen_anon_1: devlink_rate__bindgen_ty_1,
    pub tx_priority: u32_,
    pub tx_weight: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_rate__bindgen_ty_1 {
    pub devlink_port: *mut devlink_port,
    pub __bindgen_anon_1: devlink_rate__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_rate__bindgen_ty_1__bindgen_ty_1 {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub refcnt: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_sb_pool_info {
    pub pool_type: devlink_sb_pool_type::Type,
    pub size: u32_,
    pub threshold_type: devlink_sb_threshold_type::Type,
    pub cell_size: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union devlink_param_value {
    pub vu8: u8_,
    pub vu16: u16_,
    pub vu32: u32_,
    pub vstr: [::aya_bpf::cty::c_char; 32usize],
    pub vbool: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_param_gset_ctx {
    pub val: devlink_param_value,
    pub cmode: devlink_param_cmode::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_mst_state {
    pub msti: u16_,
    pub state: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_brport_flags {
    pub val: ::aya_bpf::cty::c_ulong,
    pub mask: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_vlan_msti {
    pub vid: u16_,
    pub msti: u16_,
}
pub mod switchdev_obj_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const SWITCHDEV_OBJ_ID_UNDEFINED: Type = 0;
    pub const SWITCHDEV_OBJ_ID_PORT_VLAN: Type = 1;
    pub const SWITCHDEV_OBJ_ID_PORT_MDB: Type = 2;
    pub const SWITCHDEV_OBJ_ID_HOST_MDB: Type = 3;
    pub const SWITCHDEV_OBJ_ID_MRP: Type = 4;
    pub const SWITCHDEV_OBJ_ID_RING_TEST_MRP: Type = 5;
    pub const SWITCHDEV_OBJ_ID_RING_ROLE_MRP: Type = 6;
    pub const SWITCHDEV_OBJ_ID_RING_STATE_MRP: Type = 7;
    pub const SWITCHDEV_OBJ_ID_IN_TEST_MRP: Type = 8;
    pub const SWITCHDEV_OBJ_ID_IN_ROLE_MRP: Type = 9;
    pub const SWITCHDEV_OBJ_ID_IN_STATE_MRP: Type = 10;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj {
    pub list: list_head,
    pub orig_dev: *mut net_device,
    pub id: switchdev_obj_id::Type,
    pub flags: u32_,
    pub complete_priv: *mut ::aya_bpf::cty::c_void,
    pub complete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ::aya_bpf::cty::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_port_vlan {
    pub obj: switchdev_obj,
    pub flags: u16_,
    pub vid: u16_,
    pub changed: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_port_mdb {
    pub obj: switchdev_obj,
    pub addr: [::aya_bpf::cty::c_uchar; 6usize],
    pub vid: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_mrp {
    pub obj: switchdev_obj,
    pub p_port: *mut net_device,
    pub s_port: *mut net_device,
    pub ring_id: u32_,
    pub prio: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct switchdev_obj_ring_role_mrp {
    pub obj: switchdev_obj,
    pub ring_role: u8_,
    pub ring_id: u32_,
    pub sw_backup: u8_,
}
pub mod dsa_tag_protocol {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DSA_TAG_PROTO_NONE: Type = 0;
    pub const DSA_TAG_PROTO_BRCM: Type = 1;
    pub const DSA_TAG_PROTO_BRCM_LEGACY: Type = 22;
    pub const DSA_TAG_PROTO_BRCM_PREPEND: Type = 2;
    pub const DSA_TAG_PROTO_DSA: Type = 3;
    pub const DSA_TAG_PROTO_EDSA: Type = 4;
    pub const DSA_TAG_PROTO_GSWIP: Type = 5;
    pub const DSA_TAG_PROTO_KSZ9477: Type = 6;
    pub const DSA_TAG_PROTO_KSZ9893: Type = 7;
    pub const DSA_TAG_PROTO_LAN9303: Type = 8;
    pub const DSA_TAG_PROTO_MTK: Type = 9;
    pub const DSA_TAG_PROTO_QCA: Type = 10;
    pub const DSA_TAG_PROTO_TRAILER: Type = 11;
    pub const DSA_TAG_PROTO_8021Q: Type = 12;
    pub const DSA_TAG_PROTO_SJA1105: Type = 13;
    pub const DSA_TAG_PROTO_KSZ8795: Type = 14;
    pub const DSA_TAG_PROTO_OCELOT: Type = 15;
    pub const DSA_TAG_PROTO_AR9331: Type = 16;
    pub const DSA_TAG_PROTO_RTL4_A: Type = 17;
    pub const DSA_TAG_PROTO_HELLCREEK: Type = 18;
    pub const DSA_TAG_PROTO_XRS700X: Type = 19;
    pub const DSA_TAG_PROTO_OCELOT_8021Q: Type = 20;
    pub const DSA_TAG_PROTO_SEVILLE: Type = 21;
    pub const DSA_TAG_PROTO_SJA1110: Type = 23;
    pub const DSA_TAG_PROTO_RTL8_4: Type = 24;
    pub const DSA_TAG_PROTO_RTL8_4T: Type = 25;
    pub const DSA_TAG_PROTO_RZN1_A5PSW: Type = 26;
    pub const DSA_TAG_PROTO_LAN937X: Type = 27;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_device_ops {
    pub xmit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> *mut sk_buff,
    >,
    pub rcv: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut net_device) -> *mut sk_buff,
    >,
    pub flow_dissect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sk_buff,
            arg2: *mut __be16,
            arg3: *mut ::aya_bpf::cty::c_int,
        ),
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf::cty::c_int,
    >,
    pub disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch)>,
    pub needed_headroom: ::aya_bpf::cty::c_uint,
    pub needed_tailroom: ::aya_bpf::cty::c_uint,
    pub name: *const ::aya_bpf::cty::c_char,
    pub proto: dsa_tag_protocol::Type,
    pub promisc_on_master: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_8021q_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch {
    pub dev: *mut device,
    pub dst: *mut dsa_switch_tree,
    pub index: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub nb: notifier_block,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub tagger_data: *mut ::aya_bpf::cty::c_void,
    pub cd: *mut dsa_chip_data,
    pub ops: *const dsa_switch_ops,
    pub phys_mii_mask: u32_,
    pub slave_mii_bus: *mut mii_bus,
    pub ageing_time_min: ::aya_bpf::cty::c_uint,
    pub ageing_time_max: ::aya_bpf::cty::c_uint,
    pub tag_8021q_ctx: *mut dsa_8021q_context,
    pub devlink: *mut devlink,
    pub num_tx_queues: ::aya_bpf::cty::c_uint,
    pub num_lag_ids: ::aya_bpf::cty::c_uint,
    pub max_num_bridges: ::aya_bpf::cty::c_uint,
    pub num_ports: ::aya_bpf::cty::c_uint,
}
impl dsa_switch {
    #[inline]
    pub fn setup(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_setup(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_filtering_is_global(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_filtering_is_global(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_standalone_vlan_filtering(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_standalone_vlan_filtering(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn configure_vlan_while_not_filtering(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_configure_vlan_while_not_filtering(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn untag_bridge_pvid(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_untag_bridge_pvid(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn assisted_learning_on_cpu_port(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_assisted_learning_on_cpu_port(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_filtering(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_vlan_filtering(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mtu_enforcement_ingress(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mtu_enforcement_ingress(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fdb_isolation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fdb_isolation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        setup: u32_,
        vlan_filtering_is_global: u32_,
        needs_standalone_vlan_filtering: u32_,
        configure_vlan_while_not_filtering: u32_,
        untag_bridge_pvid: u32_,
        assisted_learning_on_cpu_port: u32_,
        vlan_filtering: u32_,
        mtu_enforcement_ingress: u32_,
        fdb_isolation: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let setup: u32 = unsafe { ::core::mem::transmute(setup) };
            setup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let vlan_filtering_is_global: u32 =
                unsafe { ::core::mem::transmute(vlan_filtering_is_global) };
            vlan_filtering_is_global as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let needs_standalone_vlan_filtering: u32 =
                unsafe { ::core::mem::transmute(needs_standalone_vlan_filtering) };
            needs_standalone_vlan_filtering as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let configure_vlan_while_not_filtering: u32 =
                unsafe { ::core::mem::transmute(configure_vlan_while_not_filtering) };
            configure_vlan_while_not_filtering as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let untag_bridge_pvid: u32 = unsafe { ::core::mem::transmute(untag_bridge_pvid) };
            untag_bridge_pvid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let assisted_learning_on_cpu_port: u32 =
                unsafe { ::core::mem::transmute(assisted_learning_on_cpu_port) };
            assisted_learning_on_cpu_port as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let vlan_filtering: u32 = unsafe { ::core::mem::transmute(vlan_filtering) };
            vlan_filtering as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let mtu_enforcement_ingress: u32 =
                unsafe { ::core::mem::transmute(mtu_enforcement_ingress) };
            mtu_enforcement_ingress as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fdb_isolation: u32 = unsafe { ::core::mem::transmute(fdb_isolation) };
            fdb_isolation as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_netdevice_ops {
    pub ndo_eth_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net_device,
            arg2: *mut ifreq,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_lag {
    pub dev: *mut net_device,
    pub id: ::aya_bpf::cty::c_uint,
    pub fdb_lock: mutex,
    pub fdbs: list_head,
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch_tree {
    pub list: list_head,
    pub ports: list_head,
    pub nh: raw_notifier_head,
    pub index: ::aya_bpf::cty::c_uint,
    pub refcount: kref,
    pub lags: *mut *mut dsa_lag,
    pub tag_ops: *const dsa_device_ops,
    pub default_proto: dsa_tag_protocol::Type,
    pub setup: bool_,
    pub pd: *mut dsa_platform_data,
    pub rtable: list_head,
    pub lags_len: ::aya_bpf::cty::c_uint,
    pub last_switch: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_mall_mirror_tc_entry {
    pub to_local_port: u8_,
    pub ingress: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_mall_policer_tc_entry {
    pub burst: u32_,
    pub rate_bytes_per_sec: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_bridge {
    pub dev: *mut net_device,
    pub num: ::aya_bpf::cty::c_uint,
    pub tx_fwd_offload: bool_,
    pub refcount: refcount_t,
}
pub mod dsa_db_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DSA_DB_PORT: Type = 0;
    pub const DSA_DB_LAG: Type = 1;
    pub const DSA_DB_BRIDGE: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_db {
    pub type_: dsa_db_type::Type,
    pub __bindgen_anon_1: dsa_db__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dsa_db__bindgen_ty_1 {
    pub dp: *const dsa_port,
    pub lag: dsa_lag,
    pub bridge: dsa_bridge,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fixed_phy_status {
    _unused: [u8; 0],
}
pub type dsa_fdb_dump_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_bpf::cty::c_uchar,
        arg2: u16_,
        arg3: bool_,
        arg4: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_switch_ops {
    pub get_tag_protocol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: dsa_tag_protocol::Type,
        ) -> dsa_tag_protocol::Type,
    >,
    pub change_tag_protocol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: dsa_tag_protocol::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub connect_tag_protocol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: dsa_tag_protocol::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_change_master: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut net_device,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf::cty::c_int,
    >,
    pub teardown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dsa_switch)>,
    pub port_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_teardown: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int),
    >,
    pub get_phy_flags: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int) -> u32_,
    >,
    pub phy_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub phy_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub adjust_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut phy_device,
        ),
    >,
    pub fixed_link_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut fixed_phy_status,
        ),
    >,
    pub phylink_get_caps: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut phylink_config,
        ),
    >,
    pub phylink_mac_select_pcs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: phy_interface_t::Type,
        ) -> *mut phylink_pcs,
    >,
    pub phylink_mac_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut phylink_link_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub phylink_mac_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *const phylink_link_state,
        ),
    >,
    pub phylink_mac_an_restart: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int),
    >,
    pub phylink_mac_link_down: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: phy_interface_t::Type,
        ),
    >,
    pub phylink_mac_link_up: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: phy_interface_t::Type,
            arg5: *mut phy_device,
            arg6: ::aya_bpf::cty::c_int,
            arg7: ::aya_bpf::cty::c_int,
            arg8: bool_,
            arg9: bool_,
        ),
    >,
    pub phylink_fixed_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut phylink_link_state,
        ),
    >,
    pub get_strings: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: *mut u8,
        ),
    >,
    pub get_ethtool_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int, arg3: *mut u64),
    >,
    pub get_sset_count: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ethtool_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int, arg3: *mut u64),
    >,
    pub get_eth_phy_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_eth_phy_stats,
        ),
    >,
    pub get_eth_mac_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_eth_mac_stats,
        ),
    >,
    pub get_eth_ctrl_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_eth_ctrl_stats,
        ),
    >,
    pub get_rmon_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_rmon_stats,
            arg4: *mut *const ethtool_rmon_hist_range,
        ),
    >,
    pub get_stats64: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut rtnl_link_stats64,
        ),
    >,
    pub get_pause_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_pause_stats,
        ),
    >,
    pub self_test: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_test,
            arg4: *mut u64_,
        ),
    >,
    pub get_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_wolinfo,
        ),
    >,
    pub set_wol: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_wolinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_ts_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_ts_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_get_default_prio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_set_default_prio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_get_dscp_prio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_add_dscp_prio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
            arg4: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_del_dscp_prio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u8_,
            arg4: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf::cty::c_int,
    >,
    pub resume: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf::cty::c_int,
    >,
    pub port_enable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut phy_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int),
    >,
    pub set_mac_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_eee,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_mac_eee: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_eee,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_eeprom_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch) -> ::aya_bpf::cty::c_int,
    >,
    pub get_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_regs_len: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_regs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_regs,
            arg4: *mut ::aya_bpf::cty::c_void,
        ),
    >,
    pub port_prechangeupper: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut netdev_notifier_changeupper_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_ageing_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_bridge_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: dsa_bridge,
            arg4: *mut bool_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_bridge_leave: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int, arg3: dsa_bridge),
    >,
    pub port_stp_state_set: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int, arg3: u8_),
    >,
    pub port_mst_state_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_mst_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fast_age: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int),
    >,
    pub port_vlan_fast_age: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_pre_bridge_flags: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: switchdev_brport_flags,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_bridge_flags: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: switchdev_brport_flags,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_set_host_flood: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
            arg4: bool_,
        ),
    >,
    pub port_vlan_filtering: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: bool_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_vlan_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_port_vlan,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_vlan_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_port_vlan,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub vlan_msti_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: dsa_bridge,
            arg3: *const switchdev_vlan_msti,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: u16_,
            arg5: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: u16_,
            arg5: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: dsa_fdb_dump_cb_t,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lag_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: dsa_lag,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: u16_,
            arg5: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lag_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: dsa_lag,
            arg3: *const ::aya_bpf::cty::c_uchar,
            arg4: u16_,
            arg5: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_port_mdb,
            arg4: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_port_mdb,
            arg4: dsa_db,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_rxnfc,
            arg4: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_rxnfc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ethtool_rxnfc,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cls_flower_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cls_flower_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub cls_flower_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut flow_cls_offload,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mirror_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut dsa_mall_mirror_tc_entry,
            arg4: bool_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mirror_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut dsa_mall_mirror_tc_entry,
        ),
    >,
    pub port_policer_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut dsa_mall_policer_tc_entry,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_policer_del: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: ::aya_bpf::cty::c_int),
    >,
    pub port_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: tc_setup_type::Type,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub crosschip_bridge_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
            arg5: dsa_bridge,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub crosschip_bridge_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: ::aya_bpf::cty::c_int,
            arg5: dsa_bridge,
        ),
    >,
    pub crosschip_lag_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub crosschip_lag_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dsa_lag,
            arg5: *mut netdev_lag_upper_info,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub crosschip_lag_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: dsa_lag,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_hwtstamp_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ifreq,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_hwtstamp_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ifreq,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_txtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut sk_buff,
        ),
    >,
    pub port_rxtstamp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut sk_buff,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> bool_,
    >,
    pub devlink_param_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: u32_,
            arg3: *mut devlink_param_gset_ctx,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_param_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: u32_,
            arg3: *mut devlink_param_gset_ctx,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_info_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: *mut devlink_info_req,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: *mut devlink_sb_pool_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: u32_,
            arg5: devlink_sb_threshold_type::Type,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_port_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: u32_,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_tc_pool_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: devlink_sb_pool_type::Type,
            arg6: *mut u16_,
            arg7: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_tc_pool_bind_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: devlink_sb_pool_type::Type,
            arg6: u16_,
            arg7: u32_,
            arg8: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_occ_snapshot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_occ_max_clear: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_occ_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: *mut u32_,
            arg6: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub devlink_sb_occ_tc_port_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: u16_,
            arg5: devlink_sb_pool_type::Type,
            arg6: *mut u32_,
            arg7: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_max_mtu: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_lag_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_lag_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: dsa_lag,
            arg4: *mut netdev_lag_upper_info,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_lag_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: dsa_lag,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_hsr_join: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut net_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_hsr_leave: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut net_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mrp_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_mrp,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mrp_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_mrp,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mrp_add_ring_role: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_ring_role_mrp,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_mrp_del_ring_role: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *const switchdev_obj_ring_role_mrp,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub tag_8021q_vlan_add: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
            arg4: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub tag_8021q_vlan_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dsa_switch,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub master_state_change: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dsa_switch, arg2: *const net_device, arg3: bool_),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt6_exception_bucket {
    pub chain: hlist_head,
    pub depth: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nh_info {
    pub dev_hash: hlist_node,
    pub nh_parent: *mut nexthop,
    pub family: u8_,
    pub reject_nh: bool_,
    pub fdb_nh: bool_,
    pub __bindgen_anon_1: nh_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nh_info__bindgen_ty_1 {
    pub fib_nhc: fib_nh_common,
    pub fib_nh: fib_nh,
    pub fib6_nh: fib6_nh,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nh_res_bucket {
    pub nh_entry: *mut nh_grp_entry,
    pub used_time: atomic_long_t,
    pub migrated_time: ::aya_bpf::cty::c_ulong,
    pub occupied: bool_,
    pub nh_flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nh_grp_entry {
    pub nh: *mut nexthop,
    pub weight: u8_,
    pub __bindgen_anon_1: nh_grp_entry__bindgen_ty_1,
    pub nh_list: list_head,
    pub nh_parent: *mut nexthop,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nh_grp_entry__bindgen_ty_1 {
    pub hthr: nh_grp_entry__bindgen_ty_1__bindgen_ty_1,
    pub res: nh_grp_entry__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nh_grp_entry__bindgen_ty_1__bindgen_ty_1 {
    pub upper_bound: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nh_grp_entry__bindgen_ty_1__bindgen_ty_2 {
    pub uw_nh_entry: list_head,
    pub count_buckets: u16_,
    pub wants_buckets: u16_,
}
#[repr(C)]
#[derive(Debug)]
pub struct nh_res_table {
    pub net: *mut net,
    pub nhg_id: u32_,
    pub upkeep_dw: delayed_work,
    pub uw_nh_entries: list_head,
    pub unbalanced_since: ::aya_bpf::cty::c_ulong,
    pub idle_timer: u32_,
    pub unbalanced_timer: u32_,
    pub num_nh_buckets: u16_,
    pub nh_buckets: __IncompleteArrayField<nh_res_bucket>,
}
#[repr(C)]
pub struct nh_group {
    pub spare: *mut nh_group,
    pub num_nh: u16_,
    pub is_multipath: bool_,
    pub hash_threshold: bool_,
    pub resilient: bool_,
    pub fdb_nh: bool_,
    pub has_v4: bool_,
    pub res_table: *mut nh_res_table,
    pub nh_entries: __IncompleteArrayField<nh_grp_entry>,
}
pub type sci_t = u64_;
pub type ssci_t = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union salt {
    pub __bindgen_anon_1: salt__bindgen_ty_1,
    pub bytes: [u8_; 12usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct salt__bindgen_ty_1 {
    pub ssci: u32_,
    pub pn: u64_,
}
pub type salt_t = salt;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pn {
    pub __bindgen_anon_1: pn__bindgen_ty_1,
    pub full64: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pn__bindgen_ty_1 {
    pub lower: u32_,
    pub upper: u32_,
}
pub type pn_t = pn;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_key {
    pub id: [u8_; 16usize],
    pub tfm: *mut crypto_aead,
    pub salt: salt_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_rx_sc_stats {
    pub InOctetsValidated: __u64,
    pub InOctetsDecrypted: __u64,
    pub InPktsUnchecked: __u64,
    pub InPktsDelayed: __u64,
    pub InPktsOK: __u64,
    pub InPktsInvalid: __u64,
    pub InPktsLate: __u64,
    pub InPktsNotValid: __u64,
    pub InPktsNotUsingSA: __u64,
    pub InPktsUnusedSA: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_rx_sa_stats {
    pub InPktsOK: __u32,
    pub InPktsInvalid: __u32,
    pub InPktsNotValid: __u32,
    pub InPktsNotUsingSA: __u32,
    pub InPktsUnusedSA: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_tx_sa_stats {
    pub OutPktsProtected: __u32,
    pub OutPktsEncrypted: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_tx_sc_stats {
    pub OutPktsProtected: __u64,
    pub OutPktsEncrypted: __u64,
    pub OutOctetsProtected: __u64,
    pub OutOctetsEncrypted: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_dev_stats {
    pub OutPktsUntagged: __u64,
    pub InPktsUntagged: __u64,
    pub OutPktsTooLong: __u64,
    pub InPktsNoTag: __u64,
    pub InPktsBadTag: __u64,
    pub InPktsUnknownSCI: __u64,
    pub InPktsNoSCI: __u64,
    pub InPktsOverrun: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_rx_sa {
    pub key: macsec_key,
    pub ssci: ssci_t,
    pub lock: spinlock_t,
    pub __bindgen_anon_1: macsec_rx_sa__bindgen_ty_1,
    pub refcnt: refcount_t,
    pub active: bool_,
    pub stats: *mut macsec_rx_sa_stats,
    pub sc: *mut macsec_rx_sc,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union macsec_rx_sa__bindgen_ty_1 {
    pub next_pn_halves: pn_t,
    pub next_pn: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_rx_sc {
    pub next: *mut macsec_rx_sc,
    pub sci: sci_t,
    pub active: bool_,
    pub sa: [*mut macsec_rx_sa; 4usize],
    pub stats: *mut pcpu_rx_sc_stats,
    pub refcnt: refcount_t,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_rx_sc_stats {
    pub stats: macsec_rx_sc_stats,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_tx_sc_stats {
    pub stats: macsec_tx_sc_stats,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_tx_sa {
    pub key: macsec_key,
    pub ssci: ssci_t,
    pub lock: spinlock_t,
    pub __bindgen_anon_1: macsec_tx_sa__bindgen_ty_1,
    pub refcnt: refcount_t,
    pub active: bool_,
    pub stats: *mut macsec_tx_sa_stats,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union macsec_tx_sa__bindgen_ty_1 {
    pub next_pn_halves: pn_t,
    pub next_pn: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_tx_sc {
    pub active: bool_,
    pub encoding_sa: u8_,
    pub encrypt: bool_,
    pub send_sci: bool_,
    pub end_station: bool_,
    pub scb: bool_,
    pub sa: [*mut macsec_tx_sa; 4usize],
    pub stats: *mut pcpu_tx_sc_stats,
    pub md_dst: *mut metadata_dst,
}
pub mod metadata_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const METADATA_IP_TUNNEL: Type = 0;
    pub const METADATA_HW_PORT_MUX: Type = 1;
    pub const METADATA_MACSEC: Type = 2;
    pub const METADATA_XFRM: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_port_info {
    pub lower_dev: *mut net_device,
    pub port_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_info {
    pub sci: sci_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_md_info {
    pub if_id: u32_,
    pub link: ::aya_bpf::cty::c_int,
    pub dst_orig: *mut dst_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct metadata_dst {
    pub dst: dst_entry,
    pub type_: metadata_type::Type,
    pub u: metadata_dst__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union metadata_dst__bindgen_ty_1 {
    pub tun_info: ip_tunnel_info,
    pub port_info: hw_port_info,
    pub macsec_info: macsec_info,
    pub xfrm_info: xfrm_md_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct macsec_secy {
    pub netdev: *mut net_device,
    pub n_rx_sc: ::aya_bpf::cty::c_uint,
    pub sci: sci_t,
    pub key_len: u16_,
    pub icv_len: u16_,
    pub validate_frames: macsec_validation_type::Type,
    pub xpn: bool_,
    pub operational: bool_,
    pub protect_frames: bool_,
    pub replay_protect: bool_,
    pub replay_window: u32_,
    pub tx_sc: macsec_tx_sc,
    pub rx_sc: *mut macsec_rx_sc,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_context {
    pub __bindgen_anon_1: macsec_context__bindgen_ty_1,
    pub offload: macsec_offload::Type,
    pub secy: *mut macsec_secy,
    pub rx_sc: *mut macsec_rx_sc,
    pub sa: macsec_context__bindgen_ty_2,
    pub stats: macsec_context__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union macsec_context__bindgen_ty_1 {
    pub netdev: *mut net_device,
    pub phydev: *mut phy_device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_context__bindgen_ty_2 {
    pub assoc_num: ::aya_bpf::cty::c_uchar,
    pub key: [u8_; 128usize],
    pub __bindgen_anon_1: macsec_context__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union macsec_context__bindgen_ty_2__bindgen_ty_1 {
    pub rx_sa: *mut macsec_rx_sa,
    pub tx_sa: *mut macsec_tx_sa,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union macsec_context__bindgen_ty_3 {
    pub tx_sc_stats: *mut macsec_tx_sc_stats,
    pub tx_sa_stats: *mut macsec_tx_sa_stats,
    pub rx_sc_stats: *mut macsec_rx_sc_stats,
    pub rx_sa_stats: *mut macsec_rx_sa_stats,
    pub dev_stats: *mut macsec_dev_stats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_type {
    pub owner: *mut module,
    pub proto: u8_,
    pub flags: u8_,
    pub init_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state)>,
    pub input: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub reject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: *const flowi,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xfrm_type_offload {
    pub owner: *mut module,
    pub proto: u8_,
    pub encap:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff)>,
    pub input_tail: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut xfrm_state, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub xmit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xfrm_state,
            arg2: *mut sk_buff,
            arg3: netdev_features_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_ifaddr {
    pub hash: hlist_node,
    pub ifa_next: *mut in_ifaddr,
    pub ifa_dev: *mut in_device,
    pub callback_head: callback_head,
    pub ifa_local: __be32,
    pub ifa_address: __be32,
    pub ifa_mask: __be32,
    pub ifa_rt_priority: __u32,
    pub ifa_broadcast: __be32,
    pub ifa_scope: ::aya_bpf::cty::c_uchar,
    pub ifa_prefixlen: ::aya_bpf::cty::c_uchar,
    pub ifa_proto: ::aya_bpf::cty::c_uchar,
    pub ifa_flags: __u32,
    pub ifa_label: [::aya_bpf::cty::c_char; 16usize],
    pub ifa_valid_lft: __u32,
    pub ifa_preferred_lft: __u32,
    pub ifa_cstamp: ::aya_bpf::cty::c_ulong,
    pub ifa_tstamp: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_info {
    pub type_: ::aya_bpf::cty::c_ushort,
    pub sa_family: sa_family_t,
    pub port: __be16,
    pub hw_priv: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udp_tunnel_nic_shared {
    pub udp_tunnel_nic_info: *mut udp_tunnel_nic,
    pub devices: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_hashinfo {
    pub ehash: *mut inet_ehash_bucket,
    pub ehash_locks: *mut spinlock_t,
    pub ehash_mask: ::aya_bpf::cty::c_uint,
    pub ehash_locks_mask: ::aya_bpf::cty::c_uint,
    pub bind_bucket_cachep: *mut kmem_cache,
    pub bhash: *mut inet_bind_hashbucket,
    pub bind2_bucket_cachep: *mut kmem_cache,
    pub bhash2: *mut inet_bind_hashbucket,
    pub bhash_size: ::aya_bpf::cty::c_uint,
    pub lhash2_mask: ::aya_bpf::cty::c_uint,
    pub lhash2: *mut inet_listen_hashbucket,
    pub pernet: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_fastopen_context {
    pub key: [siphash_key_t; 2usize],
    pub num: ::aya_bpf::cty::c_int,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack {
    pub use_: refcount_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct sock_reuseport {
    pub rcu: callback_head,
    pub max_socks: u16_,
    pub num_socks: u16_,
    pub num_closed_socks: u16_,
    pub incoming_cpu: u16_,
    pub synq_overflow_ts: ::aya_bpf::cty::c_uint,
    pub reuseport_id: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub prog: *mut bpf_prog,
    pub socks: __IncompleteArrayField<*mut sock>,
}
impl sock_reuseport {
    #[inline]
    pub fn bind_inany(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind_inany(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_conns(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_conns(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bind_inany: ::aya_bpf::cty::c_uint,
        has_conns: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bind_inany: u32 = unsafe { ::core::mem::transmute(bind_inany) };
            bind_inany as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_conns: u32 = unsafe { ::core::mem::transmute(has_conns) };
            has_conns as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inet_ehash_bucket {
    pub chain: hlist_nulls_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind_hashbucket {
    pub lock: spinlock_t,
    pub chain: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_listen_hashbucket {
    pub lock: spinlock_t,
    pub nulls_head: hlist_nulls_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ack_sample {
    pub pkts_acked: u32_,
    pub rtt_us: s32,
    pub in_flight: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rate_sample {
    pub prior_mstamp: u64_,
    pub prior_delivered: u32_,
    pub prior_delivered_ce: u32_,
    pub delivered: s32,
    pub delivered_ce: s32,
    pub interval_us: ::aya_bpf::cty::c_long,
    pub snd_interval_us: u32_,
    pub rcv_interval_us: u32_,
    pub rtt_us: ::aya_bpf::cty::c_long,
    pub losses: ::aya_bpf::cty::c_int,
    pub acked_sacked: u32_,
    pub prior_in_flight: u32_,
    pub last_end_seq: u32_,
    pub is_app_limited: bool_,
    pub is_retrans: bool_,
    pub is_ack_delayed: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: __kernel_sa_family_t,
    pub sin_port: __be16,
    pub sin_addr: in_addr,
    pub __pad: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mc_list {
    pub interface: *mut in_device,
    pub multiaddr: __be32,
    pub sfmode: ::aya_bpf::cty::c_uint,
    pub sources: *mut ip_sf_list,
    pub tomb: *mut ip_sf_list,
    pub sfcount: [::aya_bpf::cty::c_ulong; 2usize],
    pub __bindgen_anon_1: ip_mc_list__bindgen_ty_1,
    pub next_hash: *mut ip_mc_list,
    pub timer: timer_list,
    pub users: ::aya_bpf::cty::c_int,
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub tm_running: ::aya_bpf::cty::c_char,
    pub reporter: ::aya_bpf::cty::c_char,
    pub unsolicit_count: ::aya_bpf::cty::c_char,
    pub loaded: ::aya_bpf::cty::c_char,
    pub gsquery: ::aya_bpf::cty::c_uchar,
    pub crcount: ::aya_bpf::cty::c_uchar,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_mc_list__bindgen_ty_1 {
    pub next: *mut ip_mc_list,
    pub next_rcu: *mut ip_mc_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_sf_list {
    pub sf_next: *mut ip_sf_list,
    pub sf_count: [::aya_bpf::cty::c_ulong; 2usize],
    pub sf_inaddr: __be32,
    pub sf_gsresp: ::aya_bpf::cty::c_uchar,
    pub sf_oldin: ::aya_bpf::cty::c_uchar,
    pub sf_crcount: ::aya_bpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_hashinfo {
    pub lock: spinlock_t,
    pub ht: [hlist_nulls_head; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlan_group {
    pub nr_vlan_devs: ::aya_bpf::cty::c_uint,
    pub hlist: hlist_node,
    pub vlan_devices_arrays: [*mut *mut net_device; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlan_info {
    pub real_dev: *mut net_device,
    pub grp: vlan_group,
    pub vid_list: list_head,
    pub nr_vids: ::aya_bpf::cty::c_uint,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mptcp_mib {
    pub mibs: [::aya_bpf::cty::c_ulong; 52usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mctp_dev {
    pub dev: *mut net_device,
    pub refs: refcount_t,
    pub net: ::aya_bpf::cty::c_uint,
    pub ops: *const mctp_netdev_ops,
    pub addrs: *mut u8_,
    pub num_addrs: usize,
    pub addrs_lock: spinlock_t,
    pub rcu: callback_head,
}
pub type mctp_eid_t = __u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mctp_sk_key {
    pub peer_addr: mctp_eid_t,
    pub local_addr: mctp_eid_t,
    pub tag: __u8,
    pub sk: *mut sock,
    pub hlist: hlist_node,
    pub sklist: hlist_node,
    pub lock: spinlock_t,
    pub refs: refcount_t,
    pub reasm_head: *mut sk_buff,
    pub reasm_tailp: *mut *mut sk_buff,
    pub reasm_dead: bool_,
    pub last_seq: u8_,
    pub valid: bool_,
    pub expiry: ::aya_bpf::cty::c_ulong,
    pub dev_flow_state: ::aya_bpf::cty::c_ulong,
    pub dev: *mut mctp_dev,
    pub manual_alloc: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mctp_netdev_ops {
    pub release_flow:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mctp_dev, arg2: *mut mctp_sk_key)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_delay_info {
    pub lock: raw_spinlock_t,
    pub blkio_start: u64_,
    pub blkio_delay: u64_,
    pub swapin_start: u64_,
    pub swapin_delay: u64_,
    pub blkio_count: u32_,
    pub swapin_count: u32_,
    pub freepages_start: u64_,
    pub freepages_delay: u64_,
    pub thrashing_start: u64_,
    pub thrashing_delay: u64_,
    pub compact_start: u64_,
    pub compact_delay: u64_,
    pub wpcopy_start: u64_,
    pub wpcopy_delay: u64_,
    pub freepages_count: u32_,
    pub thrashing_count: u32_,
    pub compact_count: u32_,
    pub wpcopy_count: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub tree_entry: rb_node,
    pub pi_tree_entry: rb_node,
    pub task: *mut task_struct,
    pub lock: *mut rt_mutex_base,
    pub wake_state: ::aya_bpf::cty::c_uint,
    pub prio: ::aya_bpf::cty::c_int,
    pub deadline: u64_,
    pub ww_ctx: *mut ww_acquire_ctx,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list {
    pub next: *mut robust_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    pub list: robust_list,
    pub futex_offset: ::aya_bpf::cty::c_long,
    pub list_op_pending: *mut robust_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union futex_key {
    pub shared: futex_key__bindgen_ty_1,
    pub private: futex_key__bindgen_ty_2,
    pub both: futex_key__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_key__bindgen_ty_1 {
    pub i_seq: u64_,
    pub pgoff: ::aya_bpf::cty::c_ulong,
    pub offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_key__bindgen_ty_2 {
    pub __bindgen_anon_1: futex_key__bindgen_ty_2__bindgen_ty_1,
    pub address: ::aya_bpf::cty::c_ulong,
    pub offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union futex_key__bindgen_ty_2__bindgen_ty_1 {
    pub mm: *mut mm_struct,
    pub __tmp: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_key__bindgen_ty_3 {
    pub ptr: u64_,
    pub word: ::aya_bpf::cty::c_ulong,
    pub offset: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_pi_state {
    pub list: list_head,
    pub pi_mutex: rt_mutex_base,
    pub owner: *mut task_struct,
    pub refcount: refcount_t,
    pub key: futex_key,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_aux_data {
    pub next: *mut audit_aux_data,
    pub type_: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_tree_refs {
    pub next: *mut audit_tree_refs,
    pub c: [*mut audit_chunk; 31usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_idmap {
    pub owner: *mut user_namespace,
    pub count: refcount_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    pub f_type: ::aya_bpf::cty::c_long,
    pub f_bsize: ::aya_bpf::cty::c_long,
    pub f_blocks: u64_,
    pub f_bfree: u64_,
    pub f_bavail: u64_,
    pub f_files: u64_,
    pub f_ffree: u64_,
    pub f_fsid: __kernel_fsid_t,
    pub f_namelen: ::aya_bpf::cty::c_long,
    pub f_frsize: ::aya_bpf::cty::c_long,
    pub f_flags: ::aya_bpf::cty::c_long,
    pub f_spare: [::aya_bpf::cty::c_long; 4usize],
}
#[repr(C)]
pub struct fid {
    pub __bindgen_anon_1: fid__bindgen_ty_1,
}
#[repr(C)]
pub struct fid__bindgen_ty_1 {
    pub i32_: __BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_1>,
    pub udf: __BindgenUnionField<fid__bindgen_ty_1__bindgen_ty_2>,
    pub raw: __BindgenUnionField<[__u32; 0usize]>,
    pub bindgen_union_field: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fid__bindgen_ty_1__bindgen_ty_1 {
    pub ino: u32_,
    pub gen: u32_,
    pub parent_ino: u32_,
    pub parent_gen: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fid__bindgen_ty_1__bindgen_ty_2 {
    pub block: u32_,
    pub partref: u16_,
    pub parent_partref: u16_,
    pub generation: u32_,
    pub parent_block: u32_,
    pub parent_generation: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eventfd_ctx {
    pub kref: kref,
    pub wqh: wait_queue_head_t,
    pub count: __u64,
    pub flags: ::aya_bpf::cty::c_uint,
    pub id: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_prepared_key {
    pub tfm: *mut crypto_skcipher,
    pub blk_key: *mut blk_crypto_key,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_info {
    pub ci_enc_key: fscrypt_prepared_key,
    pub ci_owns_key: bool_,
    pub ci_inlinecrypt: bool_,
    pub ci_mode: *mut fscrypt_mode,
    pub ci_inode: *mut inode,
    pub ci_master_key: *mut fscrypt_master_key,
    pub ci_master_key_link: list_head,
    pub ci_direct_key: *mut fscrypt_direct_key,
    pub ci_dirhash_key: siphash_key_t,
    pub ci_dirhash_key_initialized: bool_,
    pub ci_policy: fscrypt_policy,
    pub ci_nonce: [u8_; 16usize],
    pub ci_hashed_ino: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_key_specifier {
    pub type_: __u32,
    pub __reserved: __u32,
    pub u: fscrypt_key_specifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_key_specifier__bindgen_ty_1 {
    pub __reserved: [__u8; 32usize],
    pub descriptor: [__u8; 8usize],
    pub identifier: [__u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_mode {
    pub friendly_name: *const ::aya_bpf::cty::c_char,
    pub cipher_str: *const ::aya_bpf::cty::c_char,
    pub keysize: ::aya_bpf::cty::c_int,
    pub security_strength: ::aya_bpf::cty::c_int,
    pub ivsize: ::aya_bpf::cty::c_int,
    pub logged_cryptoapi_impl: ::aya_bpf::cty::c_int,
    pub logged_blk_crypto_native: ::aya_bpf::cty::c_int,
    pub logged_blk_crypto_fallback: ::aya_bpf::cty::c_int,
    pub blk_crypto_mode: blk_crypto_mode_num::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_hkdf {
    pub hmac_tfm: *mut crypto_shash,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_master_key_secret {
    pub hkdf: fscrypt_hkdf,
    pub size: u32_,
    pub raw: [u8_; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_master_key {
    pub mk_node: hlist_node,
    pub mk_sem: rw_semaphore,
    pub mk_active_refs: refcount_t,
    pub mk_struct_refs: refcount_t,
    pub mk_rcu_head: callback_head,
    pub mk_secret: fscrypt_master_key_secret,
    pub mk_spec: fscrypt_key_specifier,
    pub mk_users: *mut key,
    pub mk_decrypted_inodes: list_head,
    pub mk_decrypted_inodes_lock: spinlock_t,
    pub mk_direct_keys: [fscrypt_prepared_key; 11usize],
    pub mk_iv_ino_lblk_64_keys: [fscrypt_prepared_key; 11usize],
    pub mk_iv_ino_lblk_32_keys: [fscrypt_prepared_key; 11usize],
    pub mk_ino_hash_key: siphash_key_t,
    pub mk_ino_hash_key_initialized: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtattr {
    pub rta_len: ::aya_bpf::cty::c_ushort,
    pub rta_type: ::aya_bpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disk_stats {
    pub nsecs: [u64_; 4usize],
    pub sectors: [::aya_bpf::cty::c_ulong; 4usize],
    pub ios: [::aya_bpf::cty::c_ulong; 4usize],
    pub merges: [::aya_bpf::cty::c_ulong; 4usize],
    pub io_ticks: ::aya_bpf::cty::c_ulong,
    pub in_flight: [local_t; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct badblocks {
    pub dev: *mut device,
    pub count: ::aya_bpf::cty::c_int,
    pub unacked_exist: ::aya_bpf::cty::c_int,
    pub shift: ::aya_bpf::cty::c_int,
    pub page: *mut u64_,
    pub changed: ::aya_bpf::cty::c_int,
    pub lock: seqlock_t,
    pub sector: sector_t,
    pub size: sector_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iopf_device_param {
    pub dev: *mut device,
    pub queue: *mut iopf_queue,
    pub queue_list: list_head,
    pub partial: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iopf_queue {
    pub wq: *mut workqueue_struct,
    pub devices: list_head,
    pub lock: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_psock_progs {
    pub msg_parser: *mut bpf_prog,
    pub stream_parser: *mut bpf_prog,
    pub stream_verdict: *mut bpf_prog,
    pub skb_verdict: *mut bpf_prog,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strp_stats {
    pub msgs: ::aya_bpf::cty::c_ulonglong,
    pub bytes: ::aya_bpf::cty::c_ulonglong,
    pub mem_fail: ::aya_bpf::cty::c_uint,
    pub need_more_hdr: ::aya_bpf::cty::c_uint,
    pub msg_too_big: ::aya_bpf::cty::c_uint,
    pub msg_timeouts: ::aya_bpf::cty::c_uint,
    pub bad_hdr_len: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strp_callbacks {
    pub parse_msg: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut strparser, arg2: *mut sk_buff) -> ::aya_bpf::cty::c_int,
    >,
    pub rcv_msg:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut strparser, arg2: *mut sk_buff)>,
    pub read_sock_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut strparser,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub abort_parser: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut strparser, arg2: ::aya_bpf::cty::c_int),
    >,
    pub lock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut strparser)>,
    pub unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *mut strparser)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strparser {
    pub sk: *mut sock,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub skb_nextp: *mut *mut sk_buff,
    pub skb_head: *mut sk_buff,
    pub need_bytes: ::aya_bpf::cty::c_uint,
    pub msg_timer_work: delayed_work,
    pub work: work_struct,
    pub stats: strp_stats,
    pub cb: strp_callbacks,
}
impl strparser {
    #[inline]
    pub fn stopped(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stopped(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn paused(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_paused(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aborted(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aborted(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interrupted(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_interrupted(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unrecov_intr(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unrecov_intr(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        stopped: u32_,
        paused: u32_,
        aborted: u32_,
        interrupted: u32_,
        unrecov_intr: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let stopped: u32 = unsafe { ::core::mem::transmute(stopped) };
            stopped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let paused: u32 = unsafe { ::core::mem::transmute(paused) };
            paused as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let aborted: u32 = unsafe { ::core::mem::transmute(aborted) };
            aborted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let interrupted: u32 = unsafe { ::core::mem::transmute(interrupted) };
            interrupted as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let unrecov_intr: u32 = unsafe { ::core::mem::transmute(unrecov_intr) };
            unrecov_intr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_psock_work_state {
    pub skb: *mut sk_buff,
    pub len: u32_,
    pub off: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_psock {
    pub sk: *mut sock,
    pub sk_redir: *mut sock,
    pub apply_bytes: u32_,
    pub cork_bytes: u32_,
    pub eval: u32_,
    pub redir_ingress: bool_,
    pub cork: *mut sk_msg,
    pub progs: sk_psock_progs,
    pub strp: strparser,
    pub ingress_skb: sk_buff_head,
    pub ingress_msg: list_head,
    pub ingress_lock: spinlock_t,
    pub state: ::aya_bpf::cty::c_ulong,
    pub link: list_head,
    pub link_lock: spinlock_t,
    pub refcnt: refcount_t,
    pub saved_unhash: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_close:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_long)>,
    pub saved_write_space: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_data_ready: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub psock_update_sk_prot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sock,
            arg2: *mut sk_psock,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sk_proto: *mut proto,
    pub work_mutex: mutex,
    pub work_state: sk_psock_work_state,
    pub work: work_struct,
    pub rwork: rcu_work,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_msg_sg {
    pub start: u32_,
    pub curr: u32_,
    pub end: u32_,
    pub size: u32_,
    pub copybreak: u32_,
    pub copy: [::aya_bpf::cty::c_ulong; 1usize],
    pub data: [scatterlist; 19usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_msg {
    pub sg: sk_msg_sg,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub data_end: *mut ::aya_bpf::cty::c_void,
    pub apply_bytes: u32_,
    pub cork_bytes: u32_,
    pub flags: u32_,
    pub skb: *mut sk_buff,
    pub sk_redir: *mut sock,
    pub sk: *mut sock,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_crypto_info {
    pub version: __u16,
    pub cipher_type: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_aes_gcm_128 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf::cty::c_uchar; 8usize],
    pub key: [::aya_bpf::cty::c_uchar; 16usize],
    pub salt: [::aya_bpf::cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_aes_gcm_256 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf::cty::c_uchar; 8usize],
    pub key: [::aya_bpf::cty::c_uchar; 32usize],
    pub salt: [::aya_bpf::cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct tls12_crypto_info_chacha20_poly1305 {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf::cty::c_uchar; 12usize],
    pub key: [::aya_bpf::cty::c_uchar; 32usize],
    pub salt: __IncompleteArrayField<::aya_bpf::cty::c_uchar>,
    pub rec_seq: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_sm4_gcm {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf::cty::c_uchar; 8usize],
    pub key: [::aya_bpf::cty::c_uchar; 16usize],
    pub salt: [::aya_bpf::cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls12_crypto_info_sm4_ccm {
    pub info: tls_crypto_info,
    pub iv: [::aya_bpf::cty::c_uchar; 8usize],
    pub key: [::aya_bpf::cty::c_uchar; 16usize],
    pub salt: [::aya_bpf::cty::c_uchar; 4usize],
    pub rec_seq: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_prot_info {
    pub version: u16_,
    pub cipher_type: u16_,
    pub prepend_size: u16_,
    pub tag_size: u16_,
    pub overhead_size: u16_,
    pub iv_size: u16_,
    pub salt_size: u16_,
    pub rec_seq_size: u16_,
    pub aad_size: u16_,
    pub tail_size: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_context {
    pub iv: *mut ::aya_bpf::cty::c_char,
    pub rec_seq: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
pub struct tls_crypto_context {
    pub info: __BindgenUnionField<tls_crypto_info>,
    pub __bindgen_anon_1: __BindgenUnionField<tls_crypto_context__bindgen_ty_1>,
    pub bindgen_union_field: [u16; 28usize],
}
#[repr(C)]
pub struct tls_crypto_context__bindgen_ty_1 {
    pub aes_gcm_128: __BindgenUnionField<tls12_crypto_info_aes_gcm_128>,
    pub aes_gcm_256: __BindgenUnionField<tls12_crypto_info_aes_gcm_256>,
    pub chacha20_poly1305: __BindgenUnionField<tls12_crypto_info_chacha20_poly1305>,
    pub sm4_gcm: __BindgenUnionField<tls12_crypto_info_sm4_gcm>,
    pub sm4_ccm: __BindgenUnionField<tls12_crypto_info_sm4_ccm>,
    pub bindgen_union_field: [u16; 28usize],
}
#[repr(C)]
pub struct tls_context {
    pub prot_info: tls_prot_info,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub push_pending_record: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
    >,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub priv_ctx_tx: *mut ::aya_bpf::cty::c_void,
    pub priv_ctx_rx: *mut ::aya_bpf::cty::c_void,
    pub netdev: *mut net_device,
    pub tx: cipher_context,
    pub rx: cipher_context,
    pub partially_sent_record: *mut scatterlist,
    pub partially_sent_offset: u16_,
    pub in_tcp_sendpages: bool_,
    pub pending_open_record_frags: bool_,
    pub tx_lock: mutex,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub sk_proto: *mut proto,
    pub sk: *mut sock,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub crypto_send: tls_crypto_context,
    pub crypto_recv: tls_crypto_context,
    pub list: list_head,
    pub refcount: refcount_t,
    pub rcu: callback_head,
}
impl tls_context {
    #[inline]
    pub fn tx_conf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_tx_conf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_conf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_rx_conf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn zerocopy_sendfile(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zerocopy_sendfile(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_no_pad(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rx_no_pad(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tx_conf: u8_,
        rx_conf: u8_,
        zerocopy_sendfile: u8_,
        rx_no_pad: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tx_conf: u8 = unsafe { ::core::mem::transmute(tx_conf) };
            tx_conf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let rx_conf: u8 = unsafe { ::core::mem::transmute(rx_conf) };
            rx_conf as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let zerocopy_sendfile: u8 = unsafe { ::core::mem::transmute(zerocopy_sendfile) };
            zerocopy_sendfile as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let rx_no_pad: u8 = unsafe { ::core::mem::transmute(rx_no_pad) };
            rx_no_pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_id_dtor_kfunc {
    pub btf_id: u32_,
    pub kfunc_btf_id: u32_,
}
pub mod ethtool_podl_pse_admin_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN: Type = 1;
    pub const ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED: Type = 2;
    pub const ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED: Type = 3;
}
pub mod ethtool_podl_pse_pw_d_status {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN: Type = 1;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED: Type = 2;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING: Type = 3;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING: Type = 4;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP: Type = 5;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE: Type = 6;
    pub const ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR: Type = 7;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pse_control_config {
    pub admin_cotrol: ethtool_podl_pse_admin_state::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pse_control_status {
    pub podl_admin_state: ethtool_podl_pse_admin_state::Type,
    pub podl_pw_status: ethtool_podl_pse_pw_d_status::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uncached_list {
    pub lock: spinlock_t,
    pub head: list_head,
    pub quarantine: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seg6_pernet_data {
    pub lock: mutex,
    pub tun_src: *mut in6_addr,
    pub hmac_infos: rhashtable,
}
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_tcp_state {
    pub td_end: u_int32_t,
    pub td_maxend: u_int32_t,
    pub td_maxwin: u_int32_t,
    pub td_maxack: u_int32_t,
    pub td_scale: u_int8_t,
    pub flags: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_tcp {
    pub seen: [ip_ct_tcp_state; 2usize],
    pub state: u_int8_t,
    pub last_dir: u_int8_t,
    pub retrans: u_int8_t,
    pub last_index: u_int8_t,
    pub last_seq: u_int32_t,
    pub last_ack: u_int32_t,
    pub last_end: u_int32_t,
    pub last_win: u_int16_t,
    pub last_wscale: u_int8_t,
    pub last_flags: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_man_proto {
    pub all: __be16,
    pub tcp: nf_conntrack_man_proto__bindgen_ty_1,
    pub udp: nf_conntrack_man_proto__bindgen_ty_2,
    pub icmp: nf_conntrack_man_proto__bindgen_ty_3,
    pub dccp: nf_conntrack_man_proto__bindgen_ty_4,
    pub sctp: nf_conntrack_man_proto__bindgen_ty_5,
    pub gre: nf_conntrack_man_proto__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_1 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_2 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_3 {
    pub id: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_4 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_5 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_6 {
    pub key: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_dccp {
    pub role: [u_int8_t; 2usize],
    pub state: u_int8_t,
    pub last_pkt: u_int8_t,
    pub last_dir: u_int8_t,
    pub handshake_seq: u_int64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_ct_sctp {
    pub state: sctp_conntrack::Type,
    pub vtag: [__be32; 2usize],
    pub last_dir: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_gre {
    pub stream_timeout: ::aya_bpf::cty::c_uint,
    pub timeout: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_zone {
    pub id: u16_,
    pub flags: u8_,
    pub dir: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_man {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_man_proto,
    pub l3num: u_int16_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple {
    pub src: nf_conntrack_man,
    pub dst: nf_conntrack_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1 {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1,
    pub protonum: u_int8_t,
    pub dir: u_int8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub all: __be16,
    pub tcp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub udp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub icmp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub dccp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4,
    pub sctp: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5,
    pub gre: nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub type_: u_int8_t,
    pub code: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_5 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_tuple__bindgen_ty_1__bindgen_ty_1__bindgen_ty_6 {
    pub key: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_hash {
    pub hnnode: hlist_nulls_node,
    pub tuple: nf_conntrack_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_udp {
    pub stream_ts: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_proto {
    pub dccp: nf_ct_dccp,
    pub sctp: ip_ct_sctp,
    pub tcp: ip_ct_tcp,
    pub udp: nf_ct_udp,
    pub gre: nf_ct_gre,
    pub tmpl_padto: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conn {
    pub ct_general: nf_conntrack,
    pub lock: spinlock_t,
    pub timeout: u32_,
    pub zone: nf_conntrack_zone,
    pub tuplehash: [nf_conntrack_tuple_hash; 2usize],
    pub status: ::aya_bpf::cty::c_ulong,
    pub ct_net: possible_net_t,
    pub nat_bysource: hlist_node,
    pub __nfct_init_offset: nf_conn__bindgen_ty_1,
    pub master: *mut nf_conn,
    pub mark: u_int32_t,
    pub secmark: u_int32_t,
    pub ext: *mut nf_ct_ext,
    pub proto: nf_conntrack_proto,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conn__bindgen_ty_1 {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uevent_sock {
    pub list: list_head,
    pub sk: *mut sock,
}
#[repr(C)]
pub struct workqueue_struct {
    pub pwqs: list_head,
    pub list: list_head,
    pub mutex: mutex,
    pub work_color: ::aya_bpf::cty::c_int,
    pub flush_color: ::aya_bpf::cty::c_int,
    pub nr_pwqs_to_flush: atomic_t,
    pub first_flusher: *mut wq_flusher,
    pub flusher_queue: list_head,
    pub flusher_overflow: list_head,
    pub maydays: list_head,
    pub rescuer: *mut worker,
    pub nr_drainers: ::aya_bpf::cty::c_int,
    pub saved_max_active: ::aya_bpf::cty::c_int,
    pub unbound_attrs: *mut workqueue_attrs,
    pub dfl_pwq: *mut pool_workqueue,
    pub wq_dev: *mut wq_device,
    pub name: [::aya_bpf::cty::c_char; 24usize],
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
    pub flags: ::aya_bpf::cty::c_uint,
    pub cpu_pwqs: *mut pool_workqueue,
    pub numa_pwq_tbl: __IncompleteArrayField<*mut pool_workqueue>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_attrs {
    pub nice: ::aya_bpf::cty::c_int,
    pub cpumask: cpumask_var_t,
    pub no_numa: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker {
    pub __bindgen_anon_1: worker__bindgen_ty_1,
    pub current_work: *mut work_struct,
    pub current_func: work_func_t,
    pub current_pwq: *mut pool_workqueue,
    pub current_color: ::aya_bpf::cty::c_uint,
    pub scheduled: list_head,
    pub task: *mut task_struct,
    pub pool: *mut worker_pool,
    pub node: list_head,
    pub last_active: ::aya_bpf::cty::c_ulong,
    pub flags: ::aya_bpf::cty::c_uint,
    pub id: ::aya_bpf::cty::c_int,
    pub sleeping: ::aya_bpf::cty::c_int,
    pub desc: [::aya_bpf::cty::c_char; 24usize],
    pub rescue_wq: *mut workqueue_struct,
    pub last_func: work_func_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union worker__bindgen_ty_1 {
    pub entry: list_head,
    pub hentry: hlist_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_workqueue {
    pub pool: *mut worker_pool,
    pub wq: *mut workqueue_struct,
    pub work_color: ::aya_bpf::cty::c_int,
    pub flush_color: ::aya_bpf::cty::c_int,
    pub refcnt: ::aya_bpf::cty::c_int,
    pub nr_in_flight: [::aya_bpf::cty::c_int; 16usize],
    pub nr_active: ::aya_bpf::cty::c_int,
    pub max_active: ::aya_bpf::cty::c_int,
    pub inactive_works: list_head,
    pub pwqs_node: list_head,
    pub mayday_node: list_head,
    pub unbound_release_work: work_struct,
    pub rcu: callback_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker_pool {
    pub lock: raw_spinlock_t,
    pub cpu: ::aya_bpf::cty::c_int,
    pub node: ::aya_bpf::cty::c_int,
    pub id: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_uint,
    pub watchdog_ts: ::aya_bpf::cty::c_ulong,
    pub nr_running: ::aya_bpf::cty::c_int,
    pub worklist: list_head,
    pub nr_workers: ::aya_bpf::cty::c_int,
    pub nr_idle: ::aya_bpf::cty::c_int,
    pub idle_list: list_head,
    pub idle_timer: timer_list,
    pub mayday_timer: timer_list,
    pub busy_hash: [hlist_head; 64usize],
    pub manager: *mut worker,
    pub workers: list_head,
    pub detach_completion: *mut completion,
    pub worker_ida: ida,
    pub attrs: *mut workqueue_attrs,
    pub hash_node: hlist_node,
    pub refcnt: ::aya_bpf::cty::c_int,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wq_flusher {
    pub list: list_head,
    pub flush_color: ::aya_bpf::cty::c_int,
    pub done: completion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wq_device {
    pub wq: *mut workqueue_struct,
    pub dev: device,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_stop_done {
    pub nr_todo: atomic_t,
    pub ret: ::aya_bpf::cty::c_int,
    pub completion: completion,
}
#[repr(C)]
#[derive(Debug)]
pub struct audit_tree {
    pub count: refcount_t,
    pub goner: ::aya_bpf::cty::c_int,
    pub root: *mut audit_chunk,
    pub chunks: list_head,
    pub rules: list_head,
    pub list: list_head,
    pub same_root: list_head,
    pub head: callback_head,
    pub pathname: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_node {
    pub list: list_head,
    pub owner: *mut audit_tree,
    pub index: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug)]
pub struct audit_chunk {
    pub hash: list_head,
    pub key: ::aya_bpf::cty::c_ulong,
    pub mark: *mut fsnotify_mark,
    pub trees: list_head,
    pub count: ::aya_bpf::cty::c_int,
    pub refs: atomic_long_t,
    pub head: callback_head,
    pub owners: __IncompleteArrayField<audit_node>,
}
#[repr(C)]
#[derive(Debug)]
pub struct btf_struct_metas {
    pub cnt: u32_,
    pub types: __IncompleteArrayField<btf_struct_meta>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct btf_kfunc_set_tab {
    pub sets: [*mut btf_id_set8; 7usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct btf_id_dtor_kfunc_tab {
    pub cnt: u32_,
    pub dtors: __IncompleteArrayField<btf_id_dtor_kfunc>,
}
#[repr(C)]
pub struct perf_buffer {
    pub refcount: refcount_t,
    pub callback_head: callback_head,
    pub nr_pages: ::aya_bpf::cty::c_int,
    pub overwrite: ::aya_bpf::cty::c_int,
    pub paused: ::aya_bpf::cty::c_int,
    pub poll: atomic_t,
    pub head: local_t,
    pub nest: ::aya_bpf::cty::c_uint,
    pub events: local_t,
    pub wakeup: local_t,
    pub lost: local_t,
    pub watermark: ::aya_bpf::cty::c_long,
    pub aux_watermark: ::aya_bpf::cty::c_long,
    pub event_lock: spinlock_t,
    pub event_list: list_head,
    pub mmap_count: atomic_t,
    pub mmap_locked: ::aya_bpf::cty::c_ulong,
    pub mmap_user: *mut user_struct,
    pub aux_head: ::aya_bpf::cty::c_long,
    pub aux_nest: ::aya_bpf::cty::c_uint,
    pub aux_wakeup: ::aya_bpf::cty::c_long,
    pub aux_pgoff: ::aya_bpf::cty::c_ulong,
    pub aux_nr_pages: ::aya_bpf::cty::c_int,
    pub aux_overwrite: ::aya_bpf::cty::c_int,
    pub aux_mmap_count: atomic_t,
    pub aux_mmap_locked: ::aya_bpf::cty::c_ulong,
    pub free_aux: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub aux_refcount: refcount_t,
    pub aux_in_sampling: ::aya_bpf::cty::c_int,
    pub aux_pages: *mut *mut ::aya_bpf::cty::c_void,
    pub aux_priv: *mut ::aya_bpf::cty::c_void,
    pub user_page: *mut perf_event_mmap_page,
    pub data_pages: __IncompleteArrayField<*mut ::aya_bpf::cty::c_void>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl_entry {
    pub e_tag: ::aya_bpf::cty::c_short,
    pub e_perm: ::aya_bpf::cty::c_ushort,
    pub __bindgen_anon_1: posix_acl_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union posix_acl_entry__bindgen_ty_1 {
    pub e_uid: kuid_t,
    pub e_gid: kgid_t,
}
#[repr(C)]
pub struct posix_acl {
    pub a_refcount: refcount_t,
    pub a_rcu: callback_head,
    pub a_count: ::aya_bpf::cty::c_uint,
    pub a_entries: __IncompleteArrayField<posix_acl_entry>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_tier {
    pub list: list_head,
    pub memory_types: list_head,
    pub adistance_start: ::aya_bpf::cty::c_int,
    pub dev: device,
    pub lower_tier_mask: nodemask_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saved {
    pub link: path,
    pub done: delayed_call,
    pub name: *const ::aya_bpf::cty::c_char,
    pub seq: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameidata {
    pub path: path,
    pub last: qstr,
    pub root: path,
    pub inode: *mut inode,
    pub flags: ::aya_bpf::cty::c_uint,
    pub state: ::aya_bpf::cty::c_uint,
    pub seq: ::aya_bpf::cty::c_uint,
    pub next_seq: ::aya_bpf::cty::c_uint,
    pub m_seq: ::aya_bpf::cty::c_uint,
    pub r_seq: ::aya_bpf::cty::c_uint,
    pub last_type: ::aya_bpf::cty::c_int,
    pub depth: ::aya_bpf::cty::c_uint,
    pub total_link_count: ::aya_bpf::cty::c_int,
    pub stack: *mut saved,
    pub internal: [saved; 2usize],
    pub name: *mut filename,
    pub saved: *mut nameidata,
    pub root_seq: ::aya_bpf::cty::c_uint,
    pub dfd: ::aya_bpf::cty::c_int,
    pub dir_vfsuid: vfsuid_t,
    pub dir_mode: umode_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_keyring {
    pub lock: spinlock_t,
    pub key_hashtable: [hlist_head; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_queue_stats {
    pub callbacks: list_head,
    pub lock: spinlock_t,
    pub accounting: ::aya_bpf::cty::c_int,
}
pub type irq_poll_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut irq_poll, arg2: ::aya_bpf::cty::c_int) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_poll {
    pub list: list_head,
    pub state: ::aya_bpf::cty::c_ulong,
    pub weight: ::aya_bpf::cty::c_int,
    pub poll: irq_poll_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_cgroup {
    pub css: cgroup_subsys_state,
    pub rpools: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdmacg_device {
    pub dev_node: list_head,
    pub rpools: list_head,
    pub name: *mut ::aya_bpf::cty::c_char,
}
pub mod rdma_nl_counter_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_COUNTER_MODE_NONE: Type = 0;
    pub const RDMA_COUNTER_MODE_AUTO: Type = 1;
    pub const RDMA_COUNTER_MODE_MANUAL: Type = 2;
    pub const RDMA_COUNTER_MODE_MAX: Type = 3;
}
pub mod rdma_nl_counter_mask {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_COUNTER_MASK_QP_TYPE: Type = 1;
    pub const RDMA_COUNTER_MASK_PID: Type = 2;
}
pub mod rdma_restrack_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_RESTRACK_PD: Type = 0;
    pub const RDMA_RESTRACK_CQ: Type = 1;
    pub const RDMA_RESTRACK_QP: Type = 2;
    pub const RDMA_RESTRACK_CM_ID: Type = 3;
    pub const RDMA_RESTRACK_MR: Type = 4;
    pub const RDMA_RESTRACK_CTX: Type = 5;
    pub const RDMA_RESTRACK_COUNTER: Type = 6;
    pub const RDMA_RESTRACK_SRQ: Type = 7;
    pub const RDMA_RESTRACK_MAX: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_restrack_entry {
    pub valid: bool_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub kref: kref,
    pub comp: completion,
    pub task: *mut task_struct,
    pub kern_name: *const ::aya_bpf::cty::c_char,
    pub type_: rdma_restrack_type::Type,
    pub user: bool_,
    pub id: u32_,
}
impl rdma_restrack_entry {
    #[inline]
    pub fn no_track(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_track(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(no_track: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_track: u8 = unsafe { ::core::mem::transmute(no_track) };
            no_track as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_link_ops {
    pub list: list_head,
    pub type_: *const ::aya_bpf::cty::c_char,
    pub newlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: *mut net_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auto_mode_param {
    pub qp_type: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_counter_mode {
    pub mode: rdma_nl_counter_mode::Type,
    pub mask: rdma_nl_counter_mask::Type,
    pub param: auto_mode_param,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_port_counter {
    pub mode: rdma_counter_mode,
    pub hstats: *mut rdma_hw_stats,
    pub num_counters: ::aya_bpf::cty::c_uint,
    pub lock: mutex,
}
#[repr(C)]
pub struct rdma_hw_stats {
    pub lock: mutex,
    pub timestamp: ::aya_bpf::cty::c_ulong,
    pub lifespan: ::aya_bpf::cty::c_ulong,
    pub descs: *const rdma_stat_desc,
    pub is_disabled: *mut ::aya_bpf::cty::c_ulong,
    pub num_counters: ::aya_bpf::cty::c_int,
    pub value: __IncompleteArrayField<u64_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_counter {
    pub res: rdma_restrack_entry,
    pub device: *mut ib_device,
    pub id: u32,
    pub kref: kref,
    pub mode: rdma_counter_mode,
    pub lock: mutex,
    pub stats: *mut rdma_hw_stats,
    pub port: u32_,
}
pub mod rdma_driver_id {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_DRIVER_UNKNOWN: Type = 0;
    pub const RDMA_DRIVER_MLX5: Type = 1;
    pub const RDMA_DRIVER_MLX4: Type = 2;
    pub const RDMA_DRIVER_CXGB3: Type = 3;
    pub const RDMA_DRIVER_CXGB4: Type = 4;
    pub const RDMA_DRIVER_MTHCA: Type = 5;
    pub const RDMA_DRIVER_BNXT_RE: Type = 6;
    pub const RDMA_DRIVER_OCRDMA: Type = 7;
    pub const RDMA_DRIVER_NES: Type = 8;
    pub const RDMA_DRIVER_I40IW: Type = 9;
    pub const RDMA_DRIVER_IRDMA: Type = 9;
    pub const RDMA_DRIVER_VMW_PVRDMA: Type = 10;
    pub const RDMA_DRIVER_QEDR: Type = 11;
    pub const RDMA_DRIVER_HNS: Type = 12;
    pub const RDMA_DRIVER_USNIC: Type = 13;
    pub const RDMA_DRIVER_RXE: Type = 14;
    pub const RDMA_DRIVER_HFI1: Type = 15;
    pub const RDMA_DRIVER_QIB: Type = 16;
    pub const RDMA_DRIVER_EFA: Type = 17;
    pub const RDMA_DRIVER_SIW: Type = 18;
    pub const RDMA_DRIVER_ERDMA: Type = 19;
    pub const RDMA_DRIVER_MANA: Type = 20;
}
pub mod ib_cq_notify_flags {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_CQ_SOLICITED: Type = 1;
    pub const IB_CQ_NEXT_COMP: Type = 2;
    pub const IB_CQ_SOLICITED_MASK: Type = 3;
    pub const IB_CQ_REPORT_MISSED_EVENTS: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_mad {
    _unused: [u8; 0],
}
pub mod rdma_link_layer {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_LINK_LAYER_UNSPECIFIED: Type = 0;
    pub const IB_LINK_LAYER_INFINIBAND: Type = 1;
    pub const IB_LINK_LAYER_ETHERNET: Type = 2;
}
pub mod rdma_netdev_t {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_NETDEV_OPA_VNIC: Type = 0;
    pub const RDMA_NETDEV_IPOIB: Type = 1;
}
pub mod ib_srq_attr_mask {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_SRQ_MAX_WR: Type = 1;
    pub const IB_SRQ_LIMIT: Type = 2;
}
pub mod ib_mr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_MR_TYPE_MEM_REG: Type = 0;
    pub const IB_MR_TYPE_SG_GAPS: Type = 1;
    pub const IB_MR_TYPE_DM: Type = 2;
    pub const IB_MR_TYPE_USER: Type = 3;
    pub const IB_MR_TYPE_DMA: Type = 4;
    pub const IB_MR_TYPE_INTEGRITY: Type = 5;
}
pub mod ib_uverbs_advise_mr_advice {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH: Type = 0;
    pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE: Type = 1;
    pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uverbs_attr_bundle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_cm_id {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_cm_id {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_cm_conn_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_device_ops {
    pub owner: *mut module,
    pub driver_id: rdma_driver_id::Type,
    pub uverbs_abi_ver: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub device_group: *const attribute_group,
    pub port_groups: *mut *const attribute_group,
    pub post_send: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *const ib_send_wr,
            arg3: *mut *const ib_send_wr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub post_recv: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *const ib_recv_wr,
            arg3: *mut *const ib_recv_wr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub drain_rq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_qp)>,
    pub drain_sq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_qp)>,
    pub poll_cq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_cq,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ib_wc,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub peek_cq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_cq,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub req_notify_cq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_cq,
            arg2: ib_cq_notify_flags::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub post_srq_recv: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_srq,
            arg2: *const ib_recv_wr,
            arg3: *mut *const ib_recv_wr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub process_mad: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: *const ib_wc,
            arg5: *const ib_grh,
            arg6: *const ib_mad,
            arg7: *mut ib_mad,
            arg8: *mut usize,
            arg9: *mut u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub query_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: *mut ib_device_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_device: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ib_device_modify,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dev_fw_str: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: *mut ::aya_bpf::cty::c_char),
    >,
    pub get_vector_affinity: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: ::aya_bpf::cty::c_int) -> *const cpumask,
    >,
    pub query_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: *mut ib_port_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_port: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ib_port_modify,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_port_immutable: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: *mut ib_port_immutable,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_link_layer: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: u32_) -> rdma_link_layer::Type,
    >,
    pub get_netdev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: u32_) -> *mut net_device,
    >,
    pub alloc_rdma_netdev: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: rdma_netdev_t::Type,
            arg4: *const ::aya_bpf::cty::c_char,
            arg5: ::aya_bpf::cty::c_uchar,
            arg6: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
        ) -> *mut net_device,
    >,
    pub rdma_netdev_get_params: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: rdma_netdev_t::Type,
            arg4: *mut rdma_netdev_alloc_params,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub query_gid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ib_gid,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub add_gid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ib_gid_attr,
            arg2: *mut *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub del_gid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ib_gid_attr,
            arg2: *mut *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub query_pkey: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: u16_,
            arg4: *mut u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_ucontext: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_ucontext, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub dealloc_ucontext: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_ucontext)>,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_ucontext,
            arg2: *mut vm_area_struct,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mmap_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rdma_user_mmap_entry)>,
    pub disassociate_ucontext: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_ucontext)>,
    pub alloc_pd: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_pd, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub dealloc_pd: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_pd, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub create_ah: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_ah,
            arg2: *mut rdma_ah_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create_user_ah: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_ah,
            arg2: *mut rdma_ah_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_ah: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_ah, arg2: *mut rdma_ah_attr) -> ::aya_bpf::cty::c_int,
    >,
    pub query_ah: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_ah, arg2: *mut rdma_ah_attr) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_ah: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_ah, arg2: u32_) -> ::aya_bpf::cty::c_int,
    >,
    pub create_srq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_srq,
            arg2: *mut ib_srq_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_srq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_srq,
            arg2: *mut ib_srq_attr,
            arg3: ib_srq_attr_mask::Type,
            arg4: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub query_srq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_srq, arg2: *mut ib_srq_attr) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_srq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_srq, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub create_qp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_qp_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_qp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_qp_attr,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub query_qp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_qp_attr,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ib_qp_init_attr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_qp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_qp, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub create_cq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_cq,
            arg2: *const ib_cq_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_cq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_cq, arg2: u16_, arg3: u16_) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_cq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_cq, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub resize_cq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_cq,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_dma_mr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_pd, arg2: ::aya_bpf::cty::c_int) -> *mut ib_mr,
    >,
    pub reg_user_mr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_pd,
            arg2: u64_,
            arg3: u64_,
            arg4: u64_,
            arg5: ::aya_bpf::cty::c_int,
            arg6: *mut ib_udata,
        ) -> *mut ib_mr,
    >,
    pub reg_user_mr_dmabuf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_pd,
            arg2: u64_,
            arg3: u64_,
            arg4: u64_,
            arg5: ::aya_bpf::cty::c_int,
            arg6: ::aya_bpf::cty::c_int,
            arg7: *mut ib_udata,
        ) -> *mut ib_mr,
    >,
    pub rereg_user_mr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_mr,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u64_,
            arg4: u64_,
            arg5: u64_,
            arg6: ::aya_bpf::cty::c_int,
            arg7: *mut ib_pd,
            arg8: *mut ib_udata,
        ) -> *mut ib_mr,
    >,
    pub dereg_mr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_mr, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_mr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_pd, arg2: ib_mr_type::Type, arg3: u32_) -> *mut ib_mr,
    >,
    pub alloc_mr_integrity: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_pd, arg2: u32_, arg3: u32_) -> *mut ib_mr,
    >,
    pub advise_mr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_pd,
            arg2: ib_uverbs_advise_mr_advice::Type,
            arg3: u32_,
            arg4: *mut ib_sge,
            arg5: u32_,
            arg6: *mut uverbs_attr_bundle,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_mr_sg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_mr,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub check_mr_status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_mr,
            arg2: u32_,
            arg3: *mut ib_mr_status,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_mw: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_mw, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub dealloc_mw:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_mw) -> ::aya_bpf::cty::c_int>,
    pub attach_mcast: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_gid,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub detach_mcast: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_gid,
            arg3: u16_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_xrcd: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_xrcd, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub dealloc_xrcd: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_xrcd, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub create_flow: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_qp,
            arg2: *mut ib_flow_attr,
            arg3: *mut ib_udata,
        ) -> *mut ib_flow,
    >,
    pub destroy_flow:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_flow) -> ::aya_bpf::cty::c_int>,
    pub destroy_flow_action: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_flow_action) -> ::aya_bpf::cty::c_int,
    >,
    pub set_vf_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_vf_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: *mut ifla_vf_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_vf_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: *mut ifla_vf_stats,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: *mut ifla_vf_guid,
            arg5: *mut ifla_vf_guid,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: ::aya_bpf::cty::c_int,
            arg3: u32_,
            arg4: u64_,
            arg5: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create_wq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_pd,
            arg2: *mut ib_wq_init_attr,
            arg3: *mut ib_udata,
        ) -> *mut ib_wq,
    >,
    pub destroy_wq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_wq, arg2: *mut ib_udata) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_wq: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_wq,
            arg2: *mut ib_wq_attr,
            arg3: u32_,
            arg4: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create_rwq_ind_table: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_rwq_ind_table,
            arg2: *mut ib_rwq_ind_table_init_attr,
            arg3: *mut ib_udata,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_rwq_ind_table: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_rwq_ind_table) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_dm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: *mut ib_ucontext,
            arg3: *mut ib_dm_alloc_attr,
            arg4: *mut uverbs_attr_bundle,
        ) -> *mut ib_dm,
    >,
    pub dealloc_dm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_dm,
            arg2: *mut uverbs_attr_bundle,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reg_dm_mr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_pd,
            arg2: *mut ib_dm,
            arg3: *mut ib_dm_mr_attr,
            arg4: *mut uverbs_attr_bundle,
        ) -> *mut ib_mr,
    >,
    pub create_counters: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_counters,
            arg2: *mut uverbs_attr_bundle,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub destroy_counters: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_counters) -> ::aya_bpf::cty::c_int,
    >,
    pub read_counters: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_counters,
            arg2: *mut ib_counters_read_attr,
            arg3: *mut uverbs_attr_bundle,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub map_mr_sg_pi: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_mr,
            arg2: *mut scatterlist,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut ::aya_bpf::cty::c_uint,
            arg5: *mut scatterlist,
            arg6: ::aya_bpf::cty::c_int,
            arg7: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_hw_device_stats:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_device) -> *mut rdma_hw_stats>,
    pub alloc_hw_port_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: u32_) -> *mut rdma_hw_stats,
    >,
    pub get_hw_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: *mut rdma_hw_stats,
            arg3: u32_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub modify_hw_stat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_mr_entry: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_mr) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_mr_entry_raw: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_mr) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_cq_entry: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_cq) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_cq_entry_raw: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_cq) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_qp_entry: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_qp) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_qp_entry_raw: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_qp) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_res_cm_id_entry: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut rdma_cm_id) -> ::aya_bpf::cty::c_int,
    >,
    pub enable_driver:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_device) -> ::aya_bpf::cty::c_int>,
    pub dealloc_driver: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_device)>,
    pub iw_add_ref: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_qp)>,
    pub iw_rem_ref: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_qp)>,
    pub iw_get_qp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_device, arg2: ::aya_bpf::cty::c_int) -> *mut ib_qp,
    >,
    pub iw_connect: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iw_cm_id,
            arg2: *mut iw_cm_conn_param,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iw_accept: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iw_cm_id,
            arg2: *mut iw_cm_conn_param,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iw_reject: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iw_cm_id,
            arg2: *const ::aya_bpf::cty::c_void,
            arg3: u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iw_create_listen: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut iw_cm_id,
            arg2: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub iw_destroy_listen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut iw_cm_id) -> ::aya_bpf::cty::c_int>,
    pub counter_bind_qp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rdma_counter, arg2: *mut ib_qp) -> ::aya_bpf::cty::c_int,
    >,
    pub counter_unbind_qp:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_qp) -> ::aya_bpf::cty::c_int>,
    pub counter_dealloc: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rdma_counter) -> ::aya_bpf::cty::c_int,
    >,
    pub counter_alloc_stats:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rdma_counter) -> *mut rdma_hw_stats>,
    pub counter_update_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rdma_counter) -> ::aya_bpf::cty::c_int,
    >,
    pub fill_stat_mr_entry: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ib_mr) -> ::aya_bpf::cty::c_int,
    >,
    pub query_ucontext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_ucontext,
            arg2: *mut uverbs_attr_bundle,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_numa_node:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_device) -> ::aya_bpf::cty::c_int>,
    pub size_ib_ah: usize,
    pub size_ib_counters: usize,
    pub size_ib_cq: usize,
    pub size_ib_mw: usize,
    pub size_ib_pd: usize,
    pub size_ib_qp: usize,
    pub size_ib_rwq_ind_table: usize,
    pub size_ib_srq: usize,
    pub size_ib_ucontext: usize,
    pub size_ib_xrcd: usize,
}
impl ib_device_ops {
    #[inline]
    pub fn uverbs_no_driver_id_binding(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uverbs_no_driver_id_binding(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uverbs_no_driver_id_binding: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uverbs_no_driver_id_binding: u32 =
                unsafe { ::core::mem::transmute(uverbs_no_driver_id_binding) };
            uverbs_no_driver_id_binding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_core_device {
    pub dev: device,
    pub rdma_net: possible_net_t,
    pub ports_kobj: *mut kobject,
    pub port_list: list_head,
    pub owner: *mut ib_device,
}
pub mod ib_atomic_cap {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_ATOMIC_NONE: Type = 0;
    pub const IB_ATOMIC_HCA: Type = 1;
    pub const IB_ATOMIC_GLOB: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ib_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
    pub xrc_odp_caps: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_rss_caps {
    pub supported_qpts: u32_,
    pub max_rwq_indirection_tables: u32_,
    pub max_rwq_indirection_table_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_tm_caps {
    pub max_rndv_hdr_size: u32_,
    pub max_num_tags: u32_,
    pub flags: u32_,
    pub max_ops: u32_,
    pub max_sge: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_cq_caps {
    pub max_cq_moderation_count: u16_,
    pub max_cq_moderation_period: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_device_attr {
    pub fw_ver: u64_,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64_,
    pub page_size_cap: u64_,
    pub vendor_id: u32_,
    pub vendor_part_id: u32_,
    pub hw_ver: u32_,
    pub max_qp: ::aya_bpf::cty::c_int,
    pub max_qp_wr: ::aya_bpf::cty::c_int,
    pub device_cap_flags: u64_,
    pub kernel_cap_flags: u64_,
    pub max_send_sge: ::aya_bpf::cty::c_int,
    pub max_recv_sge: ::aya_bpf::cty::c_int,
    pub max_sge_rd: ::aya_bpf::cty::c_int,
    pub max_cq: ::aya_bpf::cty::c_int,
    pub max_cqe: ::aya_bpf::cty::c_int,
    pub max_mr: ::aya_bpf::cty::c_int,
    pub max_pd: ::aya_bpf::cty::c_int,
    pub max_qp_rd_atom: ::aya_bpf::cty::c_int,
    pub max_ee_rd_atom: ::aya_bpf::cty::c_int,
    pub max_res_rd_atom: ::aya_bpf::cty::c_int,
    pub max_qp_init_rd_atom: ::aya_bpf::cty::c_int,
    pub max_ee_init_rd_atom: ::aya_bpf::cty::c_int,
    pub atomic_cap: ib_atomic_cap::Type,
    pub masked_atomic_cap: ib_atomic_cap::Type,
    pub max_ee: ::aya_bpf::cty::c_int,
    pub max_rdd: ::aya_bpf::cty::c_int,
    pub max_mw: ::aya_bpf::cty::c_int,
    pub max_raw_ipv6_qp: ::aya_bpf::cty::c_int,
    pub max_raw_ethy_qp: ::aya_bpf::cty::c_int,
    pub max_mcast_grp: ::aya_bpf::cty::c_int,
    pub max_mcast_qp_attach: ::aya_bpf::cty::c_int,
    pub max_total_mcast_qp_attach: ::aya_bpf::cty::c_int,
    pub max_ah: ::aya_bpf::cty::c_int,
    pub max_srq: ::aya_bpf::cty::c_int,
    pub max_srq_wr: ::aya_bpf::cty::c_int,
    pub max_srq_sge: ::aya_bpf::cty::c_int,
    pub max_fast_reg_page_list_len: ::aya_bpf::cty::c_uint,
    pub max_pi_fast_reg_page_list_len: ::aya_bpf::cty::c_uint,
    pub max_pkeys: u16_,
    pub local_ca_ack_delay: u8_,
    pub sig_prot_cap: ::aya_bpf::cty::c_int,
    pub sig_guard_cap: ::aya_bpf::cty::c_int,
    pub odp_caps: ib_odp_caps,
    pub timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub rss_caps: ib_rss_caps,
    pub max_wq_type_rq: u32_,
    pub raw_packet_caps: u32_,
    pub tm_caps: ib_tm_caps,
    pub cq_caps: ib_cq_caps,
    pub max_dm_size: u64_,
    pub max_sgl_rd: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hw_stats_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_restrack_root {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uapi_definition {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_device {
    pub dma_device: *mut device,
    pub ops: ib_device_ops,
    pub name: [::aya_bpf::cty::c_char; 64usize],
    pub callback_head: callback_head,
    pub event_handler_list: list_head,
    pub event_handler_rwsem: rw_semaphore,
    pub qp_open_list_lock: spinlock_t,
    pub client_data_rwsem: rw_semaphore,
    pub client_data: xarray,
    pub unregistration_lock: mutex,
    pub cache_lock: rwlock_t,
    pub port_data: *mut ib_port_data,
    pub num_comp_vectors: ::aya_bpf::cty::c_int,
    pub __bindgen_anon_1: ib_device__bindgen_ty_1,
    pub groups: [*const attribute_group; 4usize],
    pub uverbs_cmd_mask: u64_,
    pub node_desc: [::aya_bpf::cty::c_char; 64usize],
    pub node_guid: __be64,
    pub local_dma_lkey: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub node_type: u8_,
    pub phys_port_cnt: u32_,
    pub attrs: ib_device_attr,
    pub hw_stats_data: *mut hw_stats_device_data,
    pub cg_device: rdmacg_device,
    pub index: u32_,
    pub cq_pools_lock: spinlock_t,
    pub cq_pools: [list_head; 3usize],
    pub res: *mut rdma_restrack_root,
    pub driver_def: *const uapi_definition,
    pub refcount: refcount_t,
    pub unreg_completion: completion,
    pub unregistration_work: work_struct,
    pub link_ops: *const rdma_link_ops,
    pub compat_devs_mutex: mutex,
    pub compat_devs: xarray,
    pub iw_ifname: [::aya_bpf::cty::c_char; 16usize],
    pub iw_driver_flags: u32_,
    pub lag_flags: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_device__bindgen_ty_1 {
    pub dev: device,
    pub coredev: ib_core_device,
}
impl ib_device {
    #[inline]
    pub fn is_switch(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_switch(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kverbs_provider(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kverbs_provider(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_cq_dim(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_use_cq_dim(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_switch: u16_,
        kverbs_provider: u16_,
        use_cq_dim: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_switch: u16 = unsafe { ::core::mem::transmute(is_switch) };
            is_switch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let kverbs_provider: u16 = unsafe { ::core::mem::transmute(kverbs_provider) };
            kverbs_provider as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let use_cq_dim: u16 = unsafe { ::core::mem::transmute(use_cq_dim) };
            use_cq_dim as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod ib_signature_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_SIG_TYPE_NONE: Type = 0;
    pub const IB_SIG_TYPE_T10_DIF: Type = 1;
}
pub mod ib_t10_dif_bg_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_T10DIF_CRC: Type = 0;
    pub const IB_T10DIF_CSUM: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_t10_dif_domain {
    pub bg_type: ib_t10_dif_bg_type::Type,
    pub pi_interval: u16_,
    pub bg: u16_,
    pub app_tag: u16_,
    pub ref_tag: u32_,
    pub ref_remap: bool_,
    pub app_escape: bool_,
    pub ref_escape: bool_,
    pub apptag_check_mask: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_sig_domain {
    pub sig_type: ib_signature_type::Type,
    pub sig: ib_sig_domain__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_sig_domain__bindgen_ty_1 {
    pub dif: ib_t10_dif_domain,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_sig_attrs {
    pub check_mask: u8_,
    pub mem: ib_sig_domain,
    pub wire: ib_sig_domain,
    pub meta_length: ::aya_bpf::cty::c_int,
}
pub mod ib_sig_err_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_SIG_BAD_GUARD: Type = 0;
    pub const IB_SIG_BAD_REFTAG: Type = 1;
    pub const IB_SIG_BAD_APPTAG: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_sig_err {
    pub err_type: ib_sig_err_type::Type,
    pub expected: u32_,
    pub actual: u32_,
    pub sig_err_offset: u64_,
    pub key: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_gid {
    pub raw: [u8_; 16usize],
    pub global: ib_gid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
pub mod ib_gid_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_GID_TYPE_IB: Type = 0;
    pub const IB_GID_TYPE_ROCE: Type = 1;
    pub const IB_GID_TYPE_ROCE_UDP_ENCAP: Type = 2;
    pub const IB_GID_TYPE_SIZE: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_gid_attr {
    pub ndev: *mut net_device,
    pub device: *mut ib_device,
    pub gid: ib_gid,
    pub gid_type: ib_gid_type::Type,
    pub index: u16_,
    pub port_num: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_cq_init_attr {
    pub cqe: ::aya_bpf::cty::c_uint,
    pub comp_vector: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_dm_mr_attr {
    pub length: u64_,
    pub offset: u64_,
    pub access_flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_dm_alloc_attr {
    pub length: u64_,
    pub alignment: u32_,
    pub flags: u32_,
}
pub mod ib_mtu {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_MTU_256: Type = 1;
    pub const IB_MTU_512: Type = 2;
    pub const IB_MTU_1024: Type = 3;
    pub const IB_MTU_2048: Type = 4;
    pub const IB_MTU_4096: Type = 5;
}
pub mod ib_port_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_PORT_NOP: Type = 0;
    pub const IB_PORT_DOWN: Type = 1;
    pub const IB_PORT_INIT: Type = 2;
    pub const IB_PORT_ARMED: Type = 3;
    pub const IB_PORT_ACTIVE: Type = 4;
    pub const IB_PORT_ACTIVE_DEFER: Type = 5;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_stat_desc {
    pub name: *const ::aya_bpf::cty::c_char,
    pub flags: ::aya_bpf::cty::c_uint,
    pub priv_: *const ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port_attr {
    pub subnet_prefix: u64_,
    pub state: ib_port_state::Type,
    pub max_mtu: ib_mtu::Type,
    pub active_mtu: ib_mtu::Type,
    pub phys_mtu: u32_,
    pub gid_tbl_len: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub port_cap_flags: u32_,
    pub max_msg_sz: u32_,
    pub bad_pkey_cntr: u32_,
    pub qkey_viol_cntr: u32_,
    pub pkey_tbl_len: u16_,
    pub sm_lid: u32_,
    pub lid: u32_,
    pub lmc: u8_,
    pub max_vl_num: u8_,
    pub sm_sl: u8_,
    pub subnet_timeout: u8_,
    pub init_type_reply: u8_,
    pub active_width: u8_,
    pub active_speed: u16_,
    pub phys_state: u8_,
    pub port_cap_flags2: u16_,
}
impl ib_port_attr {
    #[inline]
    pub fn ip_gids(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip_gids(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip_gids: ::aya_bpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ip_gids: u32 = unsafe { ::core::mem::transmute(ip_gids) };
            ip_gids as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_device_modify {
    pub sys_image_guid: u64_,
    pub node_desc: [::aya_bpf::cty::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port_modify {
    pub set_port_cap_mask: u32_,
    pub clr_port_cap_mask: u32_,
    pub init_type: u8_,
}
pub mod ib_event_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_EVENT_CQ_ERR: Type = 0;
    pub const IB_EVENT_QP_FATAL: Type = 1;
    pub const IB_EVENT_QP_REQ_ERR: Type = 2;
    pub const IB_EVENT_QP_ACCESS_ERR: Type = 3;
    pub const IB_EVENT_COMM_EST: Type = 4;
    pub const IB_EVENT_SQ_DRAINED: Type = 5;
    pub const IB_EVENT_PATH_MIG: Type = 6;
    pub const IB_EVENT_PATH_MIG_ERR: Type = 7;
    pub const IB_EVENT_DEVICE_FATAL: Type = 8;
    pub const IB_EVENT_PORT_ACTIVE: Type = 9;
    pub const IB_EVENT_PORT_ERR: Type = 10;
    pub const IB_EVENT_LID_CHANGE: Type = 11;
    pub const IB_EVENT_PKEY_CHANGE: Type = 12;
    pub const IB_EVENT_SM_CHANGE: Type = 13;
    pub const IB_EVENT_SRQ_ERR: Type = 14;
    pub const IB_EVENT_SRQ_LIMIT_REACHED: Type = 15;
    pub const IB_EVENT_QP_LAST_WQE_REACHED: Type = 16;
    pub const IB_EVENT_CLIENT_REREGISTER: Type = 17;
    pub const IB_EVENT_GID_CHANGE: Type = 18;
    pub const IB_EVENT_WQ_FATAL: Type = 19;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_ucq_object {
    _unused: [u8; 0],
}
pub type ib_comp_handler = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ib_cq, arg2: *mut ::aya_bpf::cty::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_cq {
    pub device: *mut ib_device,
    pub uobject: *mut ib_ucq_object,
    pub comp_handler: ib_comp_handler,
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub cq_context: *mut ::aya_bpf::cty::c_void,
    pub cqe: ::aya_bpf::cty::c_int,
    pub cqe_used: ::aya_bpf::cty::c_uint,
    pub usecnt: atomic_t,
    pub poll_ctx: ib_poll_context::Type,
    pub wc: *mut ib_wc,
    pub pool_entry: list_head,
    pub __bindgen_anon_1: ib_cq__bindgen_ty_1,
    pub comp_wq: *mut workqueue_struct,
    pub dim: *mut dim,
    pub timestamp: ktime_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub comp_vector: ::aya_bpf::cty::c_uint,
    pub res: rdma_restrack_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_cq__bindgen_ty_1 {
    pub iop: irq_poll,
    pub work: work_struct,
}
impl ib_cq {
    #[inline]
    pub fn interrupt(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_interrupt(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(interrupt: u8_, shared: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let interrupt: u8 = unsafe { ::core::mem::transmute(interrupt) };
            interrupt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let shared: u8 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_uqp_object {
    _unused: [u8; 0],
}
pub mod ib_qp_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_QPT_SMI: Type = 0;
    pub const IB_QPT_GSI: Type = 1;
    pub const IB_QPT_RC: Type = 2;
    pub const IB_QPT_UC: Type = 3;
    pub const IB_QPT_UD: Type = 4;
    pub const IB_QPT_RAW_IPV6: Type = 5;
    pub const IB_QPT_RAW_ETHERTYPE: Type = 6;
    pub const IB_QPT_RAW_PACKET: Type = 8;
    pub const IB_QPT_XRC_INI: Type = 9;
    pub const IB_QPT_XRC_TGT: Type = 10;
    pub const IB_QPT_MAX: Type = 11;
    pub const IB_QPT_DRIVER: Type = 255;
    pub const IB_QPT_RESERVED1: Type = 4096;
    pub const IB_QPT_RESERVED2: Type = 4097;
    pub const IB_QPT_RESERVED3: Type = 4098;
    pub const IB_QPT_RESERVED4: Type = 4099;
    pub const IB_QPT_RESERVED5: Type = 4100;
    pub const IB_QPT_RESERVED6: Type = 4101;
    pub const IB_QPT_RESERVED7: Type = 4102;
    pub const IB_QPT_RESERVED8: Type = 4103;
    pub const IB_QPT_RESERVED9: Type = 4104;
    pub const IB_QPT_RESERVED10: Type = 4105;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_qp {
    pub device: *mut ib_device,
    pub pd: *mut ib_pd,
    pub send_cq: *mut ib_cq,
    pub recv_cq: *mut ib_cq,
    pub mr_lock: spinlock_t,
    pub mrs_used: ::aya_bpf::cty::c_int,
    pub rdma_mrs: list_head,
    pub sig_mrs: list_head,
    pub srq: *mut ib_srq,
    pub xrcd: *mut ib_xrcd,
    pub xrcd_list: list_head,
    pub usecnt: atomic_t,
    pub open_list: list_head,
    pub real_qp: *mut ib_qp,
    pub uobject: *mut ib_uqp_object,
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub qp_context: *mut ::aya_bpf::cty::c_void,
    pub av_sgid_attr: *const ib_gid_attr,
    pub alt_path_sgid_attr: *const ib_gid_attr,
    pub qp_num: u32_,
    pub max_write_sge: u32_,
    pub max_read_sge: u32_,
    pub qp_type: ib_qp_type::Type,
    pub rwq_ind_tbl: *mut ib_rwq_ind_table,
    pub qp_sec: *mut ib_qp_security,
    pub port: u32_,
    pub integrity_en: bool_,
    pub res: rdma_restrack_entry,
    pub counter: *mut rdma_counter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_usrq_object {
    _unused: [u8; 0],
}
pub mod ib_srq_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_SRQT_BASIC: Type = 0;
    pub const IB_SRQT_XRC: Type = 1;
    pub const IB_SRQT_TM: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_srq {
    pub device: *mut ib_device,
    pub pd: *mut ib_pd,
    pub uobject: *mut ib_usrq_object,
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub srq_context: *mut ::aya_bpf::cty::c_void,
    pub srq_type: ib_srq_type::Type,
    pub usecnt: atomic_t,
    pub ext: ib_srq__bindgen_ty_1,
    pub res: rdma_restrack_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_srq__bindgen_ty_1 {
    pub cq: *mut ib_cq,
    pub __bindgen_anon_1: ib_srq__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_srq__bindgen_ty_1__bindgen_ty_1 {
    pub xrc: ib_srq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_srq__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub xrcd: *mut ib_xrcd,
    pub srq_num: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_uwq_object {
    _unused: [u8; 0],
}
pub mod ib_wq_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_WQS_RESET: Type = 0;
    pub const IB_WQS_RDY: Type = 1;
    pub const IB_WQS_ERR: Type = 2;
}
pub mod ib_wq_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_WQT_RQ: Type = 0;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_wq {
    pub device: *mut ib_device,
    pub uobject: *mut ib_uwq_object,
    pub wq_context: *mut ::aya_bpf::cty::c_void,
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub pd: *mut ib_pd,
    pub cq: *mut ib_cq,
    pub wq_num: u32_,
    pub state: ib_wq_state::Type,
    pub wq_type: ib_wq_type::Type,
    pub usecnt: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_event {
    pub device: *mut ib_device,
    pub element: ib_event__bindgen_ty_1,
    pub event: ib_event_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_event__bindgen_ty_1 {
    pub cq: *mut ib_cq,
    pub qp: *mut ib_qp,
    pub srq: *mut ib_srq,
    pub wq: *mut ib_wq,
    pub port_num: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_global_route {
    pub sgid_attr: *const ib_gid_attr,
    pub dgid: ib_gid,
    pub flow_label: u32_,
    pub sgid_index: u8_,
    pub hop_limit: u8_,
    pub traffic_class: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_grh {
    pub version_tclass_flow: __be32,
    pub paylen: __be16,
    pub next_hdr: u8_,
    pub hop_limit: u8_,
    pub sgid: ib_gid,
    pub dgid: ib_gid,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_mr_status {
    pub fail_status: u32_,
    pub sig_err: ib_sig_err,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_ah_init_attr {
    pub ah_attr: *mut rdma_ah_attr,
    pub flags: u32_,
    pub xmit_slave: *mut net_device,
}
pub mod rdma_ah_attr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const RDMA_AH_ATTR_TYPE_UNDEFINED: Type = 0;
    pub const RDMA_AH_ATTR_TYPE_IB: Type = 1;
    pub const RDMA_AH_ATTR_TYPE_ROCE: Type = 2;
    pub const RDMA_AH_ATTR_TYPE_OPA: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_ah_attr {
    pub dlid: u16_,
    pub src_path_bits: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roce_ah_attr {
    pub dmac: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opa_ah_attr {
    pub dlid: u32_,
    pub src_path_bits: u8_,
    pub make_grd: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ah_attr {
    pub grh: ib_global_route,
    pub sl: u8_,
    pub static_rate: u8_,
    pub port_num: u32_,
    pub ah_flags: u8_,
    pub type_: rdma_ah_attr_type::Type,
    pub __bindgen_anon_1: rdma_ah_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_ah_attr__bindgen_ty_1 {
    pub ib: ib_ah_attr,
    pub roce: roce_ah_attr,
    pub opa: opa_ah_attr,
}
pub mod ib_wc_status {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_WC_SUCCESS: Type = 0;
    pub const IB_WC_LOC_LEN_ERR: Type = 1;
    pub const IB_WC_LOC_QP_OP_ERR: Type = 2;
    pub const IB_WC_LOC_EEC_OP_ERR: Type = 3;
    pub const IB_WC_LOC_PROT_ERR: Type = 4;
    pub const IB_WC_WR_FLUSH_ERR: Type = 5;
    pub const IB_WC_MW_BIND_ERR: Type = 6;
    pub const IB_WC_BAD_RESP_ERR: Type = 7;
    pub const IB_WC_LOC_ACCESS_ERR: Type = 8;
    pub const IB_WC_REM_INV_REQ_ERR: Type = 9;
    pub const IB_WC_REM_ACCESS_ERR: Type = 10;
    pub const IB_WC_REM_OP_ERR: Type = 11;
    pub const IB_WC_RETRY_EXC_ERR: Type = 12;
    pub const IB_WC_RNR_RETRY_EXC_ERR: Type = 13;
    pub const IB_WC_LOC_RDD_VIOL_ERR: Type = 14;
    pub const IB_WC_REM_INV_RD_REQ_ERR: Type = 15;
    pub const IB_WC_REM_ABORT_ERR: Type = 16;
    pub const IB_WC_INV_EECN_ERR: Type = 17;
    pub const IB_WC_INV_EEC_STATE_ERR: Type = 18;
    pub const IB_WC_FATAL_ERR: Type = 19;
    pub const IB_WC_RESP_TIMEOUT_ERR: Type = 20;
    pub const IB_WC_GENERAL_ERR: Type = 21;
}
pub mod ib_wc_opcode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_WC_SEND: Type = 0;
    pub const IB_WC_RDMA_WRITE: Type = 1;
    pub const IB_WC_RDMA_READ: Type = 2;
    pub const IB_WC_COMP_SWAP: Type = 3;
    pub const IB_WC_FETCH_ADD: Type = 4;
    pub const IB_WC_BIND_MW: Type = 5;
    pub const IB_WC_LOCAL_INV: Type = 6;
    pub const IB_WC_LSO: Type = 7;
    pub const IB_WC_ATOMIC_WRITE: Type = 9;
    pub const IB_WC_REG_MR: Type = 10;
    pub const IB_WC_MASKED_COMP_SWAP: Type = 11;
    pub const IB_WC_MASKED_FETCH_ADD: Type = 12;
    pub const IB_WC_FLUSH: Type = 8;
    pub const IB_WC_RECV: Type = 128;
    pub const IB_WC_RECV_RDMA_WITH_IMM: Type = 129;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_cqe {
    pub done: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ib_cq, arg2: *mut ib_wc)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_wc {
    pub __bindgen_anon_1: ib_wc__bindgen_ty_1,
    pub status: ib_wc_status::Type,
    pub opcode: ib_wc_opcode::Type,
    pub vendor_err: u32_,
    pub byte_len: u32_,
    pub qp: *mut ib_qp,
    pub ex: ib_wc__bindgen_ty_2,
    pub src_qp: u32_,
    pub slid: u32_,
    pub wc_flags: ::aya_bpf::cty::c_int,
    pub pkey_index: u16_,
    pub sl: u8_,
    pub dlid_path_bits: u8_,
    pub port_num: u32_,
    pub smac: [u8_; 6usize],
    pub vlan_id: u16_,
    pub network_hdr_type: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_wc__bindgen_ty_1 {
    pub wr_id: u64_,
    pub wr_cqe: *mut ib_cqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_wc__bindgen_ty_2 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_srq_attr {
    pub max_wr: u32_,
    pub max_sge: u32_,
    pub srq_limit: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_xrcd {
    pub device: *mut ib_device,
    pub usecnt: atomic_t,
    pub inode: *mut inode,
    pub tgt_qps_rwsem: rw_semaphore,
    pub tgt_qps: xarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_srq_init_attr {
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub srq_context: *mut ::aya_bpf::cty::c_void,
    pub attr: ib_srq_attr,
    pub srq_type: ib_srq_type::Type,
    pub ext: ib_srq_init_attr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_srq_init_attr__bindgen_ty_1 {
    pub cq: *mut ib_cq,
    pub __bindgen_anon_1: ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1 {
    pub xrc: ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub tag_matching: ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub xrcd: *mut ib_xrcd,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_srq_init_attr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub max_num_tags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_qp_cap {
    pub max_send_wr: u32_,
    pub max_recv_wr: u32_,
    pub max_send_sge: u32_,
    pub max_recv_sge: u32_,
    pub max_inline_data: u32_,
    pub max_rdma_ctxs: u32_,
}
pub mod ib_sig_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_SIGNAL_ALL_WR: Type = 0;
    pub const IB_SIGNAL_REQ_WR: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_qp_init_attr {
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub qp_context: *mut ::aya_bpf::cty::c_void,
    pub send_cq: *mut ib_cq,
    pub recv_cq: *mut ib_cq,
    pub srq: *mut ib_srq,
    pub xrcd: *mut ib_xrcd,
    pub cap: ib_qp_cap,
    pub sq_sig_type: ib_sig_type::Type,
    pub qp_type: ib_qp_type::Type,
    pub create_flags: u32_,
    pub port_num: u32_,
    pub rwq_ind_tbl: *mut ib_rwq_ind_table,
    pub source_qpn: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_rwq_ind_table {
    pub device: *mut ib_device,
    pub uobject: *mut ib_uobject,
    pub usecnt: atomic_t,
    pub ind_tbl_num: u32_,
    pub log_ind_tbl_size: u32_,
    pub ind_tbl: *mut *mut ib_wq,
}
pub mod ib_qp_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_QPS_RESET: Type = 0;
    pub const IB_QPS_INIT: Type = 1;
    pub const IB_QPS_RTR: Type = 2;
    pub const IB_QPS_RTS: Type = 3;
    pub const IB_QPS_SQD: Type = 4;
    pub const IB_QPS_SQE: Type = 5;
    pub const IB_QPS_ERR: Type = 6;
}
pub mod ib_mig_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_MIG_MIGRATED: Type = 0;
    pub const IB_MIG_REARM: Type = 1;
    pub const IB_MIG_ARMED: Type = 2;
}
pub mod ib_mw_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_MW_TYPE_1: Type = 1;
    pub const IB_MW_TYPE_2: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_qp_attr {
    pub qp_state: ib_qp_state::Type,
    pub cur_qp_state: ib_qp_state::Type,
    pub path_mtu: ib_mtu::Type,
    pub path_mig_state: ib_mig_state::Type,
    pub qkey: u32_,
    pub rq_psn: u32_,
    pub sq_psn: u32_,
    pub dest_qp_num: u32_,
    pub qp_access_flags: ::aya_bpf::cty::c_int,
    pub cap: ib_qp_cap,
    pub ah_attr: rdma_ah_attr,
    pub alt_ah_attr: rdma_ah_attr,
    pub pkey_index: u16_,
    pub alt_pkey_index: u16_,
    pub en_sqd_async_notify: u8_,
    pub sq_draining: u8_,
    pub max_rd_atomic: u8_,
    pub max_dest_rd_atomic: u8_,
    pub min_rnr_timer: u8_,
    pub port_num: u32_,
    pub timeout: u8_,
    pub retry_cnt: u8_,
    pub rnr_retry: u8_,
    pub alt_port_num: u32_,
    pub alt_timeout: u8_,
    pub rate_limit: u32_,
    pub xmit_slave: *mut net_device,
}
pub mod ib_wr_opcode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_WR_RDMA_WRITE: Type = 0;
    pub const IB_WR_RDMA_WRITE_WITH_IMM: Type = 1;
    pub const IB_WR_SEND: Type = 2;
    pub const IB_WR_SEND_WITH_IMM: Type = 3;
    pub const IB_WR_RDMA_READ: Type = 4;
    pub const IB_WR_ATOMIC_CMP_AND_SWP: Type = 5;
    pub const IB_WR_ATOMIC_FETCH_AND_ADD: Type = 6;
    pub const IB_WR_BIND_MW: Type = 8;
    pub const IB_WR_LSO: Type = 10;
    pub const IB_WR_SEND_WITH_INV: Type = 9;
    pub const IB_WR_RDMA_READ_WITH_INV: Type = 11;
    pub const IB_WR_LOCAL_INV: Type = 7;
    pub const IB_WR_MASKED_ATOMIC_CMP_AND_SWP: Type = 12;
    pub const IB_WR_MASKED_ATOMIC_FETCH_AND_ADD: Type = 13;
    pub const IB_WR_FLUSH: Type = 14;
    pub const IB_WR_ATOMIC_WRITE: Type = 15;
    pub const IB_WR_REG_MR: Type = 32;
    pub const IB_WR_REG_MR_INTEGRITY: Type = 33;
    pub const IB_WR_RESERVED1: Type = 240;
    pub const IB_WR_RESERVED2: Type = 241;
    pub const IB_WR_RESERVED3: Type = 242;
    pub const IB_WR_RESERVED4: Type = 243;
    pub const IB_WR_RESERVED5: Type = 244;
    pub const IB_WR_RESERVED6: Type = 245;
    pub const IB_WR_RESERVED7: Type = 246;
    pub const IB_WR_RESERVED8: Type = 247;
    pub const IB_WR_RESERVED9: Type = 248;
    pub const IB_WR_RESERVED10: Type = 249;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_sge {
    pub addr: u64_,
    pub length: u32_,
    pub lkey: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_send_wr {
    pub next: *mut ib_send_wr,
    pub __bindgen_anon_1: ib_send_wr__bindgen_ty_1,
    pub sg_list: *mut ib_sge,
    pub num_sge: ::aya_bpf::cty::c_int,
    pub opcode: ib_wr_opcode::Type,
    pub send_flags: ::aya_bpf::cty::c_int,
    pub ex: ib_send_wr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_send_wr__bindgen_ty_1 {
    pub wr_id: u64_,
    pub wr_cqe: *mut ib_cqe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_send_wr__bindgen_ty_2 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_ah {
    pub device: *mut ib_device,
    pub pd: *mut ib_pd,
    pub uobject: *mut ib_uobject,
    pub sgid_attr: *const ib_gid_attr,
    pub type_: rdma_ah_attr_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_mr {
    pub device: *mut ib_device,
    pub pd: *mut ib_pd,
    pub lkey: u32_,
    pub rkey: u32_,
    pub iova: u64_,
    pub length: u64_,
    pub page_size: ::aya_bpf::cty::c_uint,
    pub type_: ib_mr_type::Type,
    pub need_inval: bool_,
    pub __bindgen_anon_1: ib_mr__bindgen_ty_1,
    pub dm: *mut ib_dm,
    pub sig_attrs: *mut ib_sig_attrs,
    pub res: rdma_restrack_entry,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_mr__bindgen_ty_1 {
    pub uobject: *mut ib_uobject,
    pub qp_entry: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_recv_wr {
    pub next: *mut ib_recv_wr,
    pub __bindgen_anon_1: ib_recv_wr__bindgen_ty_1,
    pub sg_list: *mut ib_sge,
    pub num_sge: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_recv_wr__bindgen_ty_1 {
    pub wr_id: u64_,
    pub wr_cqe: *mut ib_cqe,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_rdmacg_object {
    pub cg: *mut rdma_cgroup,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_uverbs_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_ucontext {
    pub device: *mut ib_device,
    pub ufile: *mut ib_uverbs_file,
    pub cg_obj: ib_rdmacg_object,
    pub res: rdma_restrack_entry,
    pub mmap_xa: xarray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uverbs_api_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_uobject {
    pub user_handle: u64_,
    pub ufile: *mut ib_uverbs_file,
    pub context: *mut ib_ucontext,
    pub object: *mut ::aya_bpf::cty::c_void,
    pub list: list_head,
    pub cg_obj: ib_rdmacg_object,
    pub id: ::aya_bpf::cty::c_int,
    pub ref_: kref,
    pub usecnt: atomic_t,
    pub rcu: callback_head,
    pub uapi_object: *const uverbs_api_object,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_udata {
    pub inbuf: *const ::aya_bpf::cty::c_void,
    pub outbuf: *mut ::aya_bpf::cty::c_void,
    pub inlen: usize,
    pub outlen: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_pd {
    pub local_dma_lkey: u32_,
    pub flags: u32_,
    pub device: *mut ib_device,
    pub uobject: *mut ib_uobject,
    pub usecnt: atomic_t,
    pub unsafe_global_rkey: u32_,
    pub __internal_mr: *mut ib_mr,
    pub res: rdma_restrack_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_wq_init_attr {
    pub wq_context: *mut ::aya_bpf::cty::c_void,
    pub wq_type: ib_wq_type::Type,
    pub max_wr: u32_,
    pub max_sge: u32_,
    pub cq: *mut ib_cq,
    pub event_handler: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ib_event, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub create_flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_wq_attr {
    pub wq_state: ib_wq_state::Type,
    pub curr_wq_state: ib_wq_state::Type,
    pub flags: u32_,
    pub flags_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32_,
    pub ind_tbl: *mut *mut ib_wq,
}
pub mod port_pkey_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_PORT_PKEY_NOT_VALID: Type = 0;
    pub const IB_PORT_PKEY_VALID: Type = 1;
    pub const IB_PORT_PKEY_LISTED: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port_pkey {
    pub state: port_pkey_state::Type,
    pub pkey_index: u16_,
    pub port_num: u32_,
    pub qp_list: list_head,
    pub to_error_list: list_head,
    pub sec: *mut ib_qp_security,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_qp_security {
    pub qp: *mut ib_qp,
    pub dev: *mut ib_device,
    pub mutex: mutex,
    pub ports_pkeys: *mut ib_ports_pkeys,
    pub shared_qp_list: list_head,
    pub security: *mut ::aya_bpf::cty::c_void,
    pub destroying: bool_,
    pub error_list_count: atomic_t,
    pub error_complete: completion,
    pub error_comps_pending: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_ports_pkeys {
    pub main: ib_port_pkey,
    pub alt: ib_port_pkey,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_dm {
    pub device: *mut ib_device,
    pub length: u32_,
    pub flags: u32_,
    pub uobject: *mut ib_uobject,
    pub usecnt: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_mw {
    pub device: *mut ib_device,
    pub pd: *mut ib_pd,
    pub uobject: *mut ib_uobject,
    pub rkey: u32_,
    pub type_: ib_mw_type::Type,
}
pub mod ib_flow_attr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_FLOW_ATTR_NORMAL: Type = 0;
    pub const IB_FLOW_ATTR_ALL_DEFAULT: Type = 1;
    pub const IB_FLOW_ATTR_MC_DEFAULT: Type = 2;
    pub const IB_FLOW_ATTR_SNIFFER: Type = 3;
}
pub mod ib_flow_spec_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_FLOW_SPEC_ETH: Type = 32;
    pub const IB_FLOW_SPEC_IB: Type = 34;
    pub const IB_FLOW_SPEC_IPV4: Type = 48;
    pub const IB_FLOW_SPEC_IPV6: Type = 49;
    pub const IB_FLOW_SPEC_ESP: Type = 52;
    pub const IB_FLOW_SPEC_TCP: Type = 64;
    pub const IB_FLOW_SPEC_UDP: Type = 65;
    pub const IB_FLOW_SPEC_VXLAN_TUNNEL: Type = 80;
    pub const IB_FLOW_SPEC_GRE: Type = 81;
    pub const IB_FLOW_SPEC_MPLS: Type = 96;
    pub const IB_FLOW_SPEC_INNER: Type = 256;
    pub const IB_FLOW_SPEC_ACTION_TAG: Type = 4096;
    pub const IB_FLOW_SPEC_ACTION_DROP: Type = 4097;
    pub const IB_FLOW_SPEC_ACTION_HANDLE: Type = 4098;
    pub const IB_FLOW_SPEC_ACTION_COUNT: Type = 4099;
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_eth_filter {
    pub dst_mac: [u8_; 6usize],
    pub src_mac: [u8_; 6usize],
    pub ether_type: __be16,
    pub vlan_tag: __be16,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_eth {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_eth_filter,
    pub mask: ib_flow_eth_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_ib_filter {
    pub dlid: __be16,
    pub sl: __u8,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_ib {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_ib_filter,
    pub mask: ib_flow_ib_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_ipv4_filter {
    pub src_ip: __be32,
    pub dst_ip: __be32,
    pub proto: u8_,
    pub tos: u8_,
    pub ttl: u8_,
    pub flags: u8_,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_ipv4 {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_ipv4_filter,
    pub mask: ib_flow_ipv4_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_ipv6_filter {
    pub src_ip: [u8_; 16usize],
    pub dst_ip: [u8_; 16usize],
    pub flow_label: __be32,
    pub next_hdr: u8_,
    pub traffic_class: u8_,
    pub hop_limit: u8_,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_ipv6 {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_ipv6_filter,
    pub mask: ib_flow_ipv6_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_tcp_udp_filter {
    pub dst_port: __be16,
    pub src_port: __be16,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_tcp_udp {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_tcp_udp_filter,
    pub mask: ib_flow_tcp_udp_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_tunnel_filter {
    pub tunnel_id: __be32,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_tunnel {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_tunnel_filter,
    pub mask: ib_flow_tunnel_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_esp_filter {
    pub spi: __be32,
    pub seq: __be32,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_esp {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_esp_filter,
    pub mask: ib_flow_esp_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_gre_filter {
    pub c_ks_res0_ver: __be16,
    pub protocol: __be16,
    pub key: __be32,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_gre {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_gre_filter,
    pub mask: ib_flow_gre_filter,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_mpls_filter {
    pub tag: __be32,
    pub real_sz: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ib_flow_spec_mpls {
    pub type_: u32_,
    pub size: u16_,
    pub val: ib_flow_mpls_filter,
    pub mask: ib_flow_mpls_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_spec_action_tag {
    pub type_: ib_flow_spec_type::Type,
    pub size: u16_,
    pub tag_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_spec_action_drop {
    pub type_: ib_flow_spec_type::Type,
    pub size: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_spec_action_handle {
    pub type_: ib_flow_spec_type::Type,
    pub size: u16_,
    pub act: *mut ib_flow_action,
}
pub mod ib_flow_action_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IB_FLOW_ACTION_UNSPECIFIED: Type = 0;
    pub const IB_FLOW_ACTION_ESP: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_action {
    pub device: *mut ib_device,
    pub uobject: *mut ib_uobject,
    pub type_: ib_flow_action_type::Type,
    pub usecnt: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_spec_action_count {
    pub type_: ib_flow_spec_type::Type,
    pub size: u16_,
    pub counters: *mut ib_counters,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_counters {
    pub device: *mut ib_device,
    pub uobject: *mut ib_uobject,
    pub usecnt: atomic_t,
}
#[repr(C)]
pub struct ib_flow_spec {
    pub __bindgen_anon_1: __BindgenUnionField<ib_flow_spec__bindgen_ty_1>,
    pub eth: __BindgenUnionField<ib_flow_spec_eth>,
    pub ib: __BindgenUnionField<ib_flow_spec_ib>,
    pub ipv4: __BindgenUnionField<ib_flow_spec_ipv4>,
    pub tcp_udp: __BindgenUnionField<ib_flow_spec_tcp_udp>,
    pub ipv6: __BindgenUnionField<ib_flow_spec_ipv6>,
    pub tunnel: __BindgenUnionField<ib_flow_spec_tunnel>,
    pub esp: __BindgenUnionField<ib_flow_spec_esp>,
    pub gre: __BindgenUnionField<ib_flow_spec_gre>,
    pub mpls: __BindgenUnionField<ib_flow_spec_mpls>,
    pub flow_tag: __BindgenUnionField<ib_flow_spec_action_tag>,
    pub drop: __BindgenUnionField<ib_flow_spec_action_drop>,
    pub action: __BindgenUnionField<ib_flow_spec_action_handle>,
    pub flow_count: __BindgenUnionField<ib_flow_spec_action_count>,
    pub bindgen_union_field: [u64; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow_spec__bindgen_ty_1 {
    pub type_: u32_,
    pub size: u16_,
}
#[repr(C)]
pub struct ib_flow_attr {
    pub type_: ib_flow_attr_type::Type,
    pub size: u16_,
    pub priority: u16_,
    pub flags: u32_,
    pub num_of_specs: u8_,
    pub port: u32_,
    pub flows: __IncompleteArrayField<ib_flow_spec>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_flow {
    pub qp: *mut ib_qp,
    pub device: *mut ib_device,
    pub uobject: *mut ib_uobject,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_pkey_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_gid_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port_cache {
    pub subnet_prefix: u64_,
    pub pkey: *mut ib_pkey_cache,
    pub gid: *mut ib_gid_table,
    pub lmc: u8_,
    pub port_state: ib_port_state::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port_immutable {
    pub pkey_tbl_len: ::aya_bpf::cty::c_int,
    pub gid_tbl_len: ::aya_bpf::cty::c_int,
    pub core_cap_flags: u32_,
    pub max_mad_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_port_data {
    pub ib_dev: *mut ib_device,
    pub immutable: ib_port_immutable,
    pub pkey_list_lock: spinlock_t,
    pub netdev_lock: spinlock_t,
    pub pkey_list: list_head,
    pub cache: ib_port_cache,
    pub netdev: *mut net_device,
    pub netdev_tracker: netdevice_tracker,
    pub ndev_hash_link: hlist_node,
    pub port_counter: rdma_port_counter,
    pub sysfs: *mut ib_port,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_netdev_alloc_params {
    pub sizeof_priv: usize,
    pub txqs: ::aya_bpf::cty::c_uint,
    pub rxqs: ::aya_bpf::cty::c_uint,
    pub param: *mut ::aya_bpf::cty::c_void,
    pub initialize_rdma_netdev: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ib_device,
            arg2: u32_,
            arg3: *mut net_device,
            arg4: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_counters_read_attr {
    pub counters_buff: *mut u64_,
    pub ncounters: u32_,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_user_mmap_entry {
    pub ref_: kref,
    pub ucontext: *mut ib_ucontext,
    pub start_pgoff: ::aya_bpf::cty::c_ulong,
    pub npages: usize,
    pub driver_removed: bool_,
}
pub type irq_write_msi_msg_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut msi_desc, arg2: *mut msi_msg)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_msi_priv_data {
    pub dev: *mut device,
    pub host_data: *mut ::aya_bpf::cty::c_void,
    pub arg: msi_alloc_info_t,
    pub write_msg: irq_write_msi_msg_t,
    pub devid: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dax_device {
    pub inode: inode,
    pub cdev: cdev,
    pub private: *mut ::aya_bpf::cty::c_void,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub ops: *const dax_operations,
    pub holder_data: *mut ::aya_bpf::cty::c_void,
    pub holder_ops: *const dax_holder_operations,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dax_holder_operations {
    pub notify_failure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dax_device,
            arg2: u64_,
            arg3: u64_,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_cache_pcpu {
    pub refresh_ts: ::aya_bpf::cty::c_ulong,
    pub dst: *mut dst_entry,
    pub cookie: u32_,
    pub __bindgen_anon_1: dst_cache_pcpu__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dst_cache_pcpu__bindgen_ty_1 {
    pub in_saddr: in_addr,
    pub in6_saddr: in6_addr,
}
#[repr(C)]
pub struct xsk_buff_pool {
    pub dev: *mut device,
    pub netdev: *mut net_device,
    pub xsk_tx_list: list_head,
    pub xsk_tx_list_lock: spinlock_t,
    pub users: refcount_t,
    pub umem: *mut xdp_umem,
    pub work: work_struct,
    pub free_list: list_head,
    pub heads_cnt: u32_,
    pub queue_id: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub fq: *mut xsk_queue,
    pub cq: *mut xsk_queue,
    pub dma_pages: *mut dma_addr_t,
    pub heads: *mut xdp_buff_xsk,
    pub tx_descs: *mut xdp_desc,
    pub chunk_mask: u64_,
    pub addrs_cnt: u64_,
    pub free_list_cnt: u32_,
    pub dma_pages_cnt: u32_,
    pub free_heads_cnt: u32_,
    pub headroom: u32_,
    pub chunk_size: u32_,
    pub chunk_shift: u32_,
    pub frame_len: u32_,
    pub cached_need_wakeup: u8_,
    pub uses_need_wakeup: bool_,
    pub dma_need_sync: bool_,
    pub unaligned: bool_,
    pub addrs: *mut ::aya_bpf::cty::c_void,
    pub cq_lock: spinlock_t,
    pub free_heads: __IncompleteArrayField<*mut xdp_buff_xsk>,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 24usize]>,
}
impl xsk_buff_pool {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_desc {
    pub addr: __u64,
    pub len: __u32,
    pub options: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_umem {
    pub addrs: *mut ::aya_bpf::cty::c_void,
    pub size: u64_,
    pub headroom: u32_,
    pub chunk_size: u32_,
    pub chunks: u32_,
    pub npgs: u32_,
    pub user: *mut user_struct,
    pub users: refcount_t,
    pub flags: u8_,
    pub zc: bool_,
    pub pgs: *mut *mut page,
    pub id: ::aya_bpf::cty::c_int,
    pub xsk_dma_list: list_head,
    pub work: work_struct,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_buff_xsk {
    pub xdp: xdp_buff,
    pub dma: dma_addr_t,
    pub frame_dma: dma_addr_t,
    pub pool: *mut xsk_buff_pool,
    pub orig_addr: u64_,
    pub free_list_node: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xsk_queue {
    pub ring_mask: u32_,
    pub nentries: u32_,
    pub cached_prod: u32_,
    pub cached_cons: u32_,
    pub ring: *mut xdp_ring,
    pub invalid_descs: u64_,
    pub queue_empty_descs: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_ring {
    pub producer: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_0: u32,
    pub pad1: u32_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_1: u32,
    pub consumer: u32_,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_2: u32,
    pub pad2: u32_,
    pub flags: u32_,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub pad3: u32_,
    pub _bitfield_align_5: [u8; 0],
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_3: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct param_attribute {
    pub mattr: module_attribute,
    pub param: *const kernel_param,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_param_attrs {
    pub num: ::aya_bpf::cty::c_uint,
    pub grp: attribute_group,
    pub attrs: __IncompleteArrayField<param_attribute>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_exp_work {
    pub rew_s: ::aya_bpf::cty::c_ulong,
    pub rew_work: work_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_node {
    pub lock: raw_spinlock_t,
    pub gp_seq: ::aya_bpf::cty::c_ulong,
    pub gp_seq_needed: ::aya_bpf::cty::c_ulong,
    pub completedqs: ::aya_bpf::cty::c_ulong,
    pub qsmask: ::aya_bpf::cty::c_ulong,
    pub rcu_gp_init_mask: ::aya_bpf::cty::c_ulong,
    pub qsmaskinit: ::aya_bpf::cty::c_ulong,
    pub qsmaskinitnext: ::aya_bpf::cty::c_ulong,
    pub expmask: ::aya_bpf::cty::c_ulong,
    pub expmaskinit: ::aya_bpf::cty::c_ulong,
    pub expmaskinitnext: ::aya_bpf::cty::c_ulong,
    pub cbovldmask: ::aya_bpf::cty::c_ulong,
    pub ffmask: ::aya_bpf::cty::c_ulong,
    pub grpmask: ::aya_bpf::cty::c_ulong,
    pub grplo: ::aya_bpf::cty::c_int,
    pub grphi: ::aya_bpf::cty::c_int,
    pub grpnum: u8_,
    pub level: u8_,
    pub wait_blkd_tasks: bool_,
    pub parent: *mut rcu_node,
    pub blkd_tasks: list_head,
    pub gp_tasks: *mut list_head,
    pub exp_tasks: *mut list_head,
    pub boost_tasks: *mut list_head,
    pub boost_mtx: rt_mutex,
    pub boost_time: ::aya_bpf::cty::c_ulong,
    pub boost_kthread_mutex: mutex,
    pub boost_kthread_task: *mut task_struct,
    pub boost_kthread_status: ::aya_bpf::cty::c_uint,
    pub n_boosts: ::aya_bpf::cty::c_ulong,
    pub nocb_gp_wq: [swait_queue_head; 2usize],
    pub fqslock: raw_spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_0: u32,
    pub exp_lock: spinlock_t,
    pub exp_seq_rq: ::aya_bpf::cty::c_ulong,
    pub exp_wq: [wait_queue_head_t; 4usize],
    pub rew: rcu_exp_work,
    pub exp_need_flush: bool_,
    pub exp_poll_lock: raw_spinlock_t,
    pub exp_seq_poll_rq: ::aya_bpf::cty::c_ulong,
    pub exp_poll_wq: work_struct,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 56usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_prog_offload_ops {
    pub insn_hook: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub finalize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut bpf_verifier_env) -> ::aya_bpf::cty::c_int,
    >,
    pub replace_insn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: u32_,
            arg3: *mut bpf_insn,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub remove_insns: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut bpf_verifier_env,
            arg2: u32_,
            arg3: u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf::cty::c_int>,
    pub translate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog) -> ::aya_bpf::cty::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut bpf_prog)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_offload_dev {
    pub ops: *const bpf_prog_offload_ops,
    pub netdevs: list_head,
    pub priv_: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub ops: *const uprobe_xol_ops,
    pub __bindgen_anon_2: arch_uprobe__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 16usize],
    pub ixol: [u8_; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_2 {
    pub branch: arch_uprobe__bindgen_ty_2__bindgen_ty_1,
    pub defparam: arch_uprobe__bindgen_ty_2__bindgen_ty_2,
    pub push: arch_uprobe__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub offs: s32,
    pub ilen: u8_,
    pub opc1: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fixups: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub reg_offset: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_xol_ops {
    pub emulate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> bool_,
    >,
    pub pre_xol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> ::aya_bpf::cty::c_int,
    >,
    pub post_xol: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs) -> ::aya_bpf::cty::c_int,
    >,
    pub abort:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut arch_uprobe, arg2: *mut pt_regs)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe {
    pub rb_node: rb_node,
    pub ref_: refcount_t,
    pub register_rwsem: rw_semaphore,
    pub consumer_rwsem: rw_semaphore,
    pub pending_list: list_head,
    pub consumers: *mut uprobe_consumer,
    pub inode: *mut inode,
    pub offset: loff_t,
    pub ref_ctr_offset: loff_t,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub arch: arch_uprobe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xol_area {
    pub wq: wait_queue_head_t,
    pub slot_count: atomic_t,
    pub bitmap: *mut ::aya_bpf::cty::c_ulong,
    pub xol_mapping: vm_special_mapping,
    pub pages: [*mut page; 2usize],
    pub vaddr: ::aya_bpf::cty::c_ulong,
}
pub type free_work_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_wq_work) -> *mut io_wq_work>;
pub type io_wq_work_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut io_wq_work)>;
#[repr(C)]
pub struct io_wq {
    pub state: ::aya_bpf::cty::c_ulong,
    pub free_work: free_work_fn,
    pub do_work: io_wq_work_fn,
    pub hash: *mut io_wq_hash,
    pub worker_refs: atomic_t,
    pub worker_done: completion,
    pub cpuhp_node: hlist_node,
    pub task: *mut task_struct,
    pub wqes: __IncompleteArrayField<*mut io_wqe>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_wqe_acct {
    pub nr_workers: ::aya_bpf::cty::c_uint,
    pub max_workers: ::aya_bpf::cty::c_uint,
    pub index: ::aya_bpf::cty::c_int,
    pub nr_running: atomic_t,
    pub lock: raw_spinlock_t,
    pub work_list: io_wq_work_list,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_wqe {
    pub lock: raw_spinlock_t,
    pub acct: [io_wqe_acct; 2usize],
    pub node: ::aya_bpf::cty::c_int,
    pub free_list: hlist_nulls_head,
    pub all_list: list_head,
    pub wait: wait_queue_entry,
    pub wq: *mut io_wq,
    pub hash_tail: [*mut io_wq_work; 64usize],
    pub cpu_mask: cpumask_var_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    pub kobj: kobject,
    pub devices_kobj: *mut kobject,
    pub devices: list_head,
    pub pasid_array: xarray,
    pub mutex: mutex,
    pub iommu_data: *mut ::aya_bpf::cty::c_void,
    pub iommu_data_release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub id: ::aya_bpf::cty::c_int,
    pub default_domain: *mut iommu_domain,
    pub blocking_domain: *mut iommu_domain,
    pub domain: *mut iommu_domain,
    pub entry: list_head,
    pub owner_cnt: ::aya_bpf::cty::c_uint,
    pub owner: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dm_hw_stat_delta {
    pub last_rx: ::aya_bpf::cty::c_ulong,
    pub last_drop_val: ::aya_bpf::cty::c_ulong,
    pub rcu: callback_head,
}
pub mod devlink_trap_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_TRAP_TYPE_DROP: Type = 0;
    pub const DEVLINK_TRAP_TYPE_EXCEPTION: Type = 1;
    pub const DEVLINK_TRAP_TYPE_CONTROL: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dev_stats {
    pub reload_stats: [u32_; 6usize],
    pub remote_reload_stats: [u32_; 6usize],
}
#[repr(C)]
pub struct devlink {
    pub index: u32_,
    pub ports: xarray,
    pub rate_list: list_head,
    pub sb_list: list_head,
    pub dpipe_table_list: list_head,
    pub resource_list: list_head,
    pub param_list: list_head,
    pub region_list: list_head,
    pub reporter_list: list_head,
    pub reporters_lock: mutex,
    pub dpipe_headers: *mut devlink_dpipe_headers,
    pub trap_list: list_head,
    pub trap_group_list: list_head,
    pub trap_policer_list: list_head,
    pub linecard_list: list_head,
    pub linecards_lock: mutex,
    pub ops: *const devlink_ops,
    pub features: u64_,
    pub snapshot_ids: xarray,
    pub stats: devlink_dev_stats,
    pub dev: *mut device,
    pub _net: possible_net_t,
    pub lock: mutex,
    pub lock_key: lock_class_key,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub refcount: refcount_t,
    pub comp: completion,
    pub rcu: callback_head,
    pub netdevice_nb: notifier_block,
    pub priv_: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
impl devlink {
    #[inline]
    pub fn reload_failed(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reload_failed(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reload_failed: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reload_failed: u8 = unsafe { ::core::mem::transmute(reload_failed) };
            reload_failed as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod devlink_eswitch_encap_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_ESWITCH_ENCAP_MODE_NONE: Type = 0;
    pub const DEVLINK_ESWITCH_ENCAP_MODE_BASIC: Type = 1;
}
pub mod devlink_selftest_status {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_SELFTEST_STATUS_SKIP: Type = 0;
    pub const DEVLINK_SELFTEST_STATUS_PASS: Type = 1;
    pub const DEVLINK_SELFTEST_STATUS_FAIL: Type = 2;
}
pub mod devlink_trap_action {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_TRAP_ACTION_DROP: Type = 0;
    pub const DEVLINK_TRAP_ACTION_TRAP: Type = 1;
    pub const DEVLINK_TRAP_ACTION_MIRROR: Type = 2;
}
pub mod devlink_reload_action {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_RELOAD_ACTION_UNSPEC: Type = 0;
    pub const DEVLINK_RELOAD_ACTION_DRIVER_REINIT: Type = 1;
    pub const DEVLINK_RELOAD_ACTION_FW_ACTIVATE: Type = 2;
    pub const __DEVLINK_RELOAD_ACTION_MAX: Type = 3;
    pub const DEVLINK_RELOAD_ACTION_MAX: Type = 2;
}
pub mod devlink_reload_limit {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_RELOAD_LIMIT_UNSPEC: Type = 0;
    pub const DEVLINK_RELOAD_LIMIT_NO_RESET: Type = 1;
    pub const __DEVLINK_RELOAD_LIMIT_MAX: Type = 2;
    pub const DEVLINK_RELOAD_LIMIT_MAX: Type = 1;
}
pub mod devlink_linecard_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_LINECARD_STATE_UNSPEC: Type = 0;
    pub const DEVLINK_LINECARD_STATE_UNPROVISIONED: Type = 1;
    pub const DEVLINK_LINECARD_STATE_UNPROVISIONING: Type = 2;
    pub const DEVLINK_LINECARD_STATE_PROVISIONING: Type = 3;
    pub const DEVLINK_LINECARD_STATE_PROVISIONING_FAILED: Type = 4;
    pub const DEVLINK_LINECARD_STATE_PROVISIONED: Type = 5;
    pub const DEVLINK_LINECARD_STATE_ACTIVE: Type = 6;
    pub const __DEVLINK_LINECARD_STATE_MAX: Type = 7;
    pub const DEVLINK_LINECARD_STATE_MAX: Type = 6;
}
pub mod devlink_dpipe_field_mapping_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE: Type = 0;
    pub const DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX: Type = 1;
}
pub mod devlink_port_fn_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_PORT_FN_STATE_INACTIVE: Type = 0;
    pub const DEVLINK_PORT_FN_STATE_ACTIVE: Type = 1;
}
pub mod devlink_port_fn_opstate {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_PORT_FN_OPSTATE_DETACHED: Type = 0;
    pub const DEVLINK_PORT_FN_OPSTATE_ATTACHED: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink_linecard {
    pub list: list_head,
    pub devlink: *mut devlink,
    pub index: ::aya_bpf::cty::c_uint,
    pub refcount: refcount_t,
    pub ops: *const devlink_linecard_ops,
    pub priv_: *mut ::aya_bpf::cty::c_void,
    pub state: devlink_linecard_state::Type,
    pub state_lock: mutex,
    pub type_: *const ::aya_bpf::cty::c_char,
    pub types: *mut devlink_linecard_type,
    pub types_count: ::aya_bpf::cty::c_uint,
    pub nested_devlink: *mut devlink,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_port_new_attrs {
    pub flavour: devlink_port_flavour::Type,
    pub port_index: ::aya_bpf::cty::c_uint,
    pub controller: u32_,
    pub sfnum: u32_,
    pub pfnum: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl devlink_port_new_attrs {
    #[inline]
    pub fn port_index_valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_port_index_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn controller_valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_controller_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sfnum_valid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sfnum_valid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        port_index_valid: u8_,
        controller_valid: u8_,
        sfnum_valid: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let port_index_valid: u8 = unsafe { ::core::mem::transmute(port_index_valid) };
            port_index_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let controller_valid: u8 = unsafe { ::core::mem::transmute(controller_valid) };
            controller_valid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sfnum_valid: u8 = unsafe { ::core::mem::transmute(sfnum_valid) };
            sfnum_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_linecard_ops {
    pub provision: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_linecard,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: *const ::aya_bpf::cty::c_void,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub unprovision: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_linecard,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub same_provision: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_linecard,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *const ::aya_bpf::cty::c_char,
            arg4: *const ::aya_bpf::cty::c_void,
        ) -> bool_,
    >,
    pub types_count: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_linecard,
            arg2: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_uint,
    >,
    pub types_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_linecard,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut *const ::aya_bpf::cty::c_char,
            arg5: *mut *const ::aya_bpf::cty::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_field {
    pub name: *const ::aya_bpf::cty::c_char,
    pub id: ::aya_bpf::cty::c_uint,
    pub bitwidth: ::aya_bpf::cty::c_uint,
    pub mapping_type: devlink_dpipe_field_mapping_type::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_header {
    pub name: *const ::aya_bpf::cty::c_char,
    pub id: ::aya_bpf::cty::c_uint,
    pub fields: *mut devlink_dpipe_field,
    pub fields_count: ::aya_bpf::cty::c_uint,
    pub global: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_dpipe_headers {
    pub headers: *mut *mut devlink_dpipe_header,
    pub headers_count: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_flash_update_params {
    pub fw: *const firmware,
    pub component: *const ::aya_bpf::cty::c_char,
    pub overwrite_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap_policer {
    pub id: u32_,
    pub init_rate: u64_,
    pub init_burst: u64_,
    pub max_rate: u64_,
    pub min_rate: u64_,
    pub max_burst: u64_,
    pub min_burst: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap_group {
    pub name: *const ::aya_bpf::cty::c_char,
    pub id: u16_,
    pub generic: bool_,
    pub init_policer_id: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_trap {
    pub type_: devlink_trap_type::Type,
    pub init_action: devlink_trap_action::Type,
    pub generic: bool_,
    pub id: u16_,
    pub name: *const ::aya_bpf::cty::c_char,
    pub init_group_id: u16_,
    pub metadata_cap: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_ops {
    pub supported_flash_update_params: u32_,
    pub reload_actions: ::aya_bpf::cty::c_ulong,
    pub reload_limits: ::aya_bpf::cty::c_ulong,
    pub reload_down: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: bool_,
            arg3: devlink_reload_action::Type,
            arg4: devlink_reload_limit::Type,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub reload_up: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: devlink_reload_action::Type,
            arg3: devlink_reload_limit::Type,
            arg4: *mut u32_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_type_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: devlink_port_type::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_split: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_port,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_unsplit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_port,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: *mut devlink_sb_pool_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: u32_,
            arg5: devlink_sb_threshold_type::Type,
            arg6: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_port_pool_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: u32_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_tc_pool_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: *mut u16_,
            arg6: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_tc_pool_bind_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: u16_,
            arg6: u32_,
            arg7: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_occ_snapshot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_occ_max_clear: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_occ_port_pool_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: *mut u32_,
            arg5: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub sb_occ_tc_port_bind_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: u16_,
            arg4: devlink_sb_pool_type::Type,
            arg5: *mut u32_,
            arg6: *mut u32_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_mode_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u16_) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: u16_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_inline_mode_get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *mut u8_) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_inline_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: u8_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_encap_mode_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_eswitch_encap_mode::Type,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub eswitch_encap_mode_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: devlink_eswitch_encap_mode::Type,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub info_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_info_req,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flash_update: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *mut devlink_flash_update_params,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: *mut ::aya_bpf::cty::c_void,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_fini: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: *mut ::aya_bpf::cty::c_void,
        ),
    >,
    pub trap_action_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: devlink_trap_action::Type,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_group_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_group_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
            arg3: *const devlink_trap_policer,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_group_action_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_group,
            arg3: devlink_trap_action::Type,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_drop_counter_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap,
            arg3: *mut u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_policer_init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_policer_fini: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut devlink, arg2: *const devlink_trap_policer),
    >,
    pub trap_policer_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
            arg3: u64_,
            arg4: u64_,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub trap_policer_counter_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_trap_policer,
            arg3: *mut u64_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_function_hw_addr_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: *mut u8_,
            arg3: *mut ::aya_bpf::cty::c_int,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_function_hw_addr_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: *const u8_,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_roce_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: *mut bool_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_roce_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: bool_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_migratable_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: *mut bool_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_migratable_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: bool_,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_new: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: *const devlink_port_new_attrs,
            arg3: *mut netlink_ext_ack,
            arg4: *mut ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_state_get: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: *mut devlink_port_fn_state::Type,
            arg3: *mut devlink_port_fn_opstate::Type,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub port_fn_state_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_port,
            arg2: devlink_port_fn_state::Type,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_leaf_tx_share_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u64_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_leaf_tx_max_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u64_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_leaf_tx_priority_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_leaf_tx_weight_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_tx_share_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u64_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_tx_max_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u64_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_tx_priority_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_tx_weight_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: u32_,
            arg4: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_new: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut *mut ::aya_bpf::cty::c_void,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_del: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut ::aya_bpf::cty::c_void,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_leaf_parent_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut devlink_rate,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: *mut ::aya_bpf::cty::c_void,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rate_node_parent_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink_rate,
            arg2: *mut devlink_rate,
            arg3: *mut ::aya_bpf::cty::c_void,
            arg4: *mut ::aya_bpf::cty::c_void,
            arg5: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub selftest_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: *mut netlink_ext_ack,
        ) -> bool_,
    >,
    pub selftest_run: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut devlink,
            arg2: ::aya_bpf::cty::c_uint,
            arg3: *mut netlink_ext_ack,
        ) -> devlink_selftest_status::Type,
    >,
}
pub mod devlink_info_version_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const DEVLINK_INFO_VERSION_TYPE_NONE: Type = 0;
    pub const DEVLINK_INFO_VERSION_TYPE_COMPONENT: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_info_req {
    pub msg: *mut sk_buff,
    pub version_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: devlink_info_version_type::Type,
            arg3: *mut ::aya_bpf::cty::c_void,
        ),
    >,
    pub version_cb_priv: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devlink_linecard_type {
    pub type_: *const ::aya_bpf::cty::c_char,
    pub priv_: *const ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ioam6_pernet_data {
    pub lock: mutex,
    pub namespaces: rhashtable,
    pub schemas: rhashtable,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cma {
    pub base_pfn: ::aya_bpf::cty::c_ulong,
    pub count: ::aya_bpf::cty::c_ulong,
    pub bitmap: *mut ::aya_bpf::cty::c_ulong,
    pub order_per_bit: ::aya_bpf::cty::c_uint,
    pub lock: spinlock_t,
    pub name: [::aya_bpf::cty::c_char; 64usize],
    pub reserve_pages_on_error: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prog_entry {
    pub target: ::aya_bpf::cty::c_int,
    pub when_to_branch: ::aya_bpf::cty::c_int,
    pub pred: *mut filter_pred,
}
pub type regex_match_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_bpf::cty::c_char,
        arg2: *mut regex,
        arg3: ::aya_bpf::cty::c_int,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex {
    pub pattern: [::aya_bpf::cty::c_char; 256usize],
    pub len: ::aya_bpf::cty::c_int,
    pub field_len: ::aya_bpf::cty::c_int,
    pub match_: regex_match_func,
}
pub mod filter_pred_fn {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const FILTER_PRED_FN_NOP: Type = 0;
    pub const FILTER_PRED_FN_64: Type = 1;
    pub const FILTER_PRED_FN_S64: Type = 2;
    pub const FILTER_PRED_FN_U64: Type = 3;
    pub const FILTER_PRED_FN_32: Type = 4;
    pub const FILTER_PRED_FN_S32: Type = 5;
    pub const FILTER_PRED_FN_U32: Type = 6;
    pub const FILTER_PRED_FN_16: Type = 7;
    pub const FILTER_PRED_FN_S16: Type = 8;
    pub const FILTER_PRED_FN_U16: Type = 9;
    pub const FILTER_PRED_FN_8: Type = 10;
    pub const FILTER_PRED_FN_S8: Type = 11;
    pub const FILTER_PRED_FN_U8: Type = 12;
    pub const FILTER_PRED_FN_COMM: Type = 13;
    pub const FILTER_PRED_FN_STRING: Type = 14;
    pub const FILTER_PRED_FN_STRLOC: Type = 15;
    pub const FILTER_PRED_FN_STRRELLOC: Type = 16;
    pub const FILTER_PRED_FN_PCHAR_USER: Type = 17;
    pub const FILTER_PRED_FN_PCHAR: Type = 18;
    pub const FILTER_PRED_FN_CPU: Type = 19;
    pub const FILTER_PRED_FN_: Type = 20;
    pub const FILTER_PRED_TEST_VISITED: Type = 21;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filter_pred {
    pub fn_num: filter_pred_fn::Type,
    pub val: u64_,
    pub regex: regex,
    pub ops: *mut ::aya_bpf::cty::c_ushort,
    pub field: *mut ftrace_event_field,
    pub offset: ::aya_bpf::cty::c_int,
    pub not: ::aya_bpf::cty::c_int,
    pub op: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdp_dev_bulk_queue {
    pub q: [*mut xdp_frame; 16usize],
    pub flush_node: list_head,
    pub dev: *mut net_device,
    pub dev_rx: *mut net_device,
    pub xdp_prog: *mut bpf_prog,
    pub count: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_key_mod {
    pub next: *mut static_key_mod,
    pub entries: *mut jump_entry,
    pub mod_: *mut module,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_iocb {
    pub iocb: kiocb,
    pub bvec: [bio_vec; 32usize],
    pub pages: ::aya_bpf::cty::c_int,
    pub len: ::aya_bpf::cty::c_int,
}
pub mod iommu_dma_cookie_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IOMMU_DMA_IOVA_COOKIE: Type = 0;
    pub const IOMMU_DMA_MSI_COOKIE: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_dma_cookie {
    pub type_: iommu_dma_cookie_type::Type,
    pub __bindgen_anon_1: iommu_dma_cookie__bindgen_ty_1,
    pub msi_page_list: list_head,
    pub fq_domain: *mut iommu_domain,
    pub mutex: mutex,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iommu_dma_cookie__bindgen_ty_1 {
    pub __bindgen_anon_1: iommu_dma_cookie__bindgen_ty_1__bindgen_ty_1,
    pub msi_iova: dma_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_dma_cookie__bindgen_ty_1__bindgen_ty_1 {
    pub iovad: iova_domain,
    pub fq: *mut iova_fq,
    pub fq_flush_start_cnt: atomic64_t,
    pub fq_flush_finish_cnt: atomic64_t,
    pub fq_timer: timer_list,
    pub fq_timer_on: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iova_fq_entry {
    pub iova_pfn: ::aya_bpf::cty::c_ulong,
    pub pages: ::aya_bpf::cty::c_ulong,
    pub freelist: list_head,
    pub counter: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iova_fq {
    pub entries: [iova_fq_entry; 256usize],
    pub head: ::aya_bpf::cty::c_uint,
    pub tail: ::aya_bpf::cty::c_uint,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_rate_estimator {
    pub bstats: *mut gnet_stats_basic_sync,
    pub stats_lock: *mut spinlock_t,
    pub running: bool_,
    pub cpu_bstats: *mut gnet_stats_basic_sync,
    pub ewma_log: u8_,
    pub intvl_log: u8_,
    pub seq: seqcount_t,
    pub last_packets: u64_,
    pub last_bytes: u64_,
    pub avpps: u64_,
    pub avbps: u64_,
    pub next_jiffies: ::aya_bpf::cty::c_ulong,
    pub timer: timer_list,
    pub rcu: callback_head,
}
pub mod nl80211_iftype {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_IFTYPE_UNSPECIFIED: Type = 0;
    pub const NL80211_IFTYPE_ADHOC: Type = 1;
    pub const NL80211_IFTYPE_STATION: Type = 2;
    pub const NL80211_IFTYPE_AP: Type = 3;
    pub const NL80211_IFTYPE_AP_VLAN: Type = 4;
    pub const NL80211_IFTYPE_WDS: Type = 5;
    pub const NL80211_IFTYPE_MONITOR: Type = 6;
    pub const NL80211_IFTYPE_MESH_POINT: Type = 7;
    pub const NL80211_IFTYPE_P2P_CLIENT: Type = 8;
    pub const NL80211_IFTYPE_P2P_GO: Type = 9;
    pub const NL80211_IFTYPE_P2P_DEVICE: Type = 10;
    pub const NL80211_IFTYPE_OCB: Type = 11;
    pub const NL80211_IFTYPE_NAN: Type = 12;
    pub const NUM_NL80211_IFTYPES: Type = 13;
    pub const NL80211_IFTYPE_MAX: Type = 12;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_conn {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_cached_keys {
    _unused: [u8; 0],
}
pub mod ieee80211_bss_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IEEE80211_BSS_TYPE_ESS: Type = 0;
    pub const IEEE80211_BSS_TYPE_PBSS: Type = 1;
    pub const IEEE80211_BSS_TYPE_IBSS: Type = 2;
    pub const IEEE80211_BSS_TYPE_MBSS: Type = 3;
    pub const IEEE80211_BSS_TYPE_ANY: Type = 4;
}
pub mod nl80211_chan_width {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_CHAN_WIDTH_20_NOHT: Type = 0;
    pub const NL80211_CHAN_WIDTH_20: Type = 1;
    pub const NL80211_CHAN_WIDTH_40: Type = 2;
    pub const NL80211_CHAN_WIDTH_80: Type = 3;
    pub const NL80211_CHAN_WIDTH_80P80: Type = 4;
    pub const NL80211_CHAN_WIDTH_160: Type = 5;
    pub const NL80211_CHAN_WIDTH_5: Type = 6;
    pub const NL80211_CHAN_WIDTH_10: Type = 7;
    pub const NL80211_CHAN_WIDTH_1: Type = 8;
    pub const NL80211_CHAN_WIDTH_2: Type = 9;
    pub const NL80211_CHAN_WIDTH_4: Type = 10;
    pub const NL80211_CHAN_WIDTH_8: Type = 11;
    pub const NL80211_CHAN_WIDTH_16: Type = 12;
    pub const NL80211_CHAN_WIDTH_320: Type = 13;
}
pub mod ieee80211_edmg_bw_config {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IEEE80211_EDMG_BW_CONFIG_4: Type = 4;
    pub const IEEE80211_EDMG_BW_CONFIG_5: Type = 5;
    pub const IEEE80211_EDMG_BW_CONFIG_6: Type = 6;
    pub const IEEE80211_EDMG_BW_CONFIG_7: Type = 7;
    pub const IEEE80211_EDMG_BW_CONFIG_8: Type = 8;
    pub const IEEE80211_EDMG_BW_CONFIG_9: Type = 9;
    pub const IEEE80211_EDMG_BW_CONFIG_10: Type = 10;
    pub const IEEE80211_EDMG_BW_CONFIG_11: Type = 11;
    pub const IEEE80211_EDMG_BW_CONFIG_12: Type = 12;
    pub const IEEE80211_EDMG_BW_CONFIG_13: Type = 13;
    pub const IEEE80211_EDMG_BW_CONFIG_14: Type = 14;
    pub const IEEE80211_EDMG_BW_CONFIG_15: Type = 15;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_edmg {
    pub channels: u8_,
    pub bw_config: ieee80211_edmg_bw_config::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_chan_def {
    pub chan: *mut ieee80211_channel,
    pub width: nl80211_chan_width::Type,
    pub center_freq1: u32_,
    pub center_freq2: u32_,
    pub edmg: ieee80211_edmg,
    pub freq1_offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_mcs_info {
    pub rx_mask: [u8_; 10usize],
    pub rx_highest: __le16,
    pub tx_params: u8_,
    pub reserved: [u8_; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_ht_cap {
    pub cap_info: __le16,
    pub ampdu_params_info: u8_,
    pub mcs: ieee80211_mcs_info,
    pub extended_ht_cap_info: __le16,
    pub tx_BF_cap_info: __le32,
    pub antenna_selection_info: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_ibss_params {
    pub ssid: *const u8_,
    pub bssid: *const u8_,
    pub chandef: cfg80211_chan_def,
    pub ie: *const u8_,
    pub ssid_len: u8_,
    pub ie_len: u8_,
    pub beacon_interval: u16_,
    pub basic_rates: u32_,
    pub channel_fixed: bool_,
    pub privacy: bool_,
    pub control_port: bool_,
    pub control_port_over_nl80211: bool_,
    pub userspace_handles_dfs: bool_,
    pub mcast_rate: [::aya_bpf::cty::c_int; 6usize],
    pub ht_capa: ieee80211_ht_cap,
    pub ht_capa_mask: ieee80211_ht_cap,
    pub wep_keys: *mut key_params,
    pub wep_tx_key: ::aya_bpf::cty::c_int,
}
pub mod nl80211_auth_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_AUTHTYPE_OPEN_SYSTEM: Type = 0;
    pub const NL80211_AUTHTYPE_SHARED_KEY: Type = 1;
    pub const NL80211_AUTHTYPE_FT: Type = 2;
    pub const NL80211_AUTHTYPE_NETWORK_EAP: Type = 3;
    pub const NL80211_AUTHTYPE_SAE: Type = 4;
    pub const NL80211_AUTHTYPE_FILS_SK: Type = 5;
    pub const NL80211_AUTHTYPE_FILS_SK_PFS: Type = 6;
    pub const NL80211_AUTHTYPE_FILS_PK: Type = 7;
    pub const __NL80211_AUTHTYPE_NUM: Type = 8;
    pub const NL80211_AUTHTYPE_MAX: Type = 7;
    pub const NL80211_AUTHTYPE_AUTOMATIC: Type = 8;
}
pub mod nl80211_mfp {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_MFP_NO: Type = 0;
    pub const NL80211_MFP_REQUIRED: Type = 1;
    pub const NL80211_MFP_OPTIONAL: Type = 2;
}
pub mod nl80211_sae_pwe_mechanism {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_SAE_PWE_UNSPECIFIED: Type = 0;
    pub const NL80211_SAE_PWE_HUNT_AND_PECK: Type = 1;
    pub const NL80211_SAE_PWE_HASH_TO_ELEMENT: Type = 2;
    pub const NL80211_SAE_PWE_BOTH: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_crypto_settings {
    pub wpa_versions: u32_,
    pub cipher_group: u32_,
    pub n_ciphers_pairwise: ::aya_bpf::cty::c_int,
    pub ciphers_pairwise: [u32_; 5usize],
    pub n_akm_suites: ::aya_bpf::cty::c_int,
    pub akm_suites: [u32_; 10usize],
    pub control_port: bool_,
    pub control_port_ethertype: __be16,
    pub control_port_no_encrypt: bool_,
    pub control_port_over_nl80211: bool_,
    pub control_port_no_preauth: bool_,
    pub wep_keys: *mut key_params,
    pub wep_tx_key: ::aya_bpf::cty::c_int,
    pub psk: *const u8_,
    pub sae_pwd: *const u8_,
    pub sae_pwd_len: u8_,
    pub sae_pwe: nl80211_sae_pwe_mechanism::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_vht_mcs_info {
    pub rx_mcs_map: __le16,
    pub rx_highest: __le16,
    pub tx_mcs_map: __le16,
    pub tx_highest: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_vht_cap {
    pub vht_cap_info: __le32,
    pub supp_mcs: ieee80211_vht_mcs_info,
}
pub mod nl80211_bss_select_attr {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const __NL80211_BSS_SELECT_ATTR_INVALID: Type = 0;
    pub const NL80211_BSS_SELECT_ATTR_RSSI: Type = 1;
    pub const NL80211_BSS_SELECT_ATTR_BAND_PREF: Type = 2;
    pub const NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: Type = 3;
    pub const __NL80211_BSS_SELECT_ATTR_AFTER_LAST: Type = 4;
    pub const NL80211_BSS_SELECT_ATTR_MAX: Type = 3;
}
pub mod nl80211_band {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_BAND_2GHZ: Type = 0;
    pub const NL80211_BAND_5GHZ: Type = 1;
    pub const NL80211_BAND_60GHZ: Type = 2;
    pub const NL80211_BAND_6GHZ: Type = 3;
    pub const NL80211_BAND_S1GHZ: Type = 4;
    pub const NL80211_BAND_LC: Type = 5;
    pub const NUM_NL80211_BANDS: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_bss_select_adjust {
    pub band: nl80211_band::Type,
    pub delta: s8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfg80211_bss_selection {
    pub behaviour: nl80211_bss_select_attr::Type,
    pub param: cfg80211_bss_selection__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cfg80211_bss_selection__bindgen_ty_1 {
    pub band_pref: nl80211_band::Type,
    pub adjust: cfg80211_bss_select_adjust,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfg80211_connect_params {
    pub channel: *mut ieee80211_channel,
    pub channel_hint: *mut ieee80211_channel,
    pub bssid: *const u8_,
    pub bssid_hint: *const u8_,
    pub ssid: *const u8_,
    pub ssid_len: usize,
    pub auth_type: nl80211_auth_type::Type,
    pub ie: *const u8_,
    pub ie_len: usize,
    pub privacy: bool_,
    pub mfp: nl80211_mfp::Type,
    pub crypto: cfg80211_crypto_settings,
    pub key: *const u8_,
    pub key_len: u8_,
    pub key_idx: u8_,
    pub flags: u32_,
    pub bg_scan_period: ::aya_bpf::cty::c_int,
    pub ht_capa: ieee80211_ht_cap,
    pub ht_capa_mask: ieee80211_ht_cap,
    pub vht_capa: ieee80211_vht_cap,
    pub vht_capa_mask: ieee80211_vht_cap,
    pub pbss: bool_,
    pub bss_select: cfg80211_bss_selection,
    pub prev_bssid: *const u8_,
    pub fils_erp_username: *const u8_,
    pub fils_erp_username_len: usize,
    pub fils_erp_realm: *const u8_,
    pub fils_erp_realm_len: usize,
    pub fils_erp_next_seq_num: u16_,
    pub fils_erp_rrk: *const u8_,
    pub fils_erp_rrk_len: usize,
    pub want_1x: bool_,
    pub edmg: ieee80211_edmg,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_cqm_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_internal_bss {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev {
    pub wiphy: *mut wiphy,
    pub iftype: nl80211_iftype::Type,
    pub list: list_head,
    pub netdev: *mut net_device,
    pub identifier: u32_,
    pub mgmt_registrations: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mtx: mutex,
    pub use_4addr: bool_,
    pub is_running: bool_,
    pub registered: bool_,
    pub registering: bool_,
    pub address: [u8_; 6usize],
    pub conn: *mut cfg80211_conn,
    pub connect_keys: *mut cfg80211_cached_keys,
    pub conn_bss_type: ieee80211_bss_type::Type,
    pub conn_owner_nlportid: u32_,
    pub disconnect_wk: work_struct,
    pub disconnect_bssid: [u8_; 6usize],
    pub event_list: list_head,
    pub event_lock: spinlock_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ps: bool_,
    pub ps_timeout: ::aya_bpf::cty::c_int,
    pub ap_unexpected_nlportid: u32_,
    pub owner_nlportid: u32_,
    pub nl_owner_dead: bool_,
    pub cac_started: bool_,
    pub cac_start_time: ::aya_bpf::cty::c_ulong,
    pub cac_time_ms: ::aya_bpf::cty::c_uint,
    pub wext: wireless_dev__bindgen_ty_1,
    pub cqm_config: *mut cfg80211_cqm_config,
    pub pmsr_list: list_head,
    pub pmsr_lock: spinlock_t,
    pub pmsr_free_wk: work_struct,
    pub unprot_beacon_reported: ::aya_bpf::cty::c_ulong,
    pub u: wireless_dev__bindgen_ty_2,
    pub links: [wireless_dev__bindgen_ty_3; 15usize],
    pub valid_links: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev__bindgen_ty_1 {
    pub ibss: cfg80211_ibss_params,
    pub connect: cfg80211_connect_params,
    pub keys: *mut cfg80211_cached_keys,
    pub ie: *const u8_,
    pub ie_len: usize,
    pub bssid: [u8_; 6usize],
    pub prev_bssid: [u8_; 6usize],
    pub ssid: [u8_; 32usize],
    pub default_key: s8,
    pub default_mgmt_key: s8,
    pub prev_bssid_valid: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wireless_dev__bindgen_ty_2 {
    pub client: wireless_dev__bindgen_ty_2__bindgen_ty_1,
    pub mesh: wireless_dev__bindgen_ty_2__bindgen_ty_2,
    pub ap: wireless_dev__bindgen_ty_2__bindgen_ty_3,
    pub ibss: wireless_dev__bindgen_ty_2__bindgen_ty_4,
    pub ocb: wireless_dev__bindgen_ty_2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_2__bindgen_ty_1 {
    pub connected_addr: [u8_; 6usize],
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
    pub __bindgen_padding_0: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_2__bindgen_ty_2 {
    pub beacon_interval: ::aya_bpf::cty::c_int,
    pub preset_chandef: cfg80211_chan_def,
    pub chandef: cfg80211_chan_def,
    pub id: [u8_; 32usize],
    pub id_len: u8_,
    pub id_up_len: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_2__bindgen_ty_3 {
    pub preset_chandef: cfg80211_chan_def,
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_2__bindgen_ty_4 {
    pub current_bss: *mut cfg80211_internal_bss,
    pub chandef: cfg80211_chan_def,
    pub beacon_interval: ::aya_bpf::cty::c_int,
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_2__bindgen_ty_5 {
    pub chandef: cfg80211_chan_def,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev__bindgen_ty_3 {
    pub addr: [u8_; 6usize],
    pub __bindgen_anon_1: wireless_dev__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wireless_dev__bindgen_ty_3__bindgen_ty_1 {
    pub ap: wireless_dev__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub client: wireless_dev__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub beacon_interval: ::aya_bpf::cty::c_uint,
    pub chandef: cfg80211_chan_def,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wireless_dev__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub current_bss: *mut cfg80211_internal_bss,
}
impl wireless_dev {
    #[inline]
    pub fn mgmt_registrations_need_update(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mgmt_registrations_need_update(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mgmt_registrations_need_update: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mgmt_registrations_need_update: u8 =
                unsafe { ::core::mem::transmute(mgmt_registrations_need_update) };
            mgmt_registrations_need_update as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn connected(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connected(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(connected: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connected: u8 = unsafe { ::core::mem::transmute(connected) };
            connected as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod nl80211_reg_initiator {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_REGDOM_SET_BY_CORE: Type = 0;
    pub const NL80211_REGDOM_SET_BY_USER: Type = 1;
    pub const NL80211_REGDOM_SET_BY_DRIVER: Type = 2;
    pub const NL80211_REGDOM_SET_BY_COUNTRY_IE: Type = 3;
}
pub mod nl80211_dfs_regions {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_DFS_UNSET: Type = 0;
    pub const NL80211_DFS_FCC: Type = 1;
    pub const NL80211_DFS_ETSI: Type = 2;
    pub const NL80211_DFS_JP: Type = 3;
}
pub mod nl80211_user_reg_hint_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_USER_REG_HINT_USER: Type = 0;
    pub const NL80211_USER_REG_HINT_CELL_BASE: Type = 1;
    pub const NL80211_USER_REG_HINT_INDOOR: Type = 2;
}
pub mod nl80211_key_mode {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_KEY_RX_TX: Type = 0;
    pub const NL80211_KEY_NO_TX: Type = 1;
    pub const NL80211_KEY_SET_TX: Type = 2;
}
pub mod nl80211_bss_scan_width {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_BSS_CHAN_WIDTH_20: Type = 0;
    pub const NL80211_BSS_CHAN_WIDTH_10: Type = 1;
    pub const NL80211_BSS_CHAN_WIDTH_5: Type = 2;
    pub const NL80211_BSS_CHAN_WIDTH_1: Type = 3;
    pub const NL80211_BSS_CHAN_WIDTH_2: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_seq {
    pub start: __u32,
    pub offset: __u32,
    pub len: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct nl80211_wowlan_tcp_data_token {
    pub offset: __u32,
    pub len: __u32,
    pub token_stream: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_wowlan_tcp_data_token_feature {
    pub min_len: __u32,
    pub max_len: __u32,
    pub bufsize: __u32,
}
pub mod nl80211_dfs_state {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_DFS_USABLE: Type = 0;
    pub const NL80211_DFS_UNAVAILABLE: Type = 1;
    pub const NL80211_DFS_AVAILABLE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nl80211_vendor_cmd_info {
    pub vendor_id: __u32,
    pub subcmd: __u32,
}
pub mod nl80211_sar_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL80211_SAR_TYPE_POWER: Type = 0;
    pub const NUM_NL80211_SAR_TYPE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_cap_elem {
    pub mac_cap_info: [u8_; 6usize],
    pub phy_cap_info: [u8_; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_mcs_nss_supp {
    pub rx_mcs_80: __le16,
    pub tx_mcs_80: __le16,
    pub rx_mcs_160: __le16,
    pub tx_mcs_160: __le16,
    pub rx_mcs_80p80: __le16,
    pub tx_mcs_80p80: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_eht_mcs_nss_supp_20mhz_only {
    pub rx_tx_mcs7_max_nss: u8_,
    pub rx_tx_mcs9_max_nss: u8_,
    pub rx_tx_mcs11_max_nss: u8_,
    pub rx_tx_mcs13_max_nss: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_eht_mcs_nss_supp_bw {
    pub rx_tx_mcs9_max_nss: u8_,
    pub rx_tx_mcs11_max_nss: u8_,
    pub rx_tx_mcs13_max_nss: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_eht_cap_elem_fixed {
    pub mac_cap_info: [u8_; 2usize],
    pub phy_cap_info: [u8_; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_he_6ghz_capa {
    pub capa: __le16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rfkill {
    _unused: [u8; 0],
}
pub mod environment_cap {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const ENVIRON_ANY: Type = 0;
    pub const ENVIRON_INDOOR: Type = 1;
    pub const ENVIRON_OUTDOOR: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regulatory_request {
    pub callback_head: callback_head,
    pub wiphy_idx: ::aya_bpf::cty::c_int,
    pub initiator: nl80211_reg_initiator::Type,
    pub user_reg_hint_type: nl80211_user_reg_hint_type::Type,
    pub alpha2: [::aya_bpf::cty::c_char; 3usize],
    pub dfs_region: nl80211_dfs_regions::Type,
    pub intersect: bool_,
    pub processed: bool_,
    pub country_ie_env: environment_cap::Type,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_freq_range {
    pub start_freq_khz: u32_,
    pub end_freq_khz: u32_,
    pub max_bandwidth_khz: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_power_rule {
    pub max_antenna_gain: u32_,
    pub max_eirp: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_wmm_ac {
    pub cw_min: u16_,
    pub cw_max: u16_,
    pub cot: u16_,
    pub aifsn: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_wmm_rule {
    pub client: [ieee80211_wmm_ac; 4usize],
    pub ap: [ieee80211_wmm_ac; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_reg_rule {
    pub freq_range: ieee80211_freq_range,
    pub power_rule: ieee80211_power_rule,
    pub wmm_rule: ieee80211_wmm_rule,
    pub flags: u32_,
    pub dfs_cac_ms: u32_,
    pub has_wmm: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct ieee80211_regdomain {
    pub callback_head: callback_head,
    pub n_reg_rules: u32_,
    pub alpha2: [::aya_bpf::cty::c_char; 3usize],
    pub dfs_region: nl80211_dfs_regions::Type,
    pub reg_rules: __IncompleteArrayField<ieee80211_reg_rule>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_channel {
    pub band: nl80211_band::Type,
    pub center_freq: u32_,
    pub freq_offset: u16_,
    pub hw_value: u16_,
    pub flags: u32_,
    pub max_antenna_gain: ::aya_bpf::cty::c_int,
    pub max_power: ::aya_bpf::cty::c_int,
    pub max_reg_power: ::aya_bpf::cty::c_int,
    pub beacon_found: bool_,
    pub orig_flags: u32_,
    pub orig_mag: ::aya_bpf::cty::c_int,
    pub orig_mpwr: ::aya_bpf::cty::c_int,
    pub dfs_state: nl80211_dfs_state::Type,
    pub dfs_state_entered: ::aya_bpf::cty::c_ulong,
    pub dfs_cac_ms: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_rate {
    pub flags: u32_,
    pub bitrate: u16_,
    pub hw_value: u16_,
    pub hw_value_short: u16_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_ht_cap {
    pub cap: u16_,
    pub ht_supported: bool_,
    pub ampdu_factor: u8_,
    pub ampdu_density: u8_,
    pub mcs: ieee80211_mcs_info,
    pub __bindgen_padding_0: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_vht_cap {
    pub vht_supported: bool_,
    pub cap: u32_,
    pub vht_mcs: ieee80211_vht_mcs_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_he_cap {
    pub has_he: bool_,
    pub he_cap_elem: ieee80211_he_cap_elem,
    pub he_mcs_nss_supp: ieee80211_he_mcs_nss_supp,
    pub ppe_thres: [u8_; 25usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee80211_eht_mcs_nss_supp {
    pub __bindgen_anon_1: ieee80211_eht_mcs_nss_supp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ieee80211_eht_mcs_nss_supp__bindgen_ty_1 {
    pub only_20mhz: ieee80211_eht_mcs_nss_supp_20mhz_only,
    pub bw: ieee80211_eht_mcs_nss_supp__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_eht_mcs_nss_supp__bindgen_ty_1__bindgen_ty_1 {
    pub _80: ieee80211_eht_mcs_nss_supp_bw,
    pub _160: ieee80211_eht_mcs_nss_supp_bw,
    pub _320: ieee80211_eht_mcs_nss_supp_bw,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee80211_sta_eht_cap {
    pub has_eht: bool_,
    pub eht_cap_elem: ieee80211_eht_cap_elem_fixed,
    pub eht_mcs_nss_supp: ieee80211_eht_mcs_nss_supp,
    pub eht_ppe_thres: [u8_; 32usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ieee80211_sband_iftype_data {
    pub types_mask: u16_,
    pub he_cap: ieee80211_sta_he_cap,
    pub he_6ghz_capa: ieee80211_he_6ghz_capa,
    pub eht_cap: ieee80211_sta_eht_cap,
    pub vendor_elems: ieee80211_sband_iftype_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sband_iftype_data__bindgen_ty_1 {
    pub data: *const u8_,
    pub len: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_sta_s1g_cap {
    pub s1g: bool_,
    pub cap: [u8_; 10usize],
    pub nss_mcs: [u8_; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_supported_band {
    pub channels: *mut ieee80211_channel,
    pub bitrates: *mut ieee80211_rate,
    pub band: nl80211_band::Type,
    pub n_channels: ::aya_bpf::cty::c_int,
    pub n_bitrates: ::aya_bpf::cty::c_int,
    pub ht_cap: ieee80211_sta_ht_cap,
    pub vht_cap: ieee80211_sta_vht_cap,
    pub s1g_cap: ieee80211_sta_s1g_cap,
    pub edmg_cap: ieee80211_edmg,
    pub n_iftype_data: u16_,
    pub iftype_data: *const ieee80211_sband_iftype_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_params {
    pub key: *const u8_,
    pub seq: *const u8_,
    pub key_len: ::aya_bpf::cty::c_int,
    pub seq_len: ::aya_bpf::cty::c_int,
    pub vlan_id: u16_,
    pub cipher: u32_,
    pub mode: nl80211_key_mode::Type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mac_address {
    pub addr: [u8_; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sar_freq_ranges {
    pub start_freq: u32_,
    pub end_freq: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sar_capa {
    pub type_: nl80211_sar_type::Type,
    pub num_freq_ranges: u32_,
    pub freq_ranges: *const cfg80211_sar_freq_ranges,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_ssid {
    pub ssid: [u8_; 32usize],
    pub ssid_len: u8_,
}
pub mod cfg80211_signal_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const CFG80211_SIGNAL_TYPE_NONE: Type = 0;
    pub const CFG80211_SIGNAL_TYPE_MBM: Type = 1;
    pub const CFG80211_SIGNAL_TYPE_UNSPEC: Type = 2;
}
#[repr(C)]
pub struct wiphy {
    pub mtx: mutex,
    pub perm_addr: [u8_; 6usize],
    pub addr_mask: [u8_; 6usize],
    pub addresses: *mut mac_address,
    pub mgmt_stypes: *const ieee80211_txrx_stypes,
    pub iface_combinations: *const ieee80211_iface_combination,
    pub n_iface_combinations: ::aya_bpf::cty::c_int,
    pub software_iftypes: u16_,
    pub n_addresses: u16_,
    pub interface_modes: u16_,
    pub max_acl_mac_addrs: u16_,
    pub flags: u32_,
    pub regulatory_flags: u32_,
    pub features: u32_,
    pub ext_features: [u8_; 8usize],
    pub ap_sme_capa: u32_,
    pub signal_type: cfg80211_signal_type::Type,
    pub bss_priv_size: ::aya_bpf::cty::c_int,
    pub max_scan_ssids: u8_,
    pub max_sched_scan_reqs: u8_,
    pub max_sched_scan_ssids: u8_,
    pub max_match_sets: u8_,
    pub max_scan_ie_len: u16_,
    pub max_sched_scan_ie_len: u16_,
    pub max_sched_scan_plans: u32_,
    pub max_sched_scan_plan_interval: u32_,
    pub max_sched_scan_plan_iterations: u32_,
    pub n_cipher_suites: ::aya_bpf::cty::c_int,
    pub cipher_suites: *const u32_,
    pub n_akm_suites: ::aya_bpf::cty::c_int,
    pub akm_suites: *const u32_,
    pub iftype_akm_suites: *const wiphy_iftype_akm_suites,
    pub num_iftype_akm_suites: ::aya_bpf::cty::c_uint,
    pub retry_short: u8_,
    pub retry_long: u8_,
    pub frag_threshold: u32_,
    pub rts_threshold: u32_,
    pub coverage_class: u8_,
    pub fw_version: [::aya_bpf::cty::c_char; 32usize],
    pub hw_version: u32_,
    pub wowlan: *const wiphy_wowlan_support,
    pub wowlan_config: *mut cfg80211_wowlan,
    pub max_remain_on_channel_duration: u16_,
    pub max_num_pmkids: u8_,
    pub available_antennas_tx: u32_,
    pub available_antennas_rx: u32_,
    pub probe_resp_offload: u32_,
    pub extended_capabilities: *const u8_,
    pub extended_capabilities_mask: *const u8_,
    pub extended_capabilities_len: u8_,
    pub iftype_ext_capab: *const wiphy_iftype_ext_capab,
    pub num_iftype_ext_capab: ::aya_bpf::cty::c_uint,
    pub privid: *const ::aya_bpf::cty::c_void,
    pub bands: [*mut ieee80211_supported_band; 6usize],
    pub reg_notifier: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut wiphy, arg2: *mut regulatory_request),
    >,
    pub regd: *const ieee80211_regdomain,
    pub dev: device,
    pub registered: bool_,
    pub debugfsdir: *mut dentry,
    pub ht_capa_mod_mask: *const ieee80211_ht_cap,
    pub vht_capa_mod_mask: *const ieee80211_vht_cap,
    pub wdev_list: list_head,
    pub _net: possible_net_t,
    pub wext: *const iw_handler_def,
    pub coalesce: *const wiphy_coalesce_support,
    pub vendor_commands: *const wiphy_vendor_command,
    pub vendor_events: *const nl80211_vendor_cmd_info,
    pub n_vendor_commands: ::aya_bpf::cty::c_int,
    pub n_vendor_events: ::aya_bpf::cty::c_int,
    pub max_ap_assoc_sta: u16_,
    pub max_num_csa_counters: u8_,
    pub bss_select_support: u32_,
    pub nan_supported_bands: u8_,
    pub txq_limit: u32_,
    pub txq_memory_limit: u32_,
    pub txq_quantum: u32_,
    pub tx_queue_len: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pmsr_capa: *const cfg80211_pmsr_capabilities,
    pub tid_config_support: wiphy__bindgen_ty_1,
    pub max_data_retry_count: u8_,
    pub sar_capa: *const cfg80211_sar_capa,
    pub rfkill: *mut rfkill,
    pub mbssid_max_interfaces: u8_,
    pub ema_max_profile_periodicity: u8_,
    pub max_num_akm_suites: u16_,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub __bindgen_padding_0: [u8; 4usize],
    pub priv_: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy__bindgen_ty_1 {
    pub peer: u64_,
    pub vif: u64_,
    pub max_retry: u8_,
}
impl wiphy {
    #[inline]
    pub fn support_mbssid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_mbssid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn support_only_he_mbssid(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_only_he_mbssid(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        support_mbssid: u8_,
        support_only_he_mbssid: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let support_mbssid: u8 = unsafe { ::core::mem::transmute(support_mbssid) };
            support_mbssid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let support_only_he_mbssid: u8 =
                unsafe { ::core::mem::transmute(support_only_he_mbssid) };
            support_only_he_mbssid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_match_set {
    pub ssid: cfg80211_ssid,
    pub bssid: [u8_; 6usize],
    pub rssi_thold: s32,
    pub per_band_rssi_thold: [s32; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_sched_scan_plan {
    pub interval: u32_,
    pub iterations: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct cfg80211_sched_scan_request {
    pub reqid: u64_,
    pub ssids: *mut cfg80211_ssid,
    pub n_ssids: ::aya_bpf::cty::c_int,
    pub n_channels: u32_,
    pub scan_width: nl80211_bss_scan_width::Type,
    pub ie: *const u8_,
    pub ie_len: usize,
    pub flags: u32_,
    pub match_sets: *mut cfg80211_match_set,
    pub n_match_sets: ::aya_bpf::cty::c_int,
    pub min_rssi_thold: s32,
    pub delay: u32_,
    pub scan_plans: *mut cfg80211_sched_scan_plan,
    pub n_scan_plans: ::aya_bpf::cty::c_int,
    pub mac_addr: [u8_; 6usize],
    pub mac_addr_mask: [u8_; 6usize],
    pub relative_rssi_set: bool_,
    pub relative_rssi: s8,
    pub rssi_adjust: cfg80211_bss_select_adjust,
    pub wiphy: *mut wiphy,
    pub dev: *mut net_device,
    pub scan_start: ::aya_bpf::cty::c_ulong,
    pub report_results: bool_,
    pub callback_head: callback_head,
    pub owner_nlportid: u32_,
    pub nl_owner_dead: bool_,
    pub list: list_head,
    pub channels: __IncompleteArrayField<*mut ieee80211_channel>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pkt_pattern {
    pub mask: *const u8_,
    pub pattern: *const u8_,
    pub pattern_len: ::aya_bpf::cty::c_int,
    pub pkt_offset: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct cfg80211_wowlan_tcp {
    pub sock: *mut socket,
    pub src: __be32,
    pub dst: __be32,
    pub src_port: u16_,
    pub dst_port: u16_,
    pub dst_mac: [u8_; 6usize],
    pub payload_len: ::aya_bpf::cty::c_int,
    pub payload: *const u8_,
    pub payload_seq: nl80211_wowlan_tcp_data_seq,
    pub data_interval: u32_,
    pub wake_len: u32_,
    pub wake_data: *const u8_,
    pub wake_mask: *const u8_,
    pub tokens_size: u32_,
    pub payload_tok: nl80211_wowlan_tcp_data_token,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_wowlan {
    pub any: bool_,
    pub disconnect: bool_,
    pub magic_pkt: bool_,
    pub gtk_rekey_failure: bool_,
    pub eap_identity_req: bool_,
    pub four_way_handshake: bool_,
    pub rfkill_release: bool_,
    pub patterns: *mut cfg80211_pkt_pattern,
    pub tcp: *mut cfg80211_wowlan_tcp,
    pub n_patterns: ::aya_bpf::cty::c_int,
    pub nd_config: *mut cfg80211_sched_scan_request,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_iface_limit {
    pub max: u16_,
    pub types: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_iface_combination {
    pub limits: *const ieee80211_iface_limit,
    pub num_different_channels: u32_,
    pub max_interfaces: u16_,
    pub n_limits: u8_,
    pub beacon_int_infra_match: bool_,
    pub radar_detect_widths: u8_,
    pub radar_detect_regions: u8_,
    pub beacon_int_min_gcd: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ieee80211_txrx_stypes {
    pub tx: u16_,
    pub rx: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_wowlan_tcp_support {
    pub tok: *const nl80211_wowlan_tcp_data_token_feature,
    pub data_payload_max: u32_,
    pub data_interval_max: u32_,
    pub wake_payload_max: u32_,
    pub seq: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_wowlan_support {
    pub flags: u32_,
    pub n_patterns: ::aya_bpf::cty::c_int,
    pub pattern_max_len: ::aya_bpf::cty::c_int,
    pub pattern_min_len: ::aya_bpf::cty::c_int,
    pub max_pkt_offset: ::aya_bpf::cty::c_int,
    pub max_nd_match_sets: ::aya_bpf::cty::c_int,
    pub tcp: *const wiphy_wowlan_tcp_support,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_coalesce_support {
    pub n_rules: ::aya_bpf::cty::c_int,
    pub max_delay: ::aya_bpf::cty::c_int,
    pub n_patterns: ::aya_bpf::cty::c_int,
    pub pattern_max_len: ::aya_bpf::cty::c_int,
    pub pattern_min_len: ::aya_bpf::cty::c_int,
    pub max_pkt_offset: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_vendor_command {
    pub info: nl80211_vendor_cmd_info,
    pub flags: u32_,
    pub doit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wiphy,
            arg2: *mut wireless_dev,
            arg3: *const ::aya_bpf::cty::c_void,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub dumpit: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut wiphy,
            arg2: *mut wireless_dev,
            arg3: *mut sk_buff,
            arg4: *const ::aya_bpf::cty::c_void,
            arg5: ::aya_bpf::cty::c_int,
            arg6: *mut ::aya_bpf::cty::c_ulong,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub policy: *const nla_policy,
    pub maxattr: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_iftype_ext_capab {
    pub iftype: nl80211_iftype::Type,
    pub extended_capabilities: *const u8_,
    pub extended_capabilities_mask: *const u8_,
    pub extended_capabilities_len: u8_,
    pub eml_capabilities: u16_,
    pub mld_capa_and_ops: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pmsr_capabilities {
    pub max_peers: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ftm: cfg80211_pmsr_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg80211_pmsr_capabilities__bindgen_ty_1 {
    pub preambles: u32_,
    pub bandwidths: u32_,
    pub max_bursts_exponent: s8,
    pub max_ftms_per_burst: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl cfg80211_pmsr_capabilities__bindgen_ty_1 {
    #[inline]
    pub fn supported(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn asap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_asap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_asap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_asap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_lci(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_lci(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_civicloc(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_civicloc(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger_based(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trigger_based(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_trigger_based(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_trigger_based(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u8_,
        asap: u8_,
        non_asap: u8_,
        request_lci: u8_,
        request_civicloc: u8_,
        trigger_based: u8_,
        non_trigger_based: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u8 = unsafe { ::core::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let asap: u8 = unsafe { ::core::mem::transmute(asap) };
            asap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let non_asap: u8 = unsafe { ::core::mem::transmute(non_asap) };
            non_asap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let request_lci: u8 = unsafe { ::core::mem::transmute(request_lci) };
            request_lci as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_civicloc: u8 = unsafe { ::core::mem::transmute(request_civicloc) };
            request_civicloc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let trigger_based: u8 = unsafe { ::core::mem::transmute(trigger_based) };
            trigger_based as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let non_trigger_based: u8 = unsafe { ::core::mem::transmute(non_trigger_based) };
            non_trigger_based as u64
        });
        __bindgen_bitfield_unit
    }
}
impl cfg80211_pmsr_capabilities {
    #[inline]
    pub fn report_ap_tsf(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_report_ap_tsf(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn randomize_mac_addr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_randomize_mac_addr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        report_ap_tsf: u8_,
        randomize_mac_addr: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let report_ap_tsf: u8 = unsafe { ::core::mem::transmute(report_ap_tsf) };
            report_ap_tsf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let randomize_mac_addr: u8 = unsafe { ::core::mem::transmute(randomize_mac_addr) };
            randomize_mac_addr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wiphy_iftype_akm_suites {
    pub iftypes_mask: u16_,
    pub akm_suites: *const u32_,
    pub n_akm_suites: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_tlb_area {
    pub used: ::aya_bpf::cty::c_ulong,
    pub index: ::aya_bpf::cty::c_uint,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_tlb_slot {
    pub orig_addr: phys_addr_t,
    pub alloc_size: usize,
    pub list: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_sect_attr {
    pub battr: bin_attribute,
    pub address: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_sect_attrs {
    pub grp: attribute_group,
    pub nsections: ::aya_bpf::cty::c_uint,
    pub attrs: __IncompleteArrayField<module_sect_attr>,
}
#[repr(C)]
#[derive(Debug)]
pub struct module_notes_attrs {
    pub dir: *mut kobject,
    pub notes: ::aya_bpf::cty::c_uint,
    pub attrs: __IncompleteArrayField<bin_attribute>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ring_buffer_iter {
    pub cpu_buffer: *mut ring_buffer_per_cpu,
    pub head: ::aya_bpf::cty::c_ulong,
    pub next_event: ::aya_bpf::cty::c_ulong,
    pub head_page: *mut buffer_page,
    pub cache_reader_page: *mut buffer_page,
    pub cache_read: ::aya_bpf::cty::c_ulong,
    pub read_stamp: u64_,
    pub page_stamp: u64_,
    pub event: *mut ring_buffer_event,
    pub missed_events: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_irq_work {
    pub work: irq_work,
    pub waiters: wait_queue_head_t,
    pub full_waiters: wait_queue_head_t,
    pub wait_index: ::aya_bpf::cty::c_long,
    pub waiters_pending: bool_,
    pub full_waiters_pending: bool_,
    pub wakeup_full: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_buffer {
    pub flags: ::aya_bpf::cty::c_uint,
    pub cpus: ::aya_bpf::cty::c_int,
    pub record_disabled: atomic_t,
    pub cpumask: cpumask_var_t,
    pub reader_lock_key: *mut lock_class_key,
    pub mutex: mutex,
    pub buffers: *mut *mut ring_buffer_per_cpu,
    pub node: hlist_node,
    pub clock: ::core::option::Option<unsafe extern "C" fn() -> u64_>,
    pub irq_work: rb_irq_work,
    pub time_stamp_abs: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct buffer_data_page {
    pub time_stamp: u64_,
    pub commit: local_t,
    pub data: __IncompleteArrayField<::aya_bpf::cty::c_uchar>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffer_page {
    pub list: list_head,
    pub write: local_t,
    pub read: ::aya_bpf::cty::c_uint,
    pub entries: local_t,
    pub real_end: ::aya_bpf::cty::c_ulong,
    pub page: *mut buffer_data_page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_time_struct {
    pub time: local64_t,
}
pub type rb_time_t = rb_time_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ring_buffer_per_cpu {
    pub cpu: ::aya_bpf::cty::c_int,
    pub record_disabled: atomic_t,
    pub resize_disabled: atomic_t,
    pub buffer: *mut trace_buffer,
    pub reader_lock: raw_spinlock_t,
    pub lock: arch_spinlock_t,
    pub lock_key: lock_class_key,
    pub free_page: *mut buffer_data_page,
    pub nr_pages: ::aya_bpf::cty::c_ulong,
    pub current_context: ::aya_bpf::cty::c_uint,
    pub pages: *mut list_head,
    pub head_page: *mut buffer_page,
    pub tail_page: *mut buffer_page,
    pub commit_page: *mut buffer_page,
    pub reader_page: *mut buffer_page,
    pub lost_events: ::aya_bpf::cty::c_ulong,
    pub last_overrun: ::aya_bpf::cty::c_ulong,
    pub nest: ::aya_bpf::cty::c_ulong,
    pub entries_bytes: local_t,
    pub entries: local_t,
    pub overrun: local_t,
    pub commit_overrun: local_t,
    pub dropped_events: local_t,
    pub committing: local_t,
    pub commits: local_t,
    pub pages_touched: local_t,
    pub pages_lost: local_t,
    pub pages_read: local_t,
    pub last_pages_touch: ::aya_bpf::cty::c_long,
    pub shortest_full: usize,
    pub read: ::aya_bpf::cty::c_ulong,
    pub read_bytes: ::aya_bpf::cty::c_ulong,
    pub write_stamp: rb_time_t,
    pub before_stamp: rb_time_t,
    pub event_stamp: [u64_; 5usize],
    pub read_stamp: u64_,
    pub nr_pages_to_update: ::aya_bpf::cty::c_long,
    pub new_pages: list_head,
    pub update_pages_work: work_struct,
    pub update_done: completion,
    pub irq_work: rb_irq_work,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_direct_key {
    pub dk_sb: *mut super_block,
    pub dk_node: hlist_node,
    pub dk_refcount: refcount_t,
    pub dk_mode: *const fscrypt_mode,
    pub dk_key: fscrypt_prepared_key,
    pub dk_descriptor: [u8_; 8usize],
    pub dk_raw: [u8_; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_rand_state {
    pub last_time: ::aya_bpf::cty::c_ulong,
    pub last_delta: ::aya_bpf::cty::c_long,
    pub last_delta2: ::aya_bpf::cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_bus {
    pub kref: kref,
    pub node: list_head,
    pub fwnode: *mut fwnode_handle,
    pub socket_ops: *const sfp_socket_ops,
    pub sfp_dev: *mut device,
    pub sfp: *mut sfp,
    pub sfp_quirk: *const sfp_quirk,
    pub upstream_ops: *const sfp_upstream_ops,
    pub upstream: *mut ::aya_bpf::cty::c_void,
    pub phydev: *mut phy_device,
    pub registered: bool_,
    pub started: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_eeprom_base {
    pub phys_id: u8_,
    pub phys_ext_id: u8_,
    pub connector: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub encoding: u8_,
    pub br_nominal: u8_,
    pub rate_id: u8_,
    pub link_len: [u8_; 6usize],
    pub vendor_name: [::aya_bpf::cty::c_char; 16usize],
    pub extended_cc: u8_,
    pub vendor_oui: [::aya_bpf::cty::c_char; 3usize],
    pub vendor_pn: [::aya_bpf::cty::c_char; 16usize],
    pub vendor_rev: [::aya_bpf::cty::c_char; 4usize],
    pub __bindgen_anon_1: sfp_eeprom_base__bindgen_ty_1,
    pub reserved62: u8_,
    pub cc_base: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sfp_eeprom_base__bindgen_ty_1 {
    pub optical_wavelength: __be16,
    pub cable_compliance: __be16,
    pub passive: sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1,
    pub active: sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sff8431_app_e(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_app_e(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_app_h(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_app_h(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved60_2(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved60_2(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved61(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved61(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sff8431_app_e: u8_,
        fc_pi_4_app_h: u8_,
        reserved60_2: u8_,
        reserved61: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sff8431_app_e: u8 = unsafe { ::core::mem::transmute(sff8431_app_e) };
            sff8431_app_e as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fc_pi_4_app_h: u8 = unsafe { ::core::mem::transmute(fc_pi_4_app_h) };
            fc_pi_4_app_h as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved60_2: u8 = unsafe { ::core::mem::transmute(reserved60_2) };
            reserved60_2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved61: u8 = unsafe { ::core::mem::transmute(reserved61) };
            reserved61 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl sfp_eeprom_base__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn sff8431_app_e(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_app_e(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_app_h(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_app_h(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sff8431_lim(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sff8431_lim(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_pi_4_lim(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_pi_4_lim(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved60_4(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved60_4(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved61(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved61(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sff8431_app_e: u8_,
        fc_pi_4_app_h: u8_,
        sff8431_lim: u8_,
        fc_pi_4_lim: u8_,
        reserved60_4: u8_,
        reserved61: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sff8431_app_e: u8 = unsafe { ::core::mem::transmute(sff8431_app_e) };
            sff8431_app_e as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fc_pi_4_app_h: u8 = unsafe { ::core::mem::transmute(fc_pi_4_app_h) };
            fc_pi_4_app_h as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sff8431_lim: u8 = unsafe { ::core::mem::transmute(sff8431_lim) };
            sff8431_lim as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fc_pi_4_lim: u8 = unsafe { ::core::mem::transmute(fc_pi_4_lim) };
            fc_pi_4_lim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved60_4: u8 = unsafe { ::core::mem::transmute(reserved60_4) };
            reserved60_4 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved61: u8 = unsafe { ::core::mem::transmute(reserved61) };
            reserved61 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl sfp_eeprom_base {
    #[inline]
    pub fn if_1x_copper_passive(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_copper_passive(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_copper_active(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_copper_active(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn if_1x_sx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_if_1x_sx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_sr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_sr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_lr(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_lr(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_lrm(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_lrm(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e10g_base_er(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e10g_base_er(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_smf_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_smf_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc3_smf_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc3_smf_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_5_3(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_5_3(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_smf_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_smf_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc12_smf_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc12_smf_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_5_7(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_5_7(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_intermediate_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_intermediate_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc48_long_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc48_long_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_reach_bit2(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_reach_bit2(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_reach_bit1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_reach_bit1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sonet_oc192_short_reach(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sonet_oc192_short_reach(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escon_smf_1310_laser(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_escon_smf_1310_laser(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escon_mmf_1310_led(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_escon_mmf_1310_led(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_sx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_sx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_cx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_cx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e1000_base_t(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e1000_base_t(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e100_base_lx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e100_base_lx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e100_base_fx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e100_base_fx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e_base_bx10(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e_base_bx10(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn e_base_px(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_e_base_px(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_electrical_inter_enclosure(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_electrical_inter_enclosure(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_lc(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_lc(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sa(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sa(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_m(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_m(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_l(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_l(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_i(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_i(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_s(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_s(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_ll_v(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_ll_v(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_8_0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_8_0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_8_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_8_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sfp_ct_passive(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sfp_ct_passive(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sfp_ct_active(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sfp_ct_active(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_ll(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_ll(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sl(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sl(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_sn(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_sn(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_tech_electrical_intra_enclosure(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_tech_electrical_intra_enclosure(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_sm(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_sm(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_9_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_9_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_m5(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_m5(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_m6(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_m6(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tv(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tv(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_mi(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_mi(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tp(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tp(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_media_tw(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_media_tw(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_100(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_100(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unallocated_10_1(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unallocated_10_1(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_3200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_3200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_400(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_400(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_1600(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_1600(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_800(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_800(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fc_speed_1200(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fc_speed_1200(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        if_1x_copper_passive: u8_,
        if_1x_copper_active: u8_,
        if_1x_lx: u8_,
        if_1x_sx: u8_,
        e10g_base_sr: u8_,
        e10g_base_lr: u8_,
        e10g_base_lrm: u8_,
        e10g_base_er: u8_,
        sonet_oc3_short_reach: u8_,
        sonet_oc3_smf_intermediate_reach: u8_,
        sonet_oc3_smf_long_reach: u8_,
        unallocated_5_3: u8_,
        sonet_oc12_short_reach: u8_,
        sonet_oc12_smf_intermediate_reach: u8_,
        sonet_oc12_smf_long_reach: u8_,
        unallocated_5_7: u8_,
        sonet_oc48_short_reach: u8_,
        sonet_oc48_intermediate_reach: u8_,
        sonet_oc48_long_reach: u8_,
        sonet_reach_bit2: u8_,
        sonet_reach_bit1: u8_,
        sonet_oc192_short_reach: u8_,
        escon_smf_1310_laser: u8_,
        escon_mmf_1310_led: u8_,
        e1000_base_sx: u8_,
        e1000_base_lx: u8_,
        e1000_base_cx: u8_,
        e1000_base_t: u8_,
        e100_base_lx: u8_,
        e100_base_fx: u8_,
        e_base_bx10: u8_,
        e_base_px: u8_,
        fc_tech_electrical_inter_enclosure: u8_,
        fc_tech_lc: u8_,
        fc_tech_sa: u8_,
        fc_ll_m: u8_,
        fc_ll_l: u8_,
        fc_ll_i: u8_,
        fc_ll_s: u8_,
        fc_ll_v: u8_,
        unallocated_8_0: u8_,
        unallocated_8_1: u8_,
        sfp_ct_passive: u8_,
        sfp_ct_active: u8_,
        fc_tech_ll: u8_,
        fc_tech_sl: u8_,
        fc_tech_sn: u8_,
        fc_tech_electrical_intra_enclosure: u8_,
        fc_media_sm: u8_,
        unallocated_9_1: u8_,
        fc_media_m5: u8_,
        fc_media_m6: u8_,
        fc_media_tv: u8_,
        fc_media_mi: u8_,
        fc_media_tp: u8_,
        fc_media_tw: u8_,
        fc_speed_100: u8_,
        unallocated_10_1: u8_,
        fc_speed_200: u8_,
        fc_speed_3200: u8_,
        fc_speed_400: u8_,
        fc_speed_1600: u8_,
        fc_speed_800: u8_,
        fc_speed_1200: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let if_1x_copper_passive: u8 = unsafe { ::core::mem::transmute(if_1x_copper_passive) };
            if_1x_copper_passive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let if_1x_copper_active: u8 = unsafe { ::core::mem::transmute(if_1x_copper_active) };
            if_1x_copper_active as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let if_1x_lx: u8 = unsafe { ::core::mem::transmute(if_1x_lx) };
            if_1x_lx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let if_1x_sx: u8 = unsafe { ::core::mem::transmute(if_1x_sx) };
            if_1x_sx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let e10g_base_sr: u8 = unsafe { ::core::mem::transmute(e10g_base_sr) };
            e10g_base_sr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let e10g_base_lr: u8 = unsafe { ::core::mem::transmute(e10g_base_lr) };
            e10g_base_lr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let e10g_base_lrm: u8 = unsafe { ::core::mem::transmute(e10g_base_lrm) };
            e10g_base_lrm as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let e10g_base_er: u8 = unsafe { ::core::mem::transmute(e10g_base_er) };
            e10g_base_er as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sonet_oc3_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_short_reach) };
            sonet_oc3_short_reach as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sonet_oc3_smf_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_smf_intermediate_reach) };
            sonet_oc3_smf_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sonet_oc3_smf_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc3_smf_long_reach) };
            sonet_oc3_smf_long_reach as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let unallocated_5_3: u8 = unsafe { ::core::mem::transmute(unallocated_5_3) };
            unallocated_5_3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let sonet_oc12_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_short_reach) };
            sonet_oc12_short_reach as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let sonet_oc12_smf_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_smf_intermediate_reach) };
            sonet_oc12_smf_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sonet_oc12_smf_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc12_smf_long_reach) };
            sonet_oc12_smf_long_reach as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let unallocated_5_7: u8 = unsafe { ::core::mem::transmute(unallocated_5_7) };
            unallocated_5_7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let sonet_oc48_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_short_reach) };
            sonet_oc48_short_reach as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let sonet_oc48_intermediate_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_intermediate_reach) };
            sonet_oc48_intermediate_reach as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sonet_oc48_long_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc48_long_reach) };
            sonet_oc48_long_reach as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sonet_reach_bit2: u8 = unsafe { ::core::mem::transmute(sonet_reach_bit2) };
            sonet_reach_bit2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sonet_reach_bit1: u8 = unsafe { ::core::mem::transmute(sonet_reach_bit1) };
            sonet_reach_bit1 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let sonet_oc192_short_reach: u8 =
                unsafe { ::core::mem::transmute(sonet_oc192_short_reach) };
            sonet_oc192_short_reach as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let escon_smf_1310_laser: u8 = unsafe { ::core::mem::transmute(escon_smf_1310_laser) };
            escon_smf_1310_laser as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let escon_mmf_1310_led: u8 = unsafe { ::core::mem::transmute(escon_mmf_1310_led) };
            escon_mmf_1310_led as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let e1000_base_sx: u8 = unsafe { ::core::mem::transmute(e1000_base_sx) };
            e1000_base_sx as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let e1000_base_lx: u8 = unsafe { ::core::mem::transmute(e1000_base_lx) };
            e1000_base_lx as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let e1000_base_cx: u8 = unsafe { ::core::mem::transmute(e1000_base_cx) };
            e1000_base_cx as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let e1000_base_t: u8 = unsafe { ::core::mem::transmute(e1000_base_t) };
            e1000_base_t as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let e100_base_lx: u8 = unsafe { ::core::mem::transmute(e100_base_lx) };
            e100_base_lx as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let e100_base_fx: u8 = unsafe { ::core::mem::transmute(e100_base_fx) };
            e100_base_fx as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let e_base_bx10: u8 = unsafe { ::core::mem::transmute(e_base_bx10) };
            e_base_bx10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let e_base_px: u8 = unsafe { ::core::mem::transmute(e_base_px) };
            e_base_px as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let fc_tech_electrical_inter_enclosure: u8 =
                unsafe { ::core::mem::transmute(fc_tech_electrical_inter_enclosure) };
            fc_tech_electrical_inter_enclosure as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let fc_tech_lc: u8 = unsafe { ::core::mem::transmute(fc_tech_lc) };
            fc_tech_lc as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let fc_tech_sa: u8 = unsafe { ::core::mem::transmute(fc_tech_sa) };
            fc_tech_sa as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let fc_ll_m: u8 = unsafe { ::core::mem::transmute(fc_ll_m) };
            fc_ll_m as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let fc_ll_l: u8 = unsafe { ::core::mem::transmute(fc_ll_l) };
            fc_ll_l as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let fc_ll_i: u8 = unsafe { ::core::mem::transmute(fc_ll_i) };
            fc_ll_i as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let fc_ll_s: u8 = unsafe { ::core::mem::transmute(fc_ll_s) };
            fc_ll_s as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let fc_ll_v: u8 = unsafe { ::core::mem::transmute(fc_ll_v) };
            fc_ll_v as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let unallocated_8_0: u8 = unsafe { ::core::mem::transmute(unallocated_8_0) };
            unallocated_8_0 as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let unallocated_8_1: u8 = unsafe { ::core::mem::transmute(unallocated_8_1) };
            unallocated_8_1 as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let sfp_ct_passive: u8 = unsafe { ::core::mem::transmute(sfp_ct_passive) };
            sfp_ct_passive as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let sfp_ct_active: u8 = unsafe { ::core::mem::transmute(sfp_ct_active) };
            sfp_ct_active as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let fc_tech_ll: u8 = unsafe { ::core::mem::transmute(fc_tech_ll) };
            fc_tech_ll as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let fc_tech_sl: u8 = unsafe { ::core::mem::transmute(fc_tech_sl) };
            fc_tech_sl as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let fc_tech_sn: u8 = unsafe { ::core::mem::transmute(fc_tech_sn) };
            fc_tech_sn as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let fc_tech_electrical_intra_enclosure: u8 =
                unsafe { ::core::mem::transmute(fc_tech_electrical_intra_enclosure) };
            fc_tech_electrical_intra_enclosure as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let fc_media_sm: u8 = unsafe { ::core::mem::transmute(fc_media_sm) };
            fc_media_sm as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let unallocated_9_1: u8 = unsafe { ::core::mem::transmute(unallocated_9_1) };
            unallocated_9_1 as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let fc_media_m5: u8 = unsafe { ::core::mem::transmute(fc_media_m5) };
            fc_media_m5 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let fc_media_m6: u8 = unsafe { ::core::mem::transmute(fc_media_m6) };
            fc_media_m6 as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let fc_media_tv: u8 = unsafe { ::core::mem::transmute(fc_media_tv) };
            fc_media_tv as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let fc_media_mi: u8 = unsafe { ::core::mem::transmute(fc_media_mi) };
            fc_media_mi as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let fc_media_tp: u8 = unsafe { ::core::mem::transmute(fc_media_tp) };
            fc_media_tp as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let fc_media_tw: u8 = unsafe { ::core::mem::transmute(fc_media_tw) };
            fc_media_tw as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let fc_speed_100: u8 = unsafe { ::core::mem::transmute(fc_speed_100) };
            fc_speed_100 as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let unallocated_10_1: u8 = unsafe { ::core::mem::transmute(unallocated_10_1) };
            unallocated_10_1 as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let fc_speed_200: u8 = unsafe { ::core::mem::transmute(fc_speed_200) };
            fc_speed_200 as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let fc_speed_3200: u8 = unsafe { ::core::mem::transmute(fc_speed_3200) };
            fc_speed_3200 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let fc_speed_400: u8 = unsafe { ::core::mem::transmute(fc_speed_400) };
            fc_speed_400 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let fc_speed_1600: u8 = unsafe { ::core::mem::transmute(fc_speed_1600) };
            fc_speed_1600 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let fc_speed_800: u8 = unsafe { ::core::mem::transmute(fc_speed_800) };
            fc_speed_800 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let fc_speed_1200: u8 = unsafe { ::core::mem::transmute(fc_speed_1200) };
            fc_speed_1200 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_eeprom_ext {
    pub options: __be16,
    pub br_max: u8_,
    pub br_min: u8_,
    pub vendor_sn: [::aya_bpf::cty::c_char; 16usize],
    pub datecode: [::aya_bpf::cty::c_char; 8usize],
    pub diagmon: u8_,
    pub enhopts: u8_,
    pub sff8472_compliance: u8_,
    pub cc_ext: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_eeprom_id {
    pub base: sfp_eeprom_base,
    pub ext: sfp_eeprom_ext,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_upstream_ops {
    pub attach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void, arg2: *mut sfp_bus),
    >,
    pub detach: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void, arg2: *mut sfp_bus),
    >,
    pub module_insert: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_void,
            arg2: *const sfp_eeprom_id,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub module_remove:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub module_start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> ::aya_bpf::cty::c_int,
    >,
    pub module_stop:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub link_down: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub link_up: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub connect_phy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::aya_bpf::cty::c_void,
            arg2: *mut phy_device,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub disconnect_phy:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_quirk {
    pub vendor: *const ::aya_bpf::cty::c_char,
    pub part: *const ::aya_bpf::cty::c_char,
    pub modes: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const sfp_eeprom_id,
            arg2: *mut ::aya_bpf::cty::c_ulong,
            arg3: *mut ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub fixup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sfp_socket_ops {
    pub attach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub start: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub stop: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sfp)>,
    pub module_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sfp, arg2: *mut ethtool_modinfo) -> ::aya_bpf::cty::c_int,
    >,
    pub module_eeprom: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sfp,
            arg2: *mut ethtool_eeprom,
            arg3: *mut u8_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub module_eeprom_by_page: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sfp,
            arg2: *const ethtool_module_eeprom,
            arg3: *mut netlink_ext_ack,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_loginfo {
    pub type_: u_int8_t,
    pub u: nf_loginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_loginfo__bindgen_ty_1 {
    pub ulog: nf_loginfo__bindgen_ty_1__bindgen_ty_1,
    pub log: nf_loginfo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_loginfo__bindgen_ty_1__bindgen_ty_1 {
    pub copy_len: u_int32_t,
    pub group: u_int16_t,
    pub qthreshold: u_int16_t,
    pub flags: u_int16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_loginfo__bindgen_ty_1__bindgen_ty_2 {
    pub level: u_int8_t,
    pub logflags: u_int8_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpvegas_info {
    pub tcpv_enabled: __u32,
    pub tcpv_rttcnt: __u32,
    pub tcpv_rtt: __u32,
    pub tcpv_minrtt: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_dctcp_info {
    pub dctcp_enabled: __u16,
    pub dctcp_ce_state: __u16,
    pub dctcp_alpha: __u32,
    pub dctcp_ab_ecn: __u32,
    pub dctcp_ab_tot: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_bbr_info {
    pub bbr_bw_lo: __u32,
    pub bbr_bw_hi: __u32,
    pub bbr_min_rtt: __u32,
    pub bbr_pacing_gain: __u32,
    pub bbr_cwnd_gain: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_cc_info {
    pub vegas: tcpvegas_info,
    pub dctcp: tcp_dctcp_info,
    pub bbr: tcp_bbr_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage_map {
    pub map: bpf_map,
    pub lock: spinlock_t,
    pub root: rb_root,
    pub list: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 32usize]>,
}
impl bpf_cgroup_storage_map {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 32usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 32usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct kioctx_table {
    pub rcu: callback_head,
    pub nr: ::aya_bpf::cty::c_uint,
    pub table: __IncompleteArrayField<*mut kioctx>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx {
    pub users: percpu_ref,
    pub dead: atomic_t,
    pub reqs: percpu_ref,
    pub user_id: ::aya_bpf::cty::c_ulong,
    pub cpu: *mut kioctx_cpu,
    pub req_batch: ::aya_bpf::cty::c_uint,
    pub max_reqs: ::aya_bpf::cty::c_uint,
    pub nr_events: ::aya_bpf::cty::c_uint,
    pub mmap_base: ::aya_bpf::cty::c_ulong,
    pub mmap_size: ::aya_bpf::cty::c_ulong,
    pub ring_pages: *mut *mut page,
    pub nr_pages: ::aya_bpf::cty::c_long,
    pub free_rwork: rcu_work,
    pub rq_wait: *mut ctx_rq_wait,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    pub __bindgen_anon_1: kioctx__bindgen_ty_1,
    pub __bindgen_anon_2: kioctx__bindgen_ty_2,
    pub __bindgen_anon_3: kioctx__bindgen_ty_3,
    pub __bindgen_anon_4: kioctx__bindgen_ty_4,
    pub internal_pages: [*mut page; 8usize],
    pub aio_ring_file: *mut file,
    pub id: ::aya_bpf::cty::c_uint,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx__bindgen_ty_1 {
    pub reqs_available: atomic_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 56usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_2 {
    pub ctx_lock: spinlock_t,
    pub active_reqs: list_head,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_3 {
    pub ring_lock: mutex,
    pub wait: wait_queue_head_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl kioctx__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx__bindgen_ty_4 {
    pub tail: ::aya_bpf::cty::c_uint,
    pub completed_events: ::aya_bpf::cty::c_uint,
    pub completion_lock: spinlock_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 48usize]>,
    pub __bindgen_padding_0: u32,
}
impl kioctx {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> = Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_cpu {
    pub reqs_available: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctx_rq_wait {
    pub comp: completion,
    pub count: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_timer {
    pub list: list_head,
    pub expires: ::aya_bpf::cty::c_ulong,
    pub dwork: delayed_work,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_wait_queue {
    pub lock: spinlock_t,
    pub tasks: [list_head; 4usize],
    pub maxpriority: ::aya_bpf::cty::c_uchar,
    pub priority: ::aya_bpf::cty::c_uchar,
    pub nr: ::aya_bpf::cty::c_uchar,
    pub qlen: ::aya_bpf::cty::c_ushort,
    pub timer_list: rpc_timer,
    pub name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_seqid_counter {
    pub create_time: ktime_t,
    pub owner_id: ::aya_bpf::cty::c_int,
    pub flags: ::aya_bpf::cty::c_int,
    pub counter: u32_,
    pub lock: spinlock_t,
    pub list: list_head,
    pub wait: rpc_wait_queue,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_stateid_struct {
    pub __bindgen_anon_1: nfs4_stateid_struct__bindgen_ty_1,
    pub type_: nfs4_stateid_struct__bindgen_ty_2::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nfs4_stateid_struct__bindgen_ty_1 {
    pub data: [::aya_bpf::cty::c_char; 16usize],
    pub __bindgen_anon_1: nfs4_stateid_struct__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_stateid_struct__bindgen_ty_1__bindgen_ty_1 {
    pub seqid: __be32,
    pub other: [::aya_bpf::cty::c_char; 12usize],
}
pub mod nfs4_stateid_struct__bindgen_ty_2 {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NFS4_INVALID_STATEID_TYPE: Type = 0;
    pub const NFS4_SPECIAL_STATEID_TYPE: Type = 1;
    pub const NFS4_OPEN_STATEID_TYPE: Type = 2;
    pub const NFS4_LOCK_STATEID_TYPE: Type = 3;
    pub const NFS4_DELEGATION_STATEID_TYPE: Type = 4;
    pub const NFS4_LAYOUT_STATEID_TYPE: Type = 5;
    pub const NFS4_PNFS_DS_STATEID_TYPE: Type = 6;
    pub const NFS4_REVOKED_STATEID_TYPE: Type = 7;
}
pub type nfs4_stateid = nfs4_stateid_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_lock_state {
    pub ls_locks: list_head,
    pub ls_state: *mut nfs4_state,
    pub ls_flags: ::aya_bpf::cty::c_ulong,
    pub ls_seqid: nfs_seqid_counter,
    pub ls_stateid: nfs4_stateid,
    pub ls_count: refcount_t,
    pub ls_owner: fl_owner_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdr_netobj {
    pub len: ::aya_bpf::cty::c_uint,
    pub data: *mut u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdr_buf {
    pub head: [kvec; 1usize],
    pub tail: [kvec; 1usize],
    pub bvec: *mut bio_vec,
    pub pages: *mut *mut page,
    pub page_base: ::aya_bpf::cty::c_uint,
    pub page_len: ::aya_bpf::cty::c_uint,
    pub flags: ::aya_bpf::cty::c_uint,
    pub buflen: ::aya_bpf::cty::c_uint,
    pub len: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xdr_stream {
    pub p: *mut __be32,
    pub buf: *mut xdr_buf,
    pub end: *mut __be32,
    pub iov: *mut kvec,
    pub scratch: kvec,
    pub page_ptr: *mut *mut page,
    pub nwords: ::aya_bpf::cty::c_uint,
    pub rqst: *mut rpc_rqst,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_rqst {
    pub rq_xprt: *mut rpc_xprt,
    pub rq_snd_buf: xdr_buf,
    pub rq_rcv_buf: xdr_buf,
    pub rq_task: *mut rpc_task,
    pub rq_cred: *mut rpc_cred,
    pub rq_xid: __be32,
    pub rq_cong: ::aya_bpf::cty::c_int,
    pub rq_seqno: u32_,
    pub rq_enc_pages_num: ::aya_bpf::cty::c_int,
    pub rq_enc_pages: *mut *mut page,
    pub rq_release_snd_buf: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_rqst)>,
    pub __bindgen_anon_1: rpc_rqst__bindgen_ty_1,
    pub rq_xmit: list_head,
    pub rq_xmit2: list_head,
    pub rq_buffer: *mut ::aya_bpf::cty::c_void,
    pub rq_callsize: usize,
    pub rq_rbuffer: *mut ::aya_bpf::cty::c_void,
    pub rq_rcvsize: usize,
    pub rq_xmit_bytes_sent: usize,
    pub rq_reply_bytes_recvd: usize,
    pub rq_private_buf: xdr_buf,
    pub rq_majortimeo: ::aya_bpf::cty::c_ulong,
    pub rq_minortimeo: ::aya_bpf::cty::c_ulong,
    pub rq_timeout: ::aya_bpf::cty::c_ulong,
    pub rq_rtt: ktime_t,
    pub rq_retries: ::aya_bpf::cty::c_uint,
    pub rq_connect_cookie: ::aya_bpf::cty::c_uint,
    pub rq_pin: atomic_t,
    pub rq_bytes_sent: u32_,
    pub rq_xtime: ktime_t,
    pub rq_ntrans: ::aya_bpf::cty::c_int,
    pub rq_bc_list: list_head,
    pub rq_bc_pa_state: ::aya_bpf::cty::c_ulong,
    pub rq_bc_pa_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpc_rqst__bindgen_ty_1 {
    pub rq_list: list_head,
    pub rq_recv: rb_node,
}
pub type kxdreproc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rpc_rqst,
        arg2: *mut xdr_stream,
        arg3: *const ::aya_bpf::cty::c_void,
    ),
>;
pub type kxdrdproc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rpc_rqst,
        arg2: *mut xdr_stream,
        arg3: *mut ::aya_bpf::cty::c_void,
    ) -> ::aya_bpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_message {
    pub rpc_proc: *const rpc_procinfo,
    pub rpc_argp: *mut ::aya_bpf::cty::c_void,
    pub rpc_resp: *mut ::aya_bpf::cty::c_void,
    pub rpc_cred: *const cred,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_procinfo {
    pub p_proc: u32_,
    pub p_encode: kxdreproc_t,
    pub p_decode: kxdrdproc_t,
    pub p_arglen: ::aya_bpf::cty::c_uint,
    pub p_replen: ::aya_bpf::cty::c_uint,
    pub p_timer: ::aya_bpf::cty::c_uint,
    pub p_statidx: u32_,
    pub p_name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_wait {
    pub list: list_head,
    pub links: list_head,
    pub timer_list: list_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_task {
    pub tk_count: atomic_t,
    pub tk_status: ::aya_bpf::cty::c_int,
    pub tk_task: list_head,
    pub tk_callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub tk_action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub tk_timeout: ::aya_bpf::cty::c_ulong,
    pub tk_runstate: ::aya_bpf::cty::c_ulong,
    pub tk_waitqueue: *mut rpc_wait_queue,
    pub u: rpc_task__bindgen_ty_1,
    pub tk_msg: rpc_message,
    pub tk_calldata: *mut ::aya_bpf::cty::c_void,
    pub tk_ops: *const rpc_call_ops,
    pub tk_client: *mut rpc_clnt,
    pub tk_xprt: *mut rpc_xprt,
    pub tk_op_cred: *mut rpc_cred,
    pub tk_rqstp: *mut rpc_rqst,
    pub tk_workqueue: *mut workqueue_struct,
    pub tk_start: ktime_t,
    pub tk_owner: pid_t,
    pub tk_rpc_status: ::aya_bpf::cty::c_int,
    pub tk_flags: ::aya_bpf::cty::c_ushort,
    pub tk_timeouts: ::aya_bpf::cty::c_ushort,
    pub tk_pid: ::aya_bpf::cty::c_ushort,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpc_task__bindgen_ty_1 {
    pub tk_work: work_struct,
    pub tk_wait: rpc_wait,
}
impl rpc_task {
    #[inline]
    pub fn tk_priority(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tk_priority(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tk_garb_retry(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tk_garb_retry(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tk_cred_retry(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tk_cred_retry(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tk_rebind_retry(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tk_rebind_retry(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tk_priority: ::aya_bpf::cty::c_uchar,
        tk_garb_retry: ::aya_bpf::cty::c_uchar,
        tk_cred_retry: ::aya_bpf::cty::c_uchar,
        tk_rebind_retry: ::aya_bpf::cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let tk_priority: u8 = unsafe { ::core::mem::transmute(tk_priority) };
            tk_priority as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let tk_garb_retry: u8 = unsafe { ::core::mem::transmute(tk_garb_retry) };
            tk_garb_retry as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let tk_cred_retry: u8 = unsafe { ::core::mem::transmute(tk_cred_retry) };
            tk_cred_retry as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let tk_rebind_retry: u8 = unsafe { ::core::mem::transmute(tk_rebind_retry) };
            tk_rebind_retry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_call_ops {
    pub rpc_call_prepare: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub rpc_call_done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub rpc_count_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut ::aya_bpf::cty::c_void),
    >,
    pub rpc_release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_iostats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_pipe_dir_head {
    pub pdh_entries: list_head,
    pub pdh_dentry: *mut dentry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_rtt {
    pub timeo: ::aya_bpf::cty::c_ulong,
    pub srtt: [::aya_bpf::cty::c_ulong; 5usize],
    pub sdrtt: [::aya_bpf::cty::c_ulong; 5usize],
    pub ntimeouts: [::aya_bpf::cty::c_int; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_timeout {
    pub to_initval: ::aya_bpf::cty::c_ulong,
    pub to_maxval: ::aya_bpf::cty::c_ulong,
    pub to_increment: ::aya_bpf::cty::c_ulong,
    pub to_retries: ::aya_bpf::cty::c_uint,
    pub to_exponential: ::aya_bpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_sysfs_client {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_xprt_iter {
    pub xpi_xpswitch: *mut rpc_xprt_switch,
    pub xpi_cursor: *mut rpc_xprt,
    pub xpi_ops: *const rpc_xprt_iter_ops,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_clnt {
    pub cl_count: refcount_t,
    pub cl_clid: ::aya_bpf::cty::c_uint,
    pub cl_clients: list_head,
    pub cl_tasks: list_head,
    pub cl_pid: atomic_t,
    pub cl_lock: spinlock_t,
    pub cl_xprt: *mut rpc_xprt,
    pub cl_procinfo: *const rpc_procinfo,
    pub cl_prog: u32_,
    pub cl_vers: u32_,
    pub cl_maxproc: u32_,
    pub cl_auth: *mut rpc_auth,
    pub cl_stats: *mut rpc_stat,
    pub cl_metrics: *mut rpc_iostats,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub cl_rtt: *mut rpc_rtt,
    pub cl_timeout: *const rpc_timeout,
    pub cl_swapper: atomic_t,
    pub cl_nodelen: ::aya_bpf::cty::c_int,
    pub cl_nodename: [::aya_bpf::cty::c_char; 65usize],
    pub cl_pipedir_objects: rpc_pipe_dir_head,
    pub cl_parent: *mut rpc_clnt,
    pub cl_rtt_default: rpc_rtt,
    pub cl_timeout_default: rpc_timeout,
    pub cl_program: *const rpc_program,
    pub cl_principal: *const ::aya_bpf::cty::c_char,
    pub cl_debugfs: *mut dentry,
    pub cl_sysfs: *mut rpc_sysfs_client,
    pub __bindgen_anon_1: rpc_clnt__bindgen_ty_1,
    pub cl_cred: *const cred,
    pub cl_max_connect: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpc_clnt__bindgen_ty_1 {
    pub cl_xpi: rpc_xprt_iter,
    pub cl_work: work_struct,
}
impl rpc_clnt {
    #[inline]
    pub fn cl_softrtry(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_softrtry(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_softerr(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_softerr(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_discrtry(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_discrtry(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_noretranstimeo(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_noretranstimeo(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_autobind(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_autobind(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl_chatty(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl_chatty(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cl_softrtry: ::aya_bpf::cty::c_uint,
        cl_softerr: ::aya_bpf::cty::c_uint,
        cl_discrtry: ::aya_bpf::cty::c_uint,
        cl_noretranstimeo: ::aya_bpf::cty::c_uint,
        cl_autobind: ::aya_bpf::cty::c_uint,
        cl_chatty: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cl_softrtry: u32 = unsafe { ::core::mem::transmute(cl_softrtry) };
            cl_softrtry as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cl_softerr: u32 = unsafe { ::core::mem::transmute(cl_softerr) };
            cl_softerr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cl_discrtry: u32 = unsafe { ::core::mem::transmute(cl_discrtry) };
            cl_discrtry as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cl_noretranstimeo: u32 = unsafe { ::core::mem::transmute(cl_noretranstimeo) };
            cl_noretranstimeo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cl_autobind: u32 = unsafe { ::core::mem::transmute(cl_autobind) };
            cl_autobind as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cl_chatty: u32 = unsafe { ::core::mem::transmute(cl_chatty) };
            cl_chatty as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_xprt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_sysfs_xprt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_xprt {
    pub kref: kref,
    pub ops: *const rpc_xprt_ops,
    pub id: ::aya_bpf::cty::c_uint,
    pub timeout: *const rpc_timeout,
    pub addr: __kernel_sockaddr_storage,
    pub addrlen: usize,
    pub prot: ::aya_bpf::cty::c_int,
    pub cong: ::aya_bpf::cty::c_ulong,
    pub cwnd: ::aya_bpf::cty::c_ulong,
    pub max_payload: usize,
    pub binding: rpc_wait_queue,
    pub sending: rpc_wait_queue,
    pub pending: rpc_wait_queue,
    pub backlog: rpc_wait_queue,
    pub free: list_head,
    pub max_reqs: ::aya_bpf::cty::c_uint,
    pub min_reqs: ::aya_bpf::cty::c_uint,
    pub num_reqs: ::aya_bpf::cty::c_uint,
    pub state: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub swapper: atomic_t,
    pub bind_index: ::aya_bpf::cty::c_uint,
    pub xprt_switch: list_head,
    pub bind_timeout: ::aya_bpf::cty::c_ulong,
    pub reestablish_timeout: ::aya_bpf::cty::c_ulong,
    pub connect_cookie: ::aya_bpf::cty::c_uint,
    pub task_cleanup: work_struct,
    pub timer: timer_list,
    pub last_used: ::aya_bpf::cty::c_ulong,
    pub idle_timeout: ::aya_bpf::cty::c_ulong,
    pub connect_timeout: ::aya_bpf::cty::c_ulong,
    pub max_reconnect_timeout: ::aya_bpf::cty::c_ulong,
    pub queuelen: atomic_long_t,
    pub transport_lock: spinlock_t,
    pub reserve_lock: spinlock_t,
    pub queue_lock: spinlock_t,
    pub xid: u32_,
    pub snd_task: *mut rpc_task,
    pub xmit_queue: list_head,
    pub xmit_queuelen: atomic_long_t,
    pub bc_xprt: *mut svc_xprt,
    pub bc_serv: *mut svc_serv,
    pub bc_alloc_max: ::aya_bpf::cty::c_uint,
    pub bc_alloc_count: ::aya_bpf::cty::c_uint,
    pub bc_slot_count: atomic_t,
    pub bc_pa_lock: spinlock_t,
    pub bc_pa_list: list_head,
    pub recv_queue: rb_root,
    pub stat: rpc_xprt__bindgen_ty_1,
    pub xprt_net: *mut net,
    pub ns_tracker: netns_tracker,
    pub servername: *const ::aya_bpf::cty::c_char,
    pub address_strings: [*const ::aya_bpf::cty::c_char; 6usize],
    pub debugfs: *mut dentry,
    pub rcu: callback_head,
    pub xprt_class: *const xprt_class,
    pub xprt_sysfs: *mut rpc_sysfs_xprt,
    pub main: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_xprt__bindgen_ty_1 {
    pub bind_count: ::aya_bpf::cty::c_ulong,
    pub connect_count: ::aya_bpf::cty::c_ulong,
    pub connect_start: ::aya_bpf::cty::c_ulong,
    pub connect_time: ::aya_bpf::cty::c_ulong,
    pub sends: ::aya_bpf::cty::c_ulong,
    pub recvs: ::aya_bpf::cty::c_ulong,
    pub bad_xids: ::aya_bpf::cty::c_ulong,
    pub max_slots: ::aya_bpf::cty::c_ulong,
    pub req_u: ::aya_bpf::cty::c_ulonglong,
    pub bklog_u: ::aya_bpf::cty::c_ulonglong,
    pub sending_u: ::aya_bpf::cty::c_ulonglong,
    pub pending_u: ::aya_bpf::cty::c_ulonglong,
}
impl rpc_xprt {
    #[inline]
    pub fn resvport(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_resvport(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> ::aya_bpf::cty::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: ::aya_bpf::cty::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        resvport: ::aya_bpf::cty::c_uchar,
        reuseport: ::aya_bpf::cty::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let resvport: u8 = unsafe { ::core::mem::transmute(resvport) };
            resvport as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reuseport: u8 = unsafe { ::core::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_cred {
    pub cr_hash: hlist_node,
    pub cr_lru: list_head,
    pub cr_rcu: callback_head,
    pub cr_auth: *mut rpc_auth,
    pub cr_ops: *const rpc_credops,
    pub cr_expire: ::aya_bpf::cty::c_ulong,
    pub cr_flags: ::aya_bpf::cty::c_ulong,
    pub cr_count: refcount_t,
    pub cr_cred: *const cred,
}
pub type rpc_authflavor_t = u32_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_cred {
    pub cred: *const cred,
    pub principal: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_cred_cache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_auth {
    pub au_cslack: ::aya_bpf::cty::c_uint,
    pub au_rslack: ::aya_bpf::cty::c_uint,
    pub au_verfsize: ::aya_bpf::cty::c_uint,
    pub au_ralign: ::aya_bpf::cty::c_uint,
    pub au_flags: ::aya_bpf::cty::c_ulong,
    pub au_ops: *const rpc_authops,
    pub au_flavor: rpc_authflavor_t,
    pub au_count: refcount_t,
    pub au_credcache: *mut rpc_cred_cache,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_credops {
    pub cr_name: *const ::aya_bpf::cty::c_char,
    pub cr_init: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_auth, arg2: *mut rpc_cred) -> ::aya_bpf::cty::c_int,
    >,
    pub crdestroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_cred)>,
    pub crmatch: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut auth_cred,
            arg2: *mut rpc_cred,
            arg3: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub crmarshal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut xdr_stream) -> ::aya_bpf::cty::c_int,
    >,
    pub crrefresh:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task) -> ::aya_bpf::cty::c_int>,
    pub crvalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut xdr_stream) -> ::aya_bpf::cty::c_int,
    >,
    pub crwrap_req: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut xdr_stream) -> ::aya_bpf::cty::c_int,
    >,
    pub crunwrap_resp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut xdr_stream) -> ::aya_bpf::cty::c_int,
    >,
    pub crkey_timeout:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_cred) -> ::aya_bpf::cty::c_int>,
    pub crstringify_acceptor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_cred) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub crneed_reencode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task) -> bool_>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_authops {
    pub owner: *mut module,
    pub au_flavor: rpc_authflavor_t,
    pub au_name: *mut ::aya_bpf::cty::c_char,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const rpc_auth_create_args,
            arg2: *mut rpc_clnt,
        ) -> *mut rpc_auth,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_auth)>,
    pub hash_cred: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut auth_cred,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lookup_cred: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_auth,
            arg2: *mut auth_cred,
            arg3: ::aya_bpf::cty::c_int,
        ) -> *mut rpc_cred,
    >,
    pub crcreate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_auth,
            arg2: *mut auth_cred,
            arg3: ::aya_bpf::cty::c_int,
            arg4: gfp_t,
        ) -> *mut rpc_cred,
    >,
    pub info2flavor: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpcsec_gss_info) -> rpc_authflavor_t,
    >,
    pub flavor2info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: rpc_authflavor_t,
            arg2: *mut rpcsec_gss_info,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub key_timeout: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_auth, arg2: *mut rpc_cred) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_auth_create_args {
    pub pseudoflavor: rpc_authflavor_t,
    pub target_name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcsec_gss_oid {
    pub len: ::aya_bpf::cty::c_uint,
    pub data: [u8_; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcsec_gss_info {
    pub oid: rpcsec_gss_oid,
    pub qop: u32_,
    pub service: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_xprt_ops {
    pub set_buffer_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: usize, arg3: usize)>,
    pub reserve_xprt: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_task) -> ::aya_bpf::cty::c_int,
    >,
    pub release_xprt:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_task)>,
    pub alloc_slot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_task)>,
    pub free_slot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_rqst)>,
    pub rpcbind: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub set_port: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: ::aya_bpf::cty::c_ushort),
    >,
    pub connect:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_task)>,
    pub get_srcaddr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_xprt,
            arg2: *mut ::aya_bpf::cty::c_char,
            arg3: usize,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_srcport: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_xprt) -> ::aya_bpf::cty::c_ushort,
    >,
    pub buf_alloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task) -> ::aya_bpf::cty::c_int>,
    pub buf_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub prepare_request: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_rqst, arg2: *mut xdr_buf) -> ::aya_bpf::cty::c_int,
    >,
    pub send_request:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_rqst) -> ::aya_bpf::cty::c_int>,
    pub wait_for_reply_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub timer:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut rpc_task)>,
    pub release_request: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_task)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt)>,
    pub set_connect_timeout: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_xprt,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: ::aya_bpf::cty::c_ulong,
        ),
    >,
    pub print_stats:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: *mut seq_file)>,
    pub enable_swap:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt) -> ::aya_bpf::cty::c_int>,
    pub disable_swap: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt)>,
    pub inject_disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt)>,
    pub bc_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_xprt,
            arg2: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub bc_maxpayload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt) -> usize>,
    pub bc_num_slots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt) -> ::aya_bpf::cty::c_uint>,
    pub bc_free_rqst: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_rqst)>,
    pub bc_destroy: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_xprt, arg2: ::aya_bpf::cty::c_uint),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct svc_serv {
    pub sv_program: *mut svc_program,
    pub sv_stats: *mut svc_stat,
    pub sv_lock: spinlock_t,
    pub sv_refcnt: kref,
    pub sv_nrthreads: ::aya_bpf::cty::c_uint,
    pub sv_maxconn: ::aya_bpf::cty::c_uint,
    pub sv_max_payload: ::aya_bpf::cty::c_uint,
    pub sv_max_mesg: ::aya_bpf::cty::c_uint,
    pub sv_xdrsize: ::aya_bpf::cty::c_uint,
    pub sv_permsocks: list_head,
    pub sv_tempsocks: list_head,
    pub sv_tmpcnt: ::aya_bpf::cty::c_int,
    pub sv_temptimer: timer_list,
    pub sv_name: *mut ::aya_bpf::cty::c_char,
    pub sv_nrpools: ::aya_bpf::cty::c_uint,
    pub sv_pools: *mut svc_pool,
    pub sv_threadfn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> ::aya_bpf::cty::c_int,
    >,
    pub sv_cb_list: list_head,
    pub sv_cb_lock: spinlock_t,
    pub sv_cb_waitq: wait_queue_head_t,
    pub sv_bc_enabled: bool_,
}
#[repr(C)]
#[derive(Debug)]
pub struct xprt_class {
    pub list: list_head,
    pub ident: ::aya_bpf::cty::c_int,
    pub setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut xprt_create) -> *mut rpc_xprt>,
    pub owner: *mut module,
    pub name: [::aya_bpf::cty::c_char; 32usize],
    pub netid: __IncompleteArrayField<*const ::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xprt_create {
    pub ident: ::aya_bpf::cty::c_int,
    pub net: *mut net,
    pub srcaddr: *mut sockaddr,
    pub dstaddr: *mut sockaddr,
    pub addrlen: usize,
    pub servername: *const ::aya_bpf::cty::c_char,
    pub bc_xprt: *mut svc_xprt,
    pub bc_xps: *mut rpc_xprt_switch,
    pub flags: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_sysfs_xprt_switch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpc_xprt_switch {
    pub xps_lock: spinlock_t,
    pub xps_kref: kref,
    pub xps_id: ::aya_bpf::cty::c_uint,
    pub xps_nxprts: ::aya_bpf::cty::c_uint,
    pub xps_nactive: ::aya_bpf::cty::c_uint,
    pub xps_nunique_destaddr_xprts: ::aya_bpf::cty::c_uint,
    pub xps_queuelen: atomic_long_t,
    pub xps_xprt_list: list_head,
    pub xps_net: *mut net,
    pub xps_iter_ops: *const rpc_xprt_iter_ops,
    pub xps_sysfs: *mut rpc_sysfs_xprt_switch,
    pub xps_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_stat {
    pub program: *const rpc_program,
    pub netcnt: ::aya_bpf::cty::c_uint,
    pub netudpcnt: ::aya_bpf::cty::c_uint,
    pub nettcpcnt: ::aya_bpf::cty::c_uint,
    pub nettcpconn: ::aya_bpf::cty::c_uint,
    pub netreconn: ::aya_bpf::cty::c_uint,
    pub rpccnt: ::aya_bpf::cty::c_uint,
    pub rpcretrans: ::aya_bpf::cty::c_uint,
    pub rpcauthrefresh: ::aya_bpf::cty::c_uint,
    pub rpcgarbage: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_program {
    pub name: *const ::aya_bpf::cty::c_char,
    pub number: u32_,
    pub nrvers: ::aya_bpf::cty::c_uint,
    pub version: *mut *const rpc_version,
    pub stats: *mut rpc_stat,
    pub pipe_dir_name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_stat {
    pub program: *mut svc_program,
    pub netcnt: ::aya_bpf::cty::c_uint,
    pub netudpcnt: ::aya_bpf::cty::c_uint,
    pub nettcpcnt: ::aya_bpf::cty::c_uint,
    pub nettcpconn: ::aya_bpf::cty::c_uint,
    pub rpccnt: ::aya_bpf::cty::c_uint,
    pub rpcbadfmt: ::aya_bpf::cty::c_uint,
    pub rpcbadauth: ::aya_bpf::cty::c_uint,
    pub rpcbadclnt: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_program {
    pub pg_next: *mut svc_program,
    pub pg_prog: u32_,
    pub pg_lovers: ::aya_bpf::cty::c_uint,
    pub pg_hivers: ::aya_bpf::cty::c_uint,
    pub pg_nvers: ::aya_bpf::cty::c_uint,
    pub pg_vers: *mut *const svc_version,
    pub pg_name: *mut ::aya_bpf::cty::c_char,
    pub pg_class: *mut ::aya_bpf::cty::c_char,
    pub pg_stats: *mut svc_stat,
    pub pg_authenticate:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst) -> ::aya_bpf::cty::c_int>,
    pub pg_init_request: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut svc_rqst,
            arg2: *const svc_program,
            arg3: *mut svc_process_info,
        ) -> __be32,
    >,
    pub pg_rpcbind_set: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *const svc_program,
            arg3: u32_,
            arg4: ::aya_bpf::cty::c_int,
            arg5: ::aya_bpf::cty::c_ushort,
            arg6: ::aya_bpf::cty::c_ushort,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_xprt_iter_ops {
    pub xpi_rewind: ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt_iter)>,
    pub xpi_xprt:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt_iter) -> *mut rpc_xprt>,
    pub xpi_next:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut rpc_xprt_iter) -> *mut rpc_xprt>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpc_version {
    pub number: u32_,
    pub nrprocs: ::aya_bpf::cty::c_uint,
    pub procs: *const rpc_procinfo,
    pub counts: *mut ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fh {
    pub size: ::aya_bpf::cty::c_ushort,
    pub data: [::aya_bpf::cty::c_uchar; 128usize],
}
pub mod nfs3_stable_how {
    pub type Type = ::aya_bpf::cty::c_int;
    pub const NFS_UNSTABLE: Type = 0;
    pub const NFS_DATA_SYNC: Type = 1;
    pub const NFS_FILE_SYNC: Type = 2;
    pub const NFS_INVALID_STABLE_HOW: Type = -1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_label {
    pub lfs: u32,
    pub pi: u32,
    pub len: u32_,
    pub label: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_verifier {
    pub data: [::aya_bpf::cty::c_char; 8usize],
}
pub mod nfs4_change_attr_type {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR: Type = 0;
    pub const NFS4_CHANGE_TYPE_IS_VERSION_COUNTER: Type = 1;
    pub const NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS: Type = 2;
    pub const NFS4_CHANGE_TYPE_IS_TIME_METADATA: Type = 3;
    pub const NFS4_CHANGE_TYPE_IS_UNDEFINED: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gss_ctx {
    pub mech_type: *mut gss_api_mech,
    pub internal_ctx_id: *mut ::aya_bpf::cty::c_void,
    pub slack: ::aya_bpf::cty::c_uint,
    pub align: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gss_api_mech {
    pub gm_list: list_head,
    pub gm_owner: *mut module,
    pub gm_oid: rpcsec_gss_oid,
    pub gm_name: *mut ::aya_bpf::cty::c_char,
    pub gm_ops: *const gss_api_ops,
    pub gm_pf_num: ::aya_bpf::cty::c_int,
    pub gm_pfs: *mut pf_desc,
    pub gm_upcall_enctypes: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pf_desc {
    pub pseudoflavor: u32_,
    pub qop: u32_,
    pub service: u32_,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub auth_domain_name: *mut ::aya_bpf::cty::c_char,
    pub domain: *mut auth_domain,
    pub datatouch: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_domain {
    pub ref_: kref,
    pub hash: hlist_node,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub flavour: *mut auth_ops,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gss_api_ops {
    pub gss_import_sec_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_void,
            arg2: usize,
            arg3: *mut gss_ctx,
            arg4: *mut time64_t,
            arg5: gfp_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub gss_get_mic: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gss_ctx, arg2: *mut xdr_buf, arg3: *mut xdr_netobj) -> u32_,
    >,
    pub gss_verify_mic: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut gss_ctx, arg2: *mut xdr_buf, arg3: *mut xdr_netobj) -> u32_,
    >,
    pub gss_wrap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gss_ctx,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut xdr_buf,
            arg4: *mut *mut page,
        ) -> u32_,
    >,
    pub gss_unwrap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut gss_ctx,
            arg2: ::aya_bpf::cty::c_int,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut xdr_buf,
        ) -> u32_,
    >,
    pub gss_delete_sec_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_string {
    pub len: ::aya_bpf::cty::c_uint,
    pub data: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fsid {
    pub major: u64,
    pub minor: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_threshold {
    pub bm: __u32,
    pub l_type: __u32,
    pub rd_sz: __u64,
    pub wr_sz: __u64,
    pub rd_io_sz: __u64,
    pub wr_io_sz: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_fattr {
    pub valid: ::aya_bpf::cty::c_uint,
    pub mode: umode_t,
    pub nlink: __u32,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub rdev: dev_t,
    pub size: __u64,
    pub du: nfs_fattr__bindgen_ty_1,
    pub fsid: nfs_fsid,
    pub fileid: __u64,
    pub mounted_on_fileid: __u64,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub change_attr: __u64,
    pub pre_change_attr: __u64,
    pub pre_size: __u64,
    pub pre_mtime: timespec64,
    pub pre_ctime: timespec64,
    pub time_start: ::aya_bpf::cty::c_ulong,
    pub gencount: ::aya_bpf::cty::c_ulong,
    pub owner_name: *mut nfs4_string,
    pub group_name: *mut nfs4_string,
    pub mdsthreshold: *mut nfs4_threshold,
    pub label: *mut nfs4_label,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nfs_fattr__bindgen_ty_1 {
    pub nfs2: nfs_fattr__bindgen_ty_1__bindgen_ty_1,
    pub nfs3: nfs_fattr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fattr__bindgen_ty_1__bindgen_ty_1 {
    pub blocksize: __u32,
    pub blocks: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fattr__bindgen_ty_1__bindgen_ty_2 {
    pub used: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fsinfo {
    pub fattr: *mut nfs_fattr,
    pub rtmax: __u32,
    pub rtpref: __u32,
    pub rtmult: __u32,
    pub wtmax: __u32,
    pub wtpref: __u32,
    pub wtmult: __u32,
    pub dtpref: __u32,
    pub maxfilesize: __u64,
    pub time_delta: timespec64,
    pub lease_time: __u32,
    pub nlayouttypes: __u32,
    pub layouttype: [__u32; 8usize],
    pub blksize: __u32,
    pub clone_blksize: __u32,
    pub change_attr_type: nfs4_change_attr_type::Type,
    pub xattr_support: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_fsstat {
    pub fattr: *mut nfs_fattr,
    pub tbytes: __u64,
    pub fbytes: __u64,
    pub abytes: __u64,
    pub tfiles: __u64,
    pub ffiles: __u64,
    pub afiles: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_pathconf {
    pub fattr: *mut nfs_fattr,
    pub max_link: __u32,
    pub max_namelen: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_change_info {
    pub atomic: u32_,
    pub before: u64_,
    pub after: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_slot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_sequence_args {
    pub sa_slot: *mut nfs4_slot,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl nfs4_sequence_args {
    #[inline]
    pub fn sa_cache_this(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sa_cache_this(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sa_privileged(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sa_privileged(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sa_cache_this: u8_,
        sa_privileged: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sa_cache_this: u8 = unsafe { ::core::mem::transmute(sa_cache_this) };
            sa_cache_this as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sa_privileged: u8 = unsafe { ::core::mem::transmute(sa_privileged) };
            sa_privileged as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_sequence_res {
    pub sr_slot: *mut nfs4_slot,
    pub sr_timestamp: ::aya_bpf::cty::c_ulong,
    pub sr_status: ::aya_bpf::cty::c_int,
    pub sr_status_flags: u32_,
    pub sr_highest_slotid: u32_,
    pub sr_target_highest_slotid: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_context {
    pub count: refcount_t,
    pub list: list_head,
    pub open_context: *mut nfs_open_context,
    pub lockowner: fl_owner_t,
    pub io_count: atomic_t,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_open_context {
    pub lock_context: nfs_lock_context,
    pub flock_owner: fl_owner_t,
    pub dentry: *mut dentry,
    pub cred: *const cred,
    pub ll_cred: *mut rpc_cred,
    pub state: *mut nfs4_state,
    pub mode: fmode_t,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub error: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub mdsthreshold: *mut nfs4_threshold,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_host {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_iostats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_auth_info {
    pub flavor_len: ::aya_bpf::cty::c_uint,
    pub flavors: [rpc_authflavor_t; 12usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscache_volume {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pnfs_layoutdriver_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_server {
    pub nfs_client: *mut nfs_client,
    pub client_link: list_head,
    pub master_link: list_head,
    pub client: *mut rpc_clnt,
    pub client_acl: *mut rpc_clnt,
    pub nlm_host: *mut nlm_host,
    pub io_stats: *mut nfs_iostats,
    pub writeback: atomic_long_t,
    pub write_congested: ::aya_bpf::cty::c_uint,
    pub flags: ::aya_bpf::cty::c_uint,
    pub fattr_valid: ::aya_bpf::cty::c_uint,
    pub caps: ::aya_bpf::cty::c_uint,
    pub rsize: ::aya_bpf::cty::c_uint,
    pub rpages: ::aya_bpf::cty::c_uint,
    pub wsize: ::aya_bpf::cty::c_uint,
    pub wpages: ::aya_bpf::cty::c_uint,
    pub wtmult: ::aya_bpf::cty::c_uint,
    pub dtsize: ::aya_bpf::cty::c_uint,
    pub port: ::aya_bpf::cty::c_ushort,
    pub bsize: ::aya_bpf::cty::c_uint,
    pub gxasize: ::aya_bpf::cty::c_uint,
    pub sxasize: ::aya_bpf::cty::c_uint,
    pub lxasize: ::aya_bpf::cty::c_uint,
    pub acregmin: ::aya_bpf::cty::c_uint,
    pub acregmax: ::aya_bpf::cty::c_uint,
    pub acdirmin: ::aya_bpf::cty::c_uint,
    pub acdirmax: ::aya_bpf::cty::c_uint,
    pub namelen: ::aya_bpf::cty::c_uint,
    pub options: ::aya_bpf::cty::c_uint,
    pub clone_blksize: ::aya_bpf::cty::c_uint,
    pub change_attr_type: nfs4_change_attr_type::Type,
    pub fsid: nfs_fsid,
    pub maxfilesize: __u64,
    pub time_delta: timespec64,
    pub mount_time: ::aya_bpf::cty::c_ulong,
    pub super_: *mut super_block,
    pub s_dev: dev_t,
    pub auth_info: nfs_auth_info,
    pub fscache: *mut fscache_volume,
    pub fscache_uniq: *mut ::aya_bpf::cty::c_char,
    pub pnfs_blksize: u32_,
    pub attr_bitmask: [u32_; 3usize],
    pub attr_bitmask_nl: [u32_; 3usize],
    pub exclcreat_bitmask: [u32_; 3usize],
    pub cache_consistency_bitmask: [u32_; 3usize],
    pub acl_bitmask: u32_,
    pub fh_expire_type: u32_,
    pub pnfs_curr_ld: *mut pnfs_layoutdriver_type,
    pub roc_rpcwaitq: rpc_wait_queue,
    pub pnfs_ld_data: *mut ::aya_bpf::cty::c_void,
    pub state_owners: rb_root,
    pub openowner_id: ida,
    pub lockowner_id: ida,
    pub state_owners_lru: list_head,
    pub layouts: list_head,
    pub delegations: list_head,
    pub ss_copies: list_head,
    pub mig_gen: ::aya_bpf::cty::c_ulong,
    pub mig_status: ::aya_bpf::cty::c_ulong,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_server)>,
    pub active: atomic_t,
    pub mountd_address: __kernel_sockaddr_storage,
    pub mountd_addrlen: usize,
    pub mountd_version: u32_,
    pub mountd_port: ::aya_bpf::cty::c_ushort,
    pub mountd_protocol: ::aya_bpf::cty::c_ushort,
    pub uoc_rpcwaitq: rpc_wait_queue,
    pub read_hdrsize: ::aya_bpf::cty::c_uint,
    pub cred: *const cred,
    pub has_sec_mnt_opts: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_subversion {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_slot_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_client {
    pub cl_count: refcount_t,
    pub cl_mds_count: atomic_t,
    pub cl_cons_state: ::aya_bpf::cty::c_int,
    pub cl_res_state: ::aya_bpf::cty::c_ulong,
    pub cl_flags: ::aya_bpf::cty::c_ulong,
    pub cl_addr: __kernel_sockaddr_storage,
    pub cl_addrlen: usize,
    pub cl_hostname: *mut ::aya_bpf::cty::c_char,
    pub cl_acceptor: *mut ::aya_bpf::cty::c_char,
    pub cl_share_link: list_head,
    pub cl_superblocks: list_head,
    pub cl_rpcclient: *mut rpc_clnt,
    pub rpc_ops: *const nfs_rpc_ops,
    pub cl_proto: ::aya_bpf::cty::c_int,
    pub cl_nfs_mod: *mut nfs_subversion,
    pub cl_minorversion: u32_,
    pub cl_nconnect: ::aya_bpf::cty::c_uint,
    pub cl_max_connect: ::aya_bpf::cty::c_uint,
    pub cl_principal: *const ::aya_bpf::cty::c_char,
    pub cl_ds_clients: list_head,
    pub cl_clientid: u64_,
    pub cl_confirm: nfs4_verifier,
    pub cl_state: ::aya_bpf::cty::c_ulong,
    pub cl_lock: spinlock_t,
    pub cl_lease_time: ::aya_bpf::cty::c_ulong,
    pub cl_last_renewal: ::aya_bpf::cty::c_ulong,
    pub cl_renewd: delayed_work,
    pub cl_rpcwaitq: rpc_wait_queue,
    pub cl_idmap: *mut idmap,
    pub cl_owner_id: *const ::aya_bpf::cty::c_char,
    pub cl_cb_ident: u32_,
    pub cl_mvops: *const nfs4_minor_version_ops,
    pub cl_mig_gen: ::aya_bpf::cty::c_ulong,
    pub cl_slot_tbl: *mut nfs4_slot_table,
    pub cl_seqid: u32_,
    pub cl_exchange_flags: u32_,
    pub cl_session: *mut nfs4_session,
    pub cl_preserve_clid: bool_,
    pub cl_serverowner: *mut nfs41_server_owner,
    pub cl_serverscope: *mut nfs41_server_scope,
    pub cl_implid: *mut nfs41_impl_id,
    pub cl_sp4_flags: ::aya_bpf::cty::c_ulong,
    pub cl_lock_waitq: wait_queue_head_t,
    pub cl_ipaddr: [::aya_bpf::cty::c_char; 48usize],
    pub cl_net: *mut net,
    pub pending_cb_stateids: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pnfs_layout_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_seqid {
    pub sequence: *mut nfs_seqid_counter,
    pub list: list_head,
    pub task: *mut rpc_task,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_write_verifier {
    pub data: [::aya_bpf::cty::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_writeverf {
    pub verifier: nfs_write_verifier,
    pub committed: nfs3_stable_how::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_pgio_args {
    pub seq_args: nfs4_sequence_args,
    pub fh: *mut nfs_fh,
    pub context: *mut nfs_open_context,
    pub lock_context: *mut nfs_lock_context,
    pub stateid: nfs4_stateid,
    pub offset: __u64,
    pub count: __u32,
    pub pgbase: ::aya_bpf::cty::c_uint,
    pub pages: *mut *mut page,
    pub __bindgen_anon_1: nfs_pgio_args__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nfs_pgio_args__bindgen_ty_1 {
    pub replen: ::aya_bpf::cty::c_uint,
    pub __bindgen_anon_1: nfs_pgio_args__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_pgio_args__bindgen_ty_1__bindgen_ty_1 {
    pub bitmask: *const u32_,
    pub bitmask_store: [u32_; 3usize],
    pub stable: nfs3_stable_how::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_pgio_res {
    pub seq_res: nfs4_sequence_res,
    pub fattr: *mut nfs_fattr,
    pub count: __u64,
    pub op_status: __u32,
    pub __bindgen_anon_1: nfs_pgio_res__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nfs_pgio_res__bindgen_ty_1 {
    pub __bindgen_anon_1: nfs_pgio_res__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: nfs_pgio_res__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_pgio_res__bindgen_ty_1__bindgen_ty_1 {
    pub replen: ::aya_bpf::cty::c_uint,
    pub eof: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_pgio_res__bindgen_ty_1__bindgen_ty_2 {
    pub verf: *mut nfs_writeverf,
    pub server: *const nfs_server,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_commitargs {
    pub seq_args: nfs4_sequence_args,
    pub fh: *mut nfs_fh,
    pub offset: __u64,
    pub count: __u32,
    pub bitmask: *const u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_commitres {
    pub seq_res: nfs4_sequence_res,
    pub op_status: __u32,
    pub fattr: *mut nfs_fattr,
    pub verf: *mut nfs_writeverf,
    pub server: *const nfs_server,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_removeargs {
    pub seq_args: nfs4_sequence_args,
    pub fh: *const nfs_fh,
    pub name: qstr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_removeres {
    pub seq_res: nfs4_sequence_res,
    pub server: *mut nfs_server,
    pub dir_attr: *mut nfs_fattr,
    pub cinfo: nfs4_change_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_renameargs {
    pub seq_args: nfs4_sequence_args,
    pub old_dir: *const nfs_fh,
    pub new_dir: *const nfs_fh,
    pub old_name: *const qstr,
    pub new_name: *const qstr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_renameres {
    pub seq_res: nfs4_sequence_res,
    pub server: *mut nfs_server,
    pub old_cinfo: nfs4_change_info,
    pub old_fattr: *mut nfs_fattr,
    pub new_cinfo: nfs4_change_info,
    pub new_fattr: *mut nfs_fattr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_entry {
    pub ino: __u64,
    pub cookie: __u64,
    pub name: *const ::aya_bpf::cty::c_char,
    pub len: ::aya_bpf::cty::c_uint,
    pub eof: ::aya_bpf::cty::c_int,
    pub fh: *mut nfs_fh,
    pub fattr: *mut nfs_fattr,
    pub d_type: ::aya_bpf::cty::c_uchar,
    pub server: *mut nfs_server,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_readdir_arg {
    pub dentry: *mut dentry,
    pub cred: *const cred,
    pub verf: *mut __be32,
    pub cookie: u64_,
    pub pages: *mut *mut page,
    pub page_len: ::aya_bpf::cty::c_uint,
    pub plus: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_readdir_res {
    pub verf: *mut __be32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_pathname {
    pub ncomponents: ::aya_bpf::cty::c_uint,
    pub components: [nfs4_string; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_fs_location {
    pub nservers: ::aya_bpf::cty::c_uint,
    pub servers: [nfs4_string; 10usize],
    pub rootpath: nfs4_pathname,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_fs_locations {
    pub fattr: *mut nfs_fattr,
    pub server: *const nfs_server,
    pub fs_path: nfs4_pathname,
    pub nlocations: ::aya_bpf::cty::c_int,
    pub locations: [nfs4_fs_location; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfstime4 {
    pub seconds: u64_,
    pub nseconds: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pnfs_commit_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pnfs_ds_commit_info {
    pub commits: list_head,
    pub nwritten: ::aya_bpf::cty::c_uint,
    pub ncommitting: ::aya_bpf::cty::c_uint,
    pub ops: *const pnfs_commit_ops,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs41_server_owner {
    pub minor_id: u64,
    pub major_id_sz: u32,
    pub major_id: [::aya_bpf::cty::c_char; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs41_server_scope {
    pub server_scope_sz: u32,
    pub server_scope: [::aya_bpf::cty::c_char; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs41_impl_id {
    pub domain: [::aya_bpf::cty::c_char; 1025usize],
    pub name: [::aya_bpf::cty::c_char; 1025usize],
    pub date: nfstime4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_page_array {
    pub pagevec: *mut *mut page,
    pub npages: ::aya_bpf::cty::c_uint,
    pub page_array: [*mut page; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_rw_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_io_completion {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_direct_req {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_pgio_header {
    pub inode: *mut inode,
    pub cred: *const cred,
    pub pages: list_head,
    pub req: *mut nfs_page,
    pub verf: nfs_writeverf,
    pub rw_mode: fmode_t,
    pub lseg: *mut pnfs_layout_segment,
    pub io_start: loff_t,
    pub mds_ops: *const rpc_call_ops,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_pgio_header)>,
    pub completion_ops: *const nfs_pgio_completion_ops,
    pub rw_ops: *const nfs_rw_ops,
    pub io_completion: *mut nfs_io_completion,
    pub dreq: *mut nfs_direct_req,
    pub pnfs_error: ::aya_bpf::cty::c_int,
    pub error: ::aya_bpf::cty::c_int,
    pub good_bytes: ::aya_bpf::cty::c_uint,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub task: rpc_task,
    pub fattr: nfs_fattr,
    pub args: nfs_pgio_args,
    pub res: nfs_pgio_res,
    pub timestamp: ::aya_bpf::cty::c_ulong,
    pub pgio_done_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_pgio_header,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mds_offset: __u64,
    pub page_array: nfs_page_array,
    pub ds_clp: *mut nfs_client,
    pub ds_commit_idx: u32_,
    pub pgio_mirror_idx: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_pgio_completion_ops {
    pub error_cleanup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut list_head, arg2: ::aya_bpf::cty::c_int),
    >,
    pub init_hdr: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_pgio_header)>,
    pub completion: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_pgio_header)>,
    pub reschedule_io: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_pgio_header)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_mds_commit_info {
    pub rpcs_out: atomic_t,
    pub ncommit: atomic_long_t,
    pub list: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_commit_completion_ops {
    pub completion: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_commit_data)>,
    pub resched_write: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_commit_info, arg2: *mut nfs_page),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_commit_data {
    pub task: rpc_task,
    pub inode: *mut inode,
    pub cred: *const cred,
    pub fattr: nfs_fattr,
    pub verf: nfs_writeverf,
    pub pages: list_head,
    pub list: list_head,
    pub dreq: *mut nfs_direct_req,
    pub args: nfs_commitargs,
    pub res: nfs_commitres,
    pub context: *mut nfs_open_context,
    pub lseg: *mut pnfs_layout_segment,
    pub ds_clp: *mut nfs_client,
    pub ds_commit_index: ::aya_bpf::cty::c_int,
    pub lwb: loff_t,
    pub mds_ops: *const rpc_call_ops,
    pub completion_ops: *const nfs_commit_completion_ops,
    pub commit_done_cb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_commit_data,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_commit_info {
    pub inode: *mut inode,
    pub mds: *mut nfs_mds_commit_info,
    pub ds: *mut pnfs_ds_commit_info,
    pub dreq: *mut nfs_direct_req,
    pub completion_ops: *const nfs_commit_completion_ops,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_unlinkdata {
    pub args: nfs_removeargs,
    pub res: nfs_removeres,
    pub dentry: *mut dentry,
    pub wq: wait_queue_head_t,
    pub cred: *const cred,
    pub dir_attr: nfs_fattr,
    pub timeout: ::aya_bpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_renamedata {
    pub args: nfs_renameargs,
    pub res: nfs_renameres,
    pub task: rpc_task,
    pub cred: *const cred,
    pub old_dir: *mut inode,
    pub old_dentry: *mut dentry,
    pub old_fattr: nfs_fattr,
    pub new_dir: *mut inode,
    pub new_dentry: *mut dentry,
    pub new_fattr: nfs_fattr,
    pub complete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut nfs_renamedata),
    >,
    pub timeout: ::aya_bpf::cty::c_long,
    pub cancelled: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlmclnt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_client_initdata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_rpc_ops {
    pub version: u32_,
    pub dentry_ops: *const dentry_operations,
    pub dir_inode_ops: *const inode_operations,
    pub file_inode_ops: *const inode_operations,
    pub file_ops: *const file_operations,
    pub nlmclnt_ops: *const nlmclnt_operations,
    pub getroot: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fsinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub submount: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context, arg2: *mut nfs_server) -> ::aya_bpf::cty::c_int,
    >,
    pub try_get_tree: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut fs_context) -> ::aya_bpf::cty::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fattr,
            arg4: *mut inode,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut nfs_fattr,
            arg3: *mut iattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut nfs_fh,
            arg4: *mut nfs_fattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lookupp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut nfs_access_entry,
            arg3: *const cred,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut page,
            arg3: ::aya_bpf::cty::c_uint,
            arg4: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut iattr,
            arg4: ::aya_bpf::cty::c_int,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::aya_bpf::cty::c_int,
    >,
    pub unlink_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_message, arg2: *mut dentry, arg3: *mut inode),
    >,
    pub unlink_rpc_prepare: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut nfs_unlinkdata),
    >,
    pub unlink_done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut inode) -> ::aya_bpf::cty::c_int,
    >,
    pub rename_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_message, arg2: *mut dentry, arg3: *mut dentry),
    >,
    pub rename_rpc_prepare: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut nfs_renamedata),
    >,
    pub rename_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut inode,
            arg3: *mut inode,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut inode,
            arg3: *const qstr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut page,
            arg4: ::aya_bpf::cty::c_uint,
            arg5: *mut iattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *const qstr) -> ::aya_bpf::cty::c_int,
    >,
    pub readdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_readdir_arg,
            arg2: *mut nfs_readdir_res,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut iattr,
            arg4: dev_t,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fsstat,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fsinfo: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fsinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pathconf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_pathconf,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub set_capabilities: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_server, arg2: *mut nfs_fh) -> ::aya_bpf::cty::c_int,
    >,
    pub decode_dirent: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut xdr_stream,
            arg2: *mut nfs_entry,
            arg3: bool_,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub pgio_rpc_prepare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_pgio_header,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub read_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_pgio_header, arg2: *mut rpc_message),
    >,
    pub read_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_pgio_header,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub write_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_pgio_header,
            arg2: *mut rpc_message,
            arg3: *mut *mut rpc_clnt,
        ),
    >,
    pub write_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_pgio_header,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub commit_setup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_commit_data,
            arg2: *mut rpc_message,
            arg3: *mut *mut rpc_clnt,
        ),
    >,
    pub commit_rpc_prepare: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut rpc_task, arg2: *mut nfs_commit_data),
    >,
    pub commit_done: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_task,
            arg2: *mut nfs_commit_data,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::aya_bpf::cty::c_int,
            arg3: *mut file_lock,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub lock_check_bounds: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const file_lock) -> ::aya_bpf::cty::c_int,
    >,
    pub clear_acl_cache: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub close_context: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_open_context, arg2: ::aya_bpf::cty::c_int),
    >,
    pub open_context: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut nfs_open_context,
            arg3: ::aya_bpf::cty::c_int,
            arg4: *mut iattr,
            arg5: *mut ::aya_bpf::cty::c_int,
        ) -> *mut inode,
    >,
    pub have_delegation: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: fmode_t) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_client: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const nfs_client_initdata) -> *mut nfs_client,
    >,
    pub init_client: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_client,
            arg2: *const nfs_client_initdata,
        ) -> *mut nfs_client,
    >,
    pub free_client: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_client)>,
    pub create_server:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> *mut nfs_server>,
    pub clone_server: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fattr,
            arg4: rpc_authflavor_t,
        ) -> *mut nfs_server,
    >,
    pub discover_trunking: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_server, arg2: *mut nfs_fh) -> ::aya_bpf::cty::c_int,
    >,
    pub enable_swap: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub disable_swap: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_access_entry {
    pub rb_node: rb_node,
    pub lru: list_head,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub group_info: *mut group_info,
    pub timestamp: u64_,
    pub mask: __u32,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_minor_version_ops {
    pub minor_version: u32_,
    pub init_caps: ::aya_bpf::cty::c_uint,
    pub init_client: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_client) -> ::aya_bpf::cty::c_int,
    >,
    pub shutdown_client: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_client)>,
    pub match_stateid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const nfs4_stateid, arg2: *const nfs4_stateid) -> bool_,
    >,
    pub find_root_sec: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs_fsinfo,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub free_lock_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_server, arg2: *mut nfs4_lock_state),
    >,
    pub test_and_free_expired: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs4_stateid,
            arg3: *const cred,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub alloc_seqid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_seqid_counter, arg2: gfp_t) -> *mut nfs_seqid,
    >,
    pub session_trunk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rpc_clnt,
            arg2: *mut rpc_xprt,
            arg3: *mut ::aya_bpf::cty::c_void,
        ),
    >,
    pub call_sync_ops: *const rpc_call_ops,
    pub reboot_recovery_ops: *const nfs4_state_recovery_ops,
    pub nograce_recovery_ops: *const nfs4_state_recovery_ops,
    pub state_renewal_ops: *const nfs4_state_maintenance_ops,
    pub mig_recovery_ops: *const nfs4_mig_recovery_ops,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_state {
    pub open_states: list_head,
    pub inode_states: list_head,
    pub lock_states: list_head,
    pub owner: *mut nfs4_state_owner,
    pub inode: *mut inode,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub state_lock: spinlock_t,
    pub seqlock: seqlock_t,
    pub stateid: nfs4_stateid,
    pub open_stateid: nfs4_stateid,
    pub n_rdonly: ::aya_bpf::cty::c_uint,
    pub n_wronly: ::aya_bpf::cty::c_uint,
    pub n_rdwr: ::aya_bpf::cty::c_uint,
    pub state: fmode_t,
    pub count: refcount_t,
    pub waitq: wait_queue_head_t,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cache_head {
    pub cache_list: hlist_node,
    pub expiry_time: time64_t,
    pub last_refresh: time64_t,
    pub ref_: kref,
    pub flags: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cache_req {
    pub defer: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cache_req) -> *mut cache_deferred_req,
    >,
    pub thread_wait: ::aya_bpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cache_deferred_req {
    pub hash: hlist_node,
    pub recent: list_head,
    pub item: *mut cache_head,
    pub owner: *mut ::aya_bpf::cty::c_void,
    pub revisit: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut cache_deferred_req, arg2: ::aya_bpf::cty::c_int),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_cred {
    pub cr_uid: kuid_t,
    pub cr_gid: kgid_t,
    pub cr_group_info: *mut group_info,
    pub cr_flavor: u32_,
    pub cr_raw_principal: *mut ::aya_bpf::cty::c_char,
    pub cr_principal: *mut ::aya_bpf::cty::c_char,
    pub cr_targ_princ: *mut ::aya_bpf::cty::c_char,
    pub cr_gss_mech: *mut gss_api_mech,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_ops {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub owner: *mut module,
    pub flavour: ::aya_bpf::cty::c_int,
    pub accept:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst) -> ::aya_bpf::cty::c_int>,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst) -> ::aya_bpf::cty::c_int>,
    pub domain_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut auth_domain)>,
    pub set_client:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst) -> ::aya_bpf::cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_cacherep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct svc_rqst {
    pub rq_all: list_head,
    pub rq_rcu_head: callback_head,
    pub rq_xprt: *mut svc_xprt,
    pub rq_addr: __kernel_sockaddr_storage,
    pub rq_addrlen: usize,
    pub rq_daddr: __kernel_sockaddr_storage,
    pub rq_daddrlen: usize,
    pub rq_server: *mut svc_serv,
    pub rq_pool: *mut svc_pool,
    pub rq_procinfo: *const svc_procedure,
    pub rq_authop: *mut auth_ops,
    pub rq_cred: svc_cred,
    pub rq_xprt_ctxt: *mut ::aya_bpf::cty::c_void,
    pub rq_deferred: *mut svc_deferred_req,
    pub rq_arg: xdr_buf,
    pub rq_arg_stream: xdr_stream,
    pub rq_res_stream: xdr_stream,
    pub rq_scratch_page: *mut page,
    pub rq_res: xdr_buf,
    pub rq_pages: [*mut page; 260usize],
    pub rq_respages: *mut *mut page,
    pub rq_next_page: *mut *mut page,
    pub rq_page_end: *mut *mut page,
    pub rq_pvec: pagevec,
    pub rq_vec: [kvec; 259usize],
    pub rq_bvec: [bio_vec; 259usize],
    pub rq_xid: __be32,
    pub rq_prog: u32_,
    pub rq_vers: u32_,
    pub rq_proc: u32_,
    pub rq_prot: u32_,
    pub rq_cachetype: ::aya_bpf::cty::c_int,
    pub rq_flags: ::aya_bpf::cty::c_ulong,
    pub rq_qtime: ktime_t,
    pub rq_argp: *mut ::aya_bpf::cty::c_void,
    pub rq_resp: *mut ::aya_bpf::cty::c_void,
    pub rq_auth_data: *mut ::aya_bpf::cty::c_void,
    pub rq_auth_stat: __be32,
    pub rq_auth_slack: ::aya_bpf::cty::c_int,
    pub rq_reserved: ::aya_bpf::cty::c_int,
    pub rq_stime: ktime_t,
    pub rq_chandle: cache_req,
    pub rq_client: *mut auth_domain,
    pub rq_gssclient: *mut auth_domain,
    pub rq_cacherep: *mut svc_cacherep,
    pub rq_task: *mut task_struct,
    pub rq_bc_net: *mut net,
    pub rq_lease_breaker: *mut *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_pool_stats {
    pub packets: atomic_long_t,
    pub sockets_queued: ::aya_bpf::cty::c_ulong,
    pub threads_woken: atomic_long_t,
    pub threads_timedout: atomic_long_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct svc_pool {
    pub sp_id: ::aya_bpf::cty::c_uint,
    pub sp_lock: spinlock_t,
    pub sp_sockets: list_head,
    pub sp_nrthreads: ::aya_bpf::cty::c_uint,
    pub sp_all_threads: list_head,
    pub sp_stats: svc_pool_stats,
    pub sp_flags: ::aya_bpf::cty::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 40usize]>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_procedure {
    pub pc_func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst) -> __be32>,
    pub pc_decode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut svc_rqst, arg2: *mut xdr_stream) -> bool_,
    >,
    pub pc_encode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut svc_rqst, arg2: *mut xdr_stream) -> bool_,
    >,
    pub pc_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut svc_rqst)>,
    pub pc_argsize: ::aya_bpf::cty::c_uint,
    pub pc_argzero: ::aya_bpf::cty::c_uint,
    pub pc_ressize: ::aya_bpf::cty::c_uint,
    pub pc_cachetype: ::aya_bpf::cty::c_uint,
    pub pc_xdrressize: ::aya_bpf::cty::c_uint,
    pub pc_name: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
pub struct svc_deferred_req {
    pub prot: u32_,
    pub xprt: *mut svc_xprt,
    pub addr: __kernel_sockaddr_storage,
    pub addrlen: usize,
    pub daddr: __kernel_sockaddr_storage,
    pub daddrlen: usize,
    pub xprt_ctxt: *mut ::aya_bpf::cty::c_void,
    pub handle: cache_deferred_req,
    pub argslen: ::aya_bpf::cty::c_int,
    pub args: __IncompleteArrayField<__be32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct svc_process_info {
    pub __bindgen_anon_1: svc_process_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union svc_process_info__bindgen_ty_1 {
    pub dispatch: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut svc_rqst, arg2: *mut __be32) -> ::aya_bpf::cty::c_int,
    >,
    pub mismatch: svc_process_info__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_process_info__bindgen_ty_1__bindgen_ty_1 {
    pub lovers: ::aya_bpf::cty::c_uint,
    pub hivers: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct svc_version {
    pub vs_vers: u32_,
    pub vs_nproc: u32_,
    pub vs_proc: *const svc_procedure,
    pub vs_count: *mut ::aya_bpf::cty::c_uint,
    pub vs_xdrsize: u32_,
    pub vs_hidden: bool_,
    pub vs_rpcb_optnl: bool_,
    pub vs_need_cong_ctrl: bool_,
    pub vs_dispatch: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut svc_rqst, arg2: *mut __be32) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_state_recovery_ops {
    pub owner_flag_bit: ::aya_bpf::cty::c_int,
    pub state_flag_bit: ::aya_bpf::cty::c_int,
    pub recover_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs4_state_owner,
            arg2: *mut nfs4_state,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub recover_lock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs4_state, arg2: *mut file_lock) -> ::aya_bpf::cty::c_int,
    >,
    pub establish_clid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_client, arg2: *const cred) -> ::aya_bpf::cty::c_int,
    >,
    pub reclaim_complete: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_client, arg2: *const cred) -> ::aya_bpf::cty::c_int,
    >,
    pub detect_trunking: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_client,
            arg2: *mut *mut nfs_client,
            arg3: *const cred,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_state_maintenance_ops {
    pub sched_state_renewal: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_client,
            arg2: *const cred,
            arg3: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub get_state_renewal_cred:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut nfs_client) -> *const cred>,
    pub renew_lease: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nfs_client, arg2: *const cred) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_mig_recovery_ops {
    pub get_locations: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut nfs_server,
            arg2: *mut nfs_fh,
            arg3: *mut nfs4_fs_locations,
            arg4: *mut page,
            arg5: *const cred,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub fsid_present: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *const cred) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_state_owner {
    pub so_server: *mut nfs_server,
    pub so_lru: list_head,
    pub so_expires: ::aya_bpf::cty::c_ulong,
    pub so_server_node: rb_node,
    pub so_cred: *const cred,
    pub so_lock: spinlock_t,
    pub so_count: atomic_t,
    pub so_flags: ::aya_bpf::cty::c_ulong,
    pub so_states: list_head,
    pub so_seqid: nfs_seqid_counter,
    pub so_reclaim_seqcount: seqcount_spinlock_t,
    pub so_delegreturn_mutex: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_alloc_cache {
    pub free_list: *mut bio,
    pub free_list_irq: *mut bio,
    pub nr: ::aya_bpf::cty::c_uint,
    pub nr_irq: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct throtl_service_queue {
    pub parent_sq: *mut throtl_service_queue,
    pub queued: [list_head; 2usize],
    pub nr_queued: [::aya_bpf::cty::c_uint; 2usize],
    pub pending_tree: rb_root_cached,
    pub nr_pending: ::aya_bpf::cty::c_uint,
    pub first_pending_disptime: ::aya_bpf::cty::c_ulong,
    pub pending_timer: timer_list,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latency_bucket {
    pub total_latency: ::aya_bpf::cty::c_ulong,
    pub samples: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avg_latency_bucket {
    pub latency: ::aya_bpf::cty::c_ulong,
    pub valid: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct throtl_data {
    pub service_queue: throtl_service_queue,
    pub queue: *mut request_queue,
    pub nr_queued: [::aya_bpf::cty::c_uint; 2usize],
    pub throtl_slice: ::aya_bpf::cty::c_uint,
    pub dispatch_work: work_struct,
    pub limit_index: ::aya_bpf::cty::c_uint,
    pub limit_valid: [bool_; 2usize],
    pub low_upgrade_time: ::aya_bpf::cty::c_ulong,
    pub low_downgrade_time: ::aya_bpf::cty::c_ulong,
    pub scale: ::aya_bpf::cty::c_uint,
    pub tmp_buckets: [latency_bucket; 18usize],
    pub avg_buckets: [avg_latency_bucket; 18usize],
    pub latency_buckets: [*mut latency_bucket; 2usize],
    pub last_calculate_time: ::aya_bpf::cty::c_ulong,
    pub filtered_latency: ::aya_bpf::cty::c_ulong,
    pub track_bio_latency: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_event_notifier {
    pub ct_event: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf::cty::c_uint,
            arg2: *const nf_ct_event,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub exp_event: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::aya_bpf::cty::c_uint,
            arg2: *const nf_exp_event,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_mask {
    pub src: nf_conntrack_tuple_mask__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple_mask__bindgen_ty_1 {
    pub u3: nf_inet_addr,
    pub u: nf_conntrack_man_proto,
}
#[repr(C)]
#[derive(Debug)]
pub struct nf_ct_ext {
    pub offset: [u8_; 10usize],
    pub len: u8_,
    pub gen_id: ::aya_bpf::cty::c_uint,
    pub data: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_conntrack_helper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_expect {
    pub lnode: hlist_node,
    pub hnode: hlist_node,
    pub tuple: nf_conntrack_tuple,
    pub mask: nf_conntrack_tuple_mask,
    pub expectfn: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nf_conn, arg2: *mut nf_conntrack_expect),
    >,
    pub helper: *mut nf_conntrack_helper,
    pub master: *mut nf_conn,
    pub timeout: timer_list,
    pub use_: refcount_t,
    pub flags: ::aya_bpf::cty::c_uint,
    pub class: ::aya_bpf::cty::c_uint,
    pub saved_addr: nf_inet_addr,
    pub saved_proto: nf_conntrack_man_proto,
    pub dir: ip_conntrack_dir::Type,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_ct_event {
    pub ct: *mut nf_conn,
    pub portid: u32_,
    pub report: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nf_exp_event {
    pub exp: *mut nf_conntrack_expect,
    pub portid: u32_,
    pub report: ::aya_bpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psample_group {
    pub list: list_head,
    pub net: *mut net,
    pub group_num: u32_,
    pub refcount: u32_,
    pub seq: u32_,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_gate_entry {
    pub gate_state: u8_,
    pub interval: u32_,
    pub ipv: s32,
    pub maxoctets: s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_dev {
    pub wpan_phy: *mut wpan_phy,
    pub iftype: ::aya_bpf::cty::c_int,
    pub list: list_head,
    pub netdev: *mut net_device,
    pub header_ops: *const wpan_dev_header_ops,
    pub lowpan_dev: *mut net_device,
    pub identifier: u32_,
    pub pan_id: __le16,
    pub short_addr: __le16,
    pub extended_addr: __le64,
    pub bsn: atomic_t,
    pub dsn: atomic_t,
    pub min_be: u8_,
    pub max_be: u8_,
    pub csma_retries: u8_,
    pub frame_retries: s8,
    pub lbt: bool_,
    pub ackreq: bool_,
}
pub mod ieee802154_filtering_level {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const IEEE802154_FILTERING_NONE: Type = 0;
    pub const IEEE802154_FILTERING_1_FCS: Type = 1;
    pub const IEEE802154_FILTERING_2_PROMISCUOUS: Type = 2;
    pub const IEEE802154_FILTERING_3_SCAN: Type = 3;
    pub const IEEE802154_FILTERING_4_FRAME_FIELDS: Type = 4;
}
pub mod nl802154_cca_modes {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const __NL802154_CCA_INVALID: Type = 0;
    pub const NL802154_CCA_ENERGY: Type = 1;
    pub const NL802154_CCA_CARRIER: Type = 2;
    pub const NL802154_CCA_ENERGY_CARRIER: Type = 3;
    pub const NL802154_CCA_ALOHA: Type = 4;
    pub const NL802154_CCA_UWB_SHR: Type = 5;
    pub const NL802154_CCA_UWB_MULTIPLEXED: Type = 6;
    pub const __NL802154_CCA_ATTR_AFTER_LAST: Type = 7;
    pub const NL802154_CCA_ATTR_MAX: Type = 6;
}
pub mod nl802154_cca_opts {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL802154_CCA_OPT_ENERGY_CARRIER_AND: Type = 0;
    pub const NL802154_CCA_OPT_ENERGY_CARRIER_OR: Type = 1;
    pub const __NL802154_CCA_OPT_ATTR_AFTER_LAST: Type = 2;
    pub const NL802154_CCA_OPT_ATTR_MAX: Type = 1;
}
pub mod nl802154_supported_bool_states {
    pub type Type = ::aya_bpf::cty::c_uint;
    pub const NL802154_SUPPORTED_BOOL_FALSE: Type = 0;
    pub const NL802154_SUPPORTED_BOOL_TRUE: Type = 1;
    pub const __NL802154_SUPPORTED_BOOL_INVALD: Type = 2;
    pub const NL802154_SUPPORTED_BOOL_BOTH: Type = 3;
    pub const __NL802154_SUPPORTED_BOOL_AFTER_LAST: Type = 4;
    pub const NL802154_SUPPORTED_BOOL_MAX: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_phy_supported {
    pub channels: [u32_; 32usize],
    pub cca_modes: u32_,
    pub cca_opts: u32_,
    pub iftypes: u32_,
    pub lbt: nl802154_supported_bool_states::Type,
    pub min_minbe: u8_,
    pub max_minbe: u8_,
    pub min_maxbe: u8_,
    pub max_maxbe: u8_,
    pub min_csma_backoffs: u8_,
    pub max_csma_backoffs: u8_,
    pub min_frame_retries: s8,
    pub max_frame_retries: s8,
    pub tx_powers_size: usize,
    pub cca_ed_levels_size: usize,
    pub tx_powers: *const s32,
    pub cca_ed_levels: *const s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_phy_cca {
    pub mode: nl802154_cca_modes::Type,
    pub opt: nl802154_cca_opts::Type,
}
#[repr(C)]
pub struct wpan_phy {
    pub privid: *const ::aya_bpf::cty::c_void,
    pub flags: ::aya_bpf::cty::c_ulong,
    pub current_channel: u8_,
    pub current_page: u8_,
    pub supported: wpan_phy_supported,
    pub transmit_power: s32,
    pub cca: wpan_phy_cca,
    pub perm_extended_addr: __le64,
    pub cca_ed_level: s32,
    pub symbol_duration: u32_,
    pub lifs_period: u16_,
    pub sifs_period: u16_,
    pub dev: device,
    pub _net: possible_net_t,
    pub queue_lock: spinlock_t,
    pub ongoing_txs: atomic_t,
    pub hold_txs: atomic_t,
    pub sync_txq: wait_queue_head_t,
    pub filtering: ieee802154_filtering_level::Type,
    pub __bindgen_padding_0: [u8; 4usize],
    pub priv_: __IncompleteArrayField<::aya_bpf::cty::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ieee802154_addr {
    pub mode: u8_,
    pub pan_id: __le16,
    pub __bindgen_anon_1: ieee802154_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ieee802154_addr__bindgen_ty_1 {
    pub short_addr: __le16,
    pub extended_addr: __le64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpan_dev_header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *const ieee802154_addr,
            arg4: *const ieee802154_addr,
            arg5: ::aya_bpf::cty::c_uint,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct action_cache {
    pub allow_native: [::aya_bpf::cty::c_ulong; 8usize],
    pub allow_compat: [::aya_bpf::cty::c_ulong; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp_filter {
    pub refs: refcount_t,
    pub users: refcount_t,
    pub log: bool_,
    pub wait_killable_recv: bool_,
    pub cache: action_cache,
    pub prev: *mut seccomp_filter,
    pub prog: *mut bpf_prog,
    pub notif: *mut notification,
    pub notify_lock: mutex,
    pub wqh: wait_queue_head_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notification {
    pub request: semaphore,
    pub next_id: u64_,
    pub notifications: list_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_kfunc_desc {
    pub func_model: btf_func_model,
    pub func_id: u32_,
    pub imm: s32,
    pub offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_kfunc_desc_tab {
    pub descs: [bpf_kfunc_desc; 256usize],
    pub nr_descs: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_kfunc_btf {
    pub btf: *mut btf,
    pub module: *mut module,
    pub offset: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_kfunc_btf_tab {
    pub descs: [bpf_kfunc_btf; 256usize],
    pub nr_descs: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_verifier_stack_elem {
    pub st: bpf_verifier_state,
    pub insn_idx: ::aya_bpf::cty::c_int,
    pub prev_insn_idx: ::aya_bpf::cty::c_int,
    pub next: *mut bpf_verifier_stack_elem,
    pub log_pos: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    pub list: hlist_head,
    pub has_itree: bool_,
    pub lock: spinlock_t,
    pub invalidate_seq: ::aya_bpf::cty::c_ulong,
    pub active_invalidate_ranges: ::aya_bpf::cty::c_ulong,
    pub itree: rb_root_cached,
    pub wq: wait_queue_head_t,
    pub deferred_list: hlist_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memcg_vmstats {
    pub state: [::aya_bpf::cty::c_long; 50usize],
    pub events: [::aya_bpf::cty::c_ulong; 19usize],
    pub state_pending: [::aya_bpf::cty::c_long; 50usize],
    pub events_pending: [::aya_bpf::cty::c_ulong; 19usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memcg_vmstats_percpu {
    pub state: [::aya_bpf::cty::c_long; 50usize],
    pub events: [::aya_bpf::cty::c_ulong; 19usize],
    pub state_prev: [::aya_bpf::cty::c_long; 50usize],
    pub events_prev: [::aya_bpf::cty::c_ulong; 19usize],
    pub nr_page_events: ::aya_bpf::cty::c_ulong,
    pub targets: [::aya_bpf::cty::c_ulong; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct userfaultfd_ctx {
    pub fault_pending_wqh: wait_queue_head_t,
    pub fault_wqh: wait_queue_head_t,
    pub fd_wqh: wait_queue_head_t,
    pub event_wqh: wait_queue_head_t,
    pub refile_seq: seqcount_spinlock_t,
    pub refcount: refcount_t,
    pub flags: ::aya_bpf::cty::c_uint,
    pub features: ::aya_bpf::cty::c_uint,
    pub released: bool_,
    pub mmap_changing: atomic_t,
    pub mm: *mut mm_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    pub callback_head: callback_head,
    pub event: atomic_t,
    pub poll: wait_queue_head_t,
    pub files: list_head,
    pub nr_mmapped: ::aya_bpf::cty::c_uint,
    pub nr_to_release: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct disk_events {
    pub node: list_head,
    pub disk: *mut gendisk,
    pub lock: spinlock_t,
    pub block_mutex: mutex,
    pub block: ::aya_bpf::cty::c_int,
    pub pending: ::aya_bpf::cty::c_uint,
    pub clearing: ::aya_bpf::cty::c_uint,
    pub poll_msecs: ::aya_bpf::cty::c_long,
    pub dwork: delayed_work,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pse_controller_ops {
    pub ethtool_get_status: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pse_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut netlink_ext_ack,
            arg4: *mut pse_control_status,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub ethtool_set_config: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pse_controller_dev,
            arg2: ::aya_bpf::cty::c_ulong,
            arg3: *mut netlink_ext_ack,
            arg4: *const pse_control_config,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pse_controller_dev {
    pub ops: *const pse_controller_ops,
    pub owner: *mut module,
    pub list: list_head,
    pub pse_control_head: list_head,
    pub dev: *mut device,
    pub of_pse_n_cells: ::aya_bpf::cty::c_int,
    pub of_xlate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pse_controller_dev,
            arg2: *const of_phandle_args,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub nr_lines: ::aya_bpf::cty::c_uint,
    pub lock: mutex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pse_control {
    pub pcdev: *mut pse_controller_dev,
    pub list: list_head,
    pub id: ::aya_bpf::cty::c_uint,
    pub refcnt: kref,
}
